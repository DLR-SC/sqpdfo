# Autogenerated with SMOP version 
# main.py otherfiles/*

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def sqplab_tcg_(A=None,b=None,delta=None,max_iter=None,tol=None,plevel=None,fout=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[A,b,delta,max_iter,tol,plevel,fout].count(None)+len(args)

    x=zeros_(size_(b))
    cost=0
    g=- b
    g2=g.T * g
    tol2=tol * tol
    delta2=delta * delta
    dAd=matlabarray([])
    if plevel:
        fprintf_(fout,char('    TCG solver; required tolerance %8.2e\\n'),tol)
        fprintf_(fout,char('    iter       cost        |res|   curvature  stepsize   |step|\\n'))
    _iter=0
    while 1:

        _iter=_iter + 1
        if plevel:
            fprintf_(fout,char('    %4i  %14.7e  %7.1e'),_iter,cost,sqrt_(g2))
        if g2 <= tol2:
            info.flag=0
            break
        if _iter > max_iter:
            _iter=copy_(max_iter)
            info.flag=- 1
            break
        if _iter == 1:
            d=- g
        else:
            d=- g + (g2 / g2_) * d
        Ad=A * d
        dAd=d.T * Ad
        if plevel:
            fprintf_(fout,char('  %9.2e'),dAd / (d.T * d))
        if dAd <= 0:
            x,alpha=dogleg_(x,x + d,delta,nargout=2)
            info.flag=2
            if plevel:
                fprintf_(fout,char('  %8.2e  %8.2e\\n'),alpha,norm_(x))
                cost=0.5 * (x.T * A * x) - b.T * x
                fprintf_(fout,char('    %4i  %14.7e  %7.1e\\n'),_iter + 1,cost)
            break
        alpha=- (g.T * d) / dAd
        xx=x + alpha * d
        if plevel:
            fprintf_(fout,char('  %8.2e'),alpha)
        if xx.T * xx > delta2:
            x,alpha=dogleg_(x,xx,delta,nargout=2)
            info.flag=1
            if plevel:
                fprintf_(fout,char('  %8.2e  %8.2e\\n'),alpha,norm_(x))
                cost=0.5 * (x.T * A * x) - b.T * x
                fprintf_(fout,char('    %4i  %14.7e  %7.1e\\n'),_iter + 1,cost)
            break
        else:
            x=copy_(xx)
        if plevel:
            fprintf_(fout,char('  %8.2e\\n'),norm_(x))
        g=g + alpha * Ad
        g2_=copy_(g2)
        g2=g.T * g
        if plevel:
            cost=0.5 * (x.T * (g - b))

    info.iter=_iter
    info.prec=sqrt_(g2)
    if not isempty_(dAd):
        info.curv=dAd / (d.T * d)
    return x,info
def dogleg_(dc=None,dn=None,delta=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[dc,dn,delta].count(None)+len(args)

    dd=dn - dc
    aa=dd.T * dd
    if aa == 0:
        dd=copy_(dc)
        t=0
        return dd,t
    bb=dc.T * dd
    cc=dc.T * dc - delta ** 2
    if cc >= 0:
        dd=copy_(dc)
        t=0
        return dd,t
    t=(sqrt_(bb ** 2 - aa * cc) - bb) / aa
    dd=dc + t * dd
    return dd,t
def blls_(A=None,b=None,lb=None,ub=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[A,b,lb,ub].count(None)+len(args)

    m,n=size_(A,nargout=2)
    verbose=0
    epsfeas=1e-12
    epsconv=1e-10
    epsres=1e-11
    maxiter=2 * n
    epsdzer=1e-14
    armijob=0.5
    armijor=0.01
    maxback=15
    inds=matlabarray([arange_(1,n)])
    nit=0
    nuns=0
    ssub=zeros_(n,1)
    exitc=0
    s=min_(max_(pinv_(A) * b,lb),ub)
    res=A * s - b
    resn=norm_(res)
    g=A.T * res
    stry=min_(max_(s - g,lb),ub) - s
    opt=norm_(stry)
    free=find_(stry).T
    atlb=find_(abs_(max_(s - g,lb) - s) <= epsfeas).T
    atub=find_(abs_(min_(s - g,ub) - s) <= epsfeas).T
    latlb=length_(atlb)
    latub=length_(atub)
    lfree=length_(free)
    if (verbose > 0):
        disp_(char(' '))
        disp_(char('   **************************************************************'))
        disp_(char('   *                                                            *'))
        disp_(char('   *                          BLLS                              *'))
        disp_(char('   *                                                            *'))
        disp_(char('   *   a direct bound-constrained linear least-squares solver   *'))
        disp_(char('   *                                                            *'))
        disp_(char('   *                                                            *'))
        disp_(char('   *     (c) Ph. Sampaio, Ph. L. Toint, A. Troeltzsch, 2014     *'))
        disp_(char('   *                                                            *'))
        disp_(char('   **************************************************************'))
        disp_(char(' '))
        disp_([char('     The problem has '),int2str_(n),char(' variables and '),int2str_(m),char(' rows.')])
        disp_(char(' '))
        if (verbose > 2):
            problem_matrix=copy_(A)
            right_hand_side=b.T
            lower_bounds=lb.T
            upper_bounds=ub.T
            disp_(char(' '))
        fprintf_(char('     nit     ||r||    optimality'))
        fprintf_(char('                 nfr nlow nupp\\n\\n'))
        fprintf_(char('   %5d  %.4e  %.4e                %4d %4d %4d\\n'),nit,resn,opt,lfree,latlb,latub)
        if (verbose > 1):
            if (verbose > 2):
                unconstrained_solution=s.T
            disp_(char(' '))
            disp_(char('   --------------------------------------------------------------'))
            disp_(char(' '))
    if (opt <= epsconv or resn <= epsres):
        maxit=0
    else:
        maxit=copy_(maxiter)
    for i in arange_(1,maxit).reshape(-1):
        nit=nit + 1
        if (verbose > 1):
            disp_([char('   Iteration '),int2str_(i)])
            disp_(char(' '))
            fprintf_(char('   Cauchy point projected search\\n'))
            fprintf_(char('       k     ||r||     stepsize'))
            fprintf_(char('                  nfr nlow nupp\\n'))
            fprintf_(char('   %5d  %.4e                            %4d %4d %4d'),0,resn,lfree,latlb,latub)
        g=A.T * res
        alpha=(norm_(g) / norm_(A * g)) ** 2
        for kc in arange_(1,maxback).reshape(-1):
            stry=min_(max_(s - alpha * g,lb),ub)
            dtry=stry - s
            ltry=g.T * dtry
            qtry=ltry + 0.5 * norm_(A * dtry) ** 2
            if (verbose > 1):
                fprintf_(char('\\n   %5d  %.4e  %.4e'),kc,norm_(A * stry - b),alpha)
            if (qtry <= armijor * ltry):
                break
            else:
                alpha=armijob * alpha
        if (kc >= maxback):
            exitc=- 1
            break
        atlb=inds[find_(abs_(stry - lb) <= epsfeas)]
        atub=inds[find_(abs_(stry - ub) <= epsfeas)]
        atb=matlabarray([atlb,atub])
        latlb=length_(atlb)
        latub=length_(atub)
        free=copy_(inds)
        free[atb]=[]
        lfree=length_(free)
        s[atlb]=lb[atlb]
        s[atub]=ub[atub]
        s[free]=stry[free]
        res=A * s - b
        resn=norm_(res)
        if (verbose > 1):
            fprintf_(char('                %4d %4d %4d\\n'),lfree,latlb,latub)
            if (verbose > 2):
                Cauchy_point=s.T
                indices_of_free_variables=copy_(free)
                indices_of_variables_at_their_lower_bound=copy_(atlb)
                indices_of_variables_at_their_upper_bound=copy_(atub)
        if (lfree == 0 or resn <= epsres):
            if (verbose > 1):
                fprintf_(char('   No nested subspace search\\n'))
            opt=0
        else:
            if (verbose > 1):
                fprintf_(char('   Nested subspace search\\n'))
                fprintf_(char('       k     ||r||     stepsize      ||r*||'))
                fprintf_(char('      nfr nlow nupp\\n'))
                fprintf_(char('   %5d  %.4e                            %4d %4d %4d\\n'),0,resn,lfree,latlb,latub)
            for k in arange_(1,n).reshape(-1):
                if (verbose > 2):
                    disp_([char('    > Solving in subspace '),int2str_(k)])
                    indices_of_free_variables=copy_(free)
                    indices_of_variables_at_their_lower_bound=copy_(atlb)
                    indices_of_variables_at_their_upper_bound=copy_(atub)
                rhs=copy_(b)
                if not isempty_(atlb):
                    rhs=rhs - A[1:m,atlb] * lb[atlb]
                if not isempty_(atub):
                    rhs=rhs - A[1:m,atub] * ub[atub]
                ssub[free]=pinv_(A[1:m,free]) * rhs
                ssub[atlb]=lb[atlb]
                ssub[atub]=ub[atub]
                rsubo=A * ssub - b
                rsubon=norm_(rsubo)
                natlb=find_(ssub[free] < lb[free])
                natub=find_(ssub[free] > ub[free])
                lnatb=length_(natlb) + length_(natub)
                if (lnatb > 0):
                    alpha=1
                    dtry=ssub - s
                    rred=rsubon - resn
                    found=0
                    nback=4 * (1 - nuns)
                    for kb in arange_(1,nback).reshape(-1):
                        stry=(1 - alpha) * s + alpha * ssub
                        natlbt=free[find_(stry[free] < lb[free])]
                        natubt=free[find_(stry[free] > ub[free])]
                        lnatbt=length_(natlbt) + length_(natubt)
                        stry=min_(max_(stry,lb),ub)
                        if (verbose >= 1):
                            rtry=A * stry - b
                            rtryn=norm_(rtry)
                            atlbt=matlabarray([atlb,natlbt])
                            atubt=matlabarray([atub,natubt])
                            atbt=matlabarray([atlbt,atubt])
                            freet=copy_(inds)
                            freet[atbt]=[]
                            latlbt=length_(atlbt)
                            latubt=length_(atubt)
                            lfreet=length_(freet)
                            fprintf_(char('   %5dp %.4e  %.4e   %.4e   %4d %4d %4d\\n'),kb,rtryn,alpha,rsubon,lfreet,latlbt,latubt)
                        if (lnatbt == 0):
                            break
                        if (verbose == 0):
                            rtry=A * stry - b
                            rtryn=norm_(rtry)
                        if (rtryn <= resn - armijor * alpha * rred):
                            s=copy_(stry)
                            res=copy_(rtry)
                            resn=copy_(rtryn)
                            if (verbose == 0):
                                atlb=matlabarray([atlb,natlbt])
                                atub=matlabarray([atub,natubt])
                                atb=matlabarray([atlb,atub])
                                free=copy_(inds)
                                free[atb]=[]
                                latlb=length_(atlb)
                                latub=length_(atub)
                                lfree=length_(free)
                            else:
                                atlb=copy_(atlbt)
                                atub=copy_(atubt)
                                free=copy_(freet)
                                latlb=copy_(latlbt)
                                latub=copy_(latubt)
                                lfree=copy_(lfreet)
                            found=1
                            break
                        alpha=armijob * alpha
                    if (found):
                        break
                    else:
                        if (kb >= nback):
                            nuns=nuns + 1
                        alpha=1
                        for kf in arange_(1,length_(free)).reshape(-1):
                            kk=free[kf]
                            if (dtry[kk] >= epsdzer):
                                alpha=min_(alpha,(ub[kk] - s[kk]) / dtry[kk])
                            else:
                                if (dtry[kk] <= - epsdzer):
                                    alpha=min_(alpha,(lb[kk] - s[kk]) / dtry[kk])
                        ssub=s + alpha * dtry
                        rsub=(1 - alpha) * res + alpha * rsubo
                        rsubn=norm_(rsub)
                        if (verbose > 1):
                            fprintf_(char('   %5ds %.4e  %.4e   %.4e   %4d %4d %4d\\n'),k,rsubn,alpha,rsubon,lfree,latlb,latub)
                        natlb=free[find_(abs_(ssub[free] - lb[free]) <= epsfeas)]
                        natub=free[find_(abs_(ssub[free] - ub[free]) <= epsfeas)]
                        atlb=matlabarray([atlb,natlb])
                        atub=matlabarray([atub,natub])
                        atb=matlabarray([atlb,atub])
                        free=copy_(inds)
                        free[atb]=[]
                        latlb=length_(atlb)
                        latub=length_(atub)
                        lfree=length_(free)
                        if (verbose > 2):
                            current_subspace_solution=ssub.T
                            indices_of_free_variables=copy_(free)
                            indices_of_variables_at_their_lower_bound=copy_(atlb)
                            indices_of_variables_at_their_upper_bound=copy_(atub)
                        s=copy_(ssub)
                        res=copy_(rsub)
                        resn=copy_(rsubn)
                else:
                    s=copy_(ssub)
                    res=copy_(rsubo)
                    resn=copy_(rsubon)
                    if (verbose > 1):
                        fprintf_(char('   %5df %.4e  %.4e   %.4e   %4d %4d %4d\\n'),k,resn,1,resn,lfree,latlb,latub)
                        if (verbose > 2):
                            current_subspace_solution=ssub.T
                            indices_of_variables_at_their_lower_bound=copy_(atlb)
                            indices_of_variables_at_their_upper_bound=copy_(atub)
                            free
                    break
            opt=norm_(min_(max_(s - A.T * res,lb),ub) - s)
        if (verbose == 1):
            fprintf_(char('   %5d  %.4e  %.4e                %4d %4d %4d\\n'),nit,resn,opt,lfree,latlb,latub)
        else:
            if (verbose > 1):
                disp_(char(' '))
                fprintf_(char('     nit    ||r||     optimality'))
                fprintf_(char('                 nfr nlow nupp\\n\\n'))
                fprintf_(char('   %5d  %.4e  %.4e                %4d %4d %4d\\n'),nit,resn,opt,lfree,latlb,latub)
                if (verbose > 2):
                    current_solution=s.T
                    indices_of_free_variables=copy_(free)
                    indices_of_variables_at_their_lower_bound=copy_(atlb)
                    indices_of_variables_at_their_upper_bound=copy_(atub)
                disp_(char('   --------------------------------------------------------------'))
                disp_(char(' '))
        if (opt <= epsconv or resn <= epsres):
            break
    if (exitc == 0 and nit >= maxiter):
        exitc=1
    if (verbose > 0):
        disp_(char(' '))
        if (verbose > 2):
            indices_of_free_variables=copy_(free)
            indices_of_variables_at_their_lower_bound=copy_(atlb)
            indices_of_variables_at_their_upper_bound=copy_(atub)
            final_solution=s.T
            final_residual=res.T
        if (exitc == 1):
            disp_(char('   !!! maxit reached !!!'))
            keyboard
        else:
            if (exitc == - 1):
                disp_(char('   !!! Cauchy point calculation failure :-(  !!!'))
            else:
                disp_(char('   ---> Solved.'))
        disp_(char(' '))
    return s,resn,opt,exitc
def history_(*args,**kwargs):
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    A=matlabarray([0,NaN,1.0])
    return A
def evalfgh_(key=None,xy=None,lm=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[key,xy,lm].count(None)+len(args)

    global fileoutput,simul_not_initialized
    global foutxy
    global n,nb,mi,me,_iter,prob
    msg=matlabarray([])
    out2=matlabarray([])
    out3=matlabarray([])
    out4=matlabarray([])
    out5=matlabarray([])
    out6=matlabarray([])
    out7=matlabarray([])
    out8=matlabarray([])
    if simul_not_initialized:
        foutxy=fopen_(char('results.out'),char('w'))
        _iter=0
        simul_not_initialized=0
    if key == 1:
        if nargin < 1:
            fprintf_(fileoutput,char('\\n(simulopt) >>> not enough input arguments (%0i < 1) with key = %0i\\n\\n'),nargin,key)
            msg=- 2
            return msg,out2,out3,out4
    else:
        if key == 2:
            if nargin < 2:
                fprintf_(fileoutput,char('\\n(simulopt) >>> not enough input arguments (%0i < 2) with key = %0i\\n\\n'),nargin,key)
                msg=- 2
                return msg,out2,out3,out4
            msg,out2,out3,out4=ecdfo_func_(xy,nargout=4)
        else:
            if key == 5:
                if nargin < 3:
                    fprintf_(fileoutput,char('\\n(simulopt) >>> not enough input arguments (%0i < 3) with key = %0i\\n\\n'),nargin,key)
                    msg=- 2
                    return msg,out2,out3,out4
                if nargout < 2:
                    fprintf_(fileoutput,char('\\n(simulopt) >>> not enough output arguments (%0i < 2) with key = %0i\\n\\n'),nargout,key)
                    msg=- 2
                    return msg,out2,out3,out4
                msg,out2=ecdfo_hessian_lagr_(xy,lm,nargout=2)
            else:
                fprintf_(fileoutput,char('\\n(simulopt) >>> unexpected value of key (=%i)\\n\\n'),key)
                msg=- 2
                return msg,out2,out3,out4
    return msg,out2,out3,out4
def sqplab_badsimul_(outdic=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[outdic,info,options,values].count(None)+len(args)

    if outdic == 2:
        if options.verbose:
            fprintf_(options.fout,char('\\n\\n### sqplab: the simulator wants to stop\\n'))
        info.flag=values.stop_on_simul
    else:
        if outdic > 2:
            if options.verbose:
                fprintf_(options.fout,char('\\n\\n### sqplab: error with the simulator (outdic = %0i)\\n'),outdic)
            info.flag=values.fail_on_simul
    return info
def sqplab_bfgs_(M=None,y=None,s=None,first=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[M,y,s,first,info,options,values].count(None)+len(args)

    eta=0.2
    n=length_(s)
    pc=1
    info.flag=values.success
    if norm_(s) == 0:
        info.flag=values.fail_strange
        if options.verbose >= 3:
            fprintf_(options.fout,char('\\n### sqplab_bfgs: null step s\\n\\n'))
        return M,pc,info,values
    ys=y.T * s
    if options.verbose >= 4:
        fprintf_(options.fout,char(" y'*s/(s'*s) = %9.3e\\n"),ys / (s.T * s))
    Ms=M * s
    sMs=s.T * Ms
    if sMs <= 0:
        info.flag=values.fail_strange
        if options.verbose >= 3:
            fprintf_(options.fout,char('\\n### sqplab_bfgs: BFGS Hessian approximation is not positive definite:\\n'))
            fprintf_(options.fout,char("            s'*M*s = %g <= 0\\n\\n"),sMs)
        return M,pc,info,values
    if (options.algo_descent == values.powell) and (ys < eta * sMs):
        pc=(1 - eta) * sMs / (sMs - ys)
        if options.verbose >= 4:
            fprintf_(options.fout,char("  Powell's corrector = %7.1e\\n"),pc)
        y=pc * y + (1 - pc) * Ms
        ys=y.T * s
        if options.verbose >= 4:
            fprintf_(options.fout,char(" (new y'*s/(s'*s) = %7.1e\\n)"),ys / (s.T * s))
        if ys <= 0:
            info.flag=values.fail_strange
            if options.verbose >= 4:
                fprintf_(options.fout,char("\\n### sqplab_bfgs: y'*s = %9.3e not positive despite correction:\\n\\n"),ys).T
            return M,pc,info,values
    else:
        if ys <= 0:
            if options.verbose >= 4:
                fprintf_(options.fout,char("\\n### sqplab_bfgs: y'*s = %9.3e is nonpositive\\n\\n"),ys).T
            info.flag=values.fail_strange
            return M,pc,info,values
    if first:
        ol=(y.T * y) / ys
        M=ol * eye_(n)
        if options.verbose >= 4:
            fprintf_(options.fout,char('  OL coefficient = %g\\n'),ol)
        Ms=ol * s
        sMs=s.T * Ms
    M=M - (Ms * Ms.T) / sMs + (y * y.T) / ys
    if options.verbose >= 6:
        eigM=sort_(eig_(M))
        fprintf_(options.fout,char('  eig(M): min = %g, max = %g, cond = %g\\n'),min_(eigM),max_(eigM),max_(eigM) / min_(eigM))
    return M,pc,info,values
def sqplab_checkoptions_(nb=None,mi=None,me=None,ms=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[nb,mi,me,ms,info,options,values].count(None)+len(args)

    info.flag=values.success
    if options.algo_method == values.cheap_quasi_newton:
        if options.verbose:
            fprintf_(options.fout,char('\\n### sqplab_checkoptions: the cheap quasi-Newton method is not a valid\\n'))
            fprintf_(options.fout,char('### approach when there is no state constraint\\n\\n'))
        info.flag=values.fail_on_problem
        return info,options
    if values.unit_stepsize == options.algo_globalization:
        if options.algo_method != values.newton:
            if not isfield_(options,char('algo_descent')):
                if options.verbose:
                    fprintf_(options.fout,char('\\n### sqplab_checkoptions: positive definiteness of the matrices is ensured\\n'))
                    fprintf_(options.fout,char('### by Powell corrections\\n\\n'))
                options.algo_descent=values.powell
            else:
                if options.algo_descent == values.wolfe:
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### sqplab_checkoptions: positive definiteness of the matrices cannot be ensured\\n'))
                        fprintf_(options.fout,char('### by the Wolfe linesearch when unit stepsize is required; Powell corrections\\n'))
                        fprintf_(options.fout,char('### will be used instead\\n\\n'))
                    options.algo_descent=values.powell
    else:
        if values.linesearch == options.algo_globalization:
            if options.algo_method == values.newton:
                if isfield_(options,char('algo_descent')):
                    if options.verbose:
                        fprintf_(options.fout,char("\\n### sqplab_checkoptions: descent cannot be ensured for Newton's method\\n"))
                        fprintf_(options.fout,char('### by using Powell corrections or Wolfe linesearch\\n\\n'))
                    info.flag=values.fail_on_argument
                    return info,options
                else:
                    if options.verbose:
                        fprintf_(options.fout,char("\\n### sqplab_checkoptions: Armijo's linesearch can fail with Newton's method,\\n"))
                        fprintf_(options.fout,char('###                      use unit step-size instead\\n\\n'))
            else:
                if not isfield_(options,char('algo_descent')):
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### sqplab_checkoptions: descent ensured by Powell corrections\\n'))
                        if nb + mi + me + ms == 0:
                            fprintf_(options.fout,char('### setting "options.algo_descent = \'Wolfe\'" should be better\\n\\n'))
                    options.algo_descent=values.powell
                else:
                    if (options.algo_descent == values.wolfe) and (nb + mi + me + ms != 0):
                        if options.verbose:
                            fprintf_(options.fout,char('\\n### sqplab_checkoptions: positive definiteness of the matrices cannot be ensured\\n'))
                            fprintf_(options.fout,char('### by the Wolfe linesearch when constraints are present; Powell corrections\\n'))
                            fprintf_(options.fout,char('### will be used instead\\n\\n'))
                        options.algo_descent=values.powell
    return info,options
def sqplab_lsmult_(x=None,lb=None,ub=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[x,lb,ub,info,options,values].count(None)+len(args)

    lm=matlabarray([])
    info.flag=values.success
    badcond=0
    n=length_(info.g)
    me=0
    if (nargin >= 3):
        me=size_(info.ae,1)
    if (nargin < 4) or isempty_(lb):
        lb=- options.inf * ones_(n,1)
    else:
        lb=lb[:]
        if any_(size_(lb) != [n,1]):
            fprintf_(char('\\n### sqplab_lsmult: incorrect size of lb\\n\\n'))
            info.flag=values.fail_strange
            return lm,info
    if (nargin < 5) or isempty_(ub):
        ub=options.inf * ones_(n,1)
    else:
        ub=ub[:]
        if any_(size_(ub) != [n,1]):
            fprintf_(char('\\n### sqplab_lsmult: incorrect size of ub\\n\\n'))
            info.flag=values.fail_strange
            return lm,info
    A=matlabarray([[eye_(n)],[info.ae]])
    lo=- inf * ones_(n + me,1)
    up=inf * ones_(n + me,1)
    for i in arange_(1,n).reshape(-1):
        if (lb[i] <= - options.inf):
            lo[i]=0
        if (ub[i] >= options.inf):
            up[i]=0
        if (lb[i] > - options.inf) and (abs_(x[i] - lb[i]) < options.dxmin):
            up[i]=0
        if (ub[i] < options.inf) and (abs_(x[i] - ub[i]) < options.dxmin):
            lo[i]=0
    AA=A * A.T
    check_condition=0
    if check_condition:
        cthreshold=1e+17
        AA,badcond=ecdfo_check_cond_(AA,cthreshold,options,nargout=2)
    check_convex=1
    if check_convex:
        AA=ecdfo_check_convex_(AA,options)
    Ag=A * info.g
    AAn=copy_(AA)
    Agn=copy_(Ag)
    lon=copy_(lo)
    upn=copy_(up)
    ifree=ones_(size_(lo))
    k=1
    for i in arange_(1,length_(lo)).reshape(-1):
        if lo[i] == up[i]:
            AAn[k,:]=[]
            AAn[:,k]=[]
            Agn[k]=[]
            lon[k]=[]
            upn[k]=[]
            ifree[i]=0
        else:
            k=k + 1
    if not isempty_(ifree[ifree > 0]):
        sn,rn,op,exitc=blls_(AAn,- Agn,lon,upn,nargout=4)
        I=eye_(length_(lo))
        lm=I[:,ifree > 0] * sn
    else:
        lm=zeros_(size_(lo))
    return lm,info
def sqplab_options_(info=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[info,options].count(None)+len(args)

    values.success=0
    values.fail_on_argument=1
    values.fail_on_problem=2
    values.fail_on_simul=3
    values.stop_on_simul=4
    values.stop_on_max_iter=5
    values.stop_on_max_simul=6
    values.stop_on_dxmin=7
    values.fail_on_non_decrease=8
    values.fail_on_ascent_dir=9
    values.fail_on_max_ls_iter=10
    values.fail_on_ill_cond=11
    values.stop_on_small_trust_region=15
    values.fail_on_null_step=20
    values.fail_on_infeasible_QP=21
    values.fail_on_unbounded_QP=22
    values.fail_strange=99
    values.nsimultype=16
    values.max_null_steps=1
    values.newton=100
    values.quasi_newton=101
    values.cheap_quasi_newton=102
    values.unit_stepsize=110
    values.linesearch=111
    values.trust_regions=112
    values.powell=120
    values.wolfe=121
    values.bfgs=130
    values.model=131
    info.flag=values.success
    if isempty_(options):
        options.xxx=0
    if isfield_(options,char('fout')):
        if options.fout < 0:
            fprintf_(char('\\n### ecdfo: options.fout = "%0i" is not a valid file identifier (use \'fopen\' to have a valid one)'),options.fout)
            fprintf_(char('\\n            options.fout is set to 1\\n\\n'))
            options.fout=1
    else:
        options.fout=1
    if isfield_(options,char('verbose')):
        if (options.verbose < 0) or (options.verbose > 6):
            fprintf_(options.fout,char('\\n### ecdfo: options.verbose = "%0i" and should be in [0,6], reset to 1\\n\\n'),options.verbose)
            options.verbose=1
    else:
        options.verbose=1
    if isfield_(options,char('algo_method')):
        if char('newton') == lower___(regexprep___(strtrim___(options.algo_method),char('  *'),char(' '))):
            options.algo_method=values.newton
        else:
            if [char('quasi-newton'),char('quasi newton'),char('quasinewton')] == lower___(regexprep___(strtrim___(options.algo_method),char('  *'),char(' '))):
                options.algo_method=values.quasi_newton
            else:
                if [char('cheap quasi-newton'),char('cheap quasi newton'),char('cheap quasinewton')] == lower___(regexprep___(strtrim___(options.algo_method),char('  *'),char(' '))):
                    options.algo_method=values.cheap_quasi_newton
                else:
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### ecdfo: options.algo_method "%s" not recognized\\n\\n'),options.algo_method)
                    info.flag=values.fail_on_argument
                    return info,options,values
    else:
        options.algo_method=values.quasi_newton
    if isfield_(options,char('algo_globalization')):
        if [char('unit step-size'),char('unit stepsize')] == lower___(regexprep___(strtrim___(options.algo_globalization),char('  *'),char(' '))):
            options.algo_globalization=values.unit_stepsize
        else:
            if [char('line-search'),char('linesearch')] == lower___(regexprep___(strtrim___(options.algo_globalization),char('  *'),char(' '))):
                options.algo_globalization=values.linesearch
            else:
                if [char('trust regions'),char('trust-regions'),char('trustregions')] == lower___(regexprep___(strtrim___(options.algo_globalization),char('  *'),char(' '))):
                    options.algo_globalization=values.trust_regions
                else:
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### ecdfo: options.algo_globalization "%s" not recognized\\n\\n'),options.algo_globalization)
                    info.flag=values.fail_on_argument
                    return info,options,values
    else:
        options.algo_globalization=values.linesearch
    if isfield_(options,char('algo_descent')):
        if char('powell') == lower__(regexprep__(strtrim__(options.algo_descent),char('  *'),char(' '))):
            options.algo_descent=values.powell
        else:
            if char('wolfe') == lower__(regexprep__(strtrim__(options.algo_descent),char('  *'),char(' '))):
                options.algo_descent=values.wolfe
            else:
                if options.verbose:
                    fprintf_(options.fout,char('\\n### ecdfo: options.algo_descent "%s" not recognized\\n\\n'),options.algo_descent)
                info.flag=values.fail_on_argument
                return info,options,values
    if isfield_(options,char('dxmin')):
        if (options.dxmin <= 0):
            if options.verbose:
                fprintf_(options.fout,char('\\n### ecdfo: options.dxmin = %g must be > 0\\n\\n'),options.dxmin)
            info.flag=values.fail_on_argument
            return info,options,values
    else:
        options.dxmin=1e-08
    if isfield_(options,char('inf')):
        if options.inf <= 0:
            if options.verbose:
                fprintf_(char('\\n### ecdfo: incorrect value of options.inf %g (should be > 0)\\n\\n'),options.inf)
            info.flag=values.fail_on_argument
            return info,options,values
    else:
        options.inf=inf
    if isfield_(options,char('miter')):
        if options.miter <= 0:
            if options.verbose:
                fprintf_(char('\\n### ecdfo: incorrect value of options.miter %g (should be > 0)\\n\\n'),options.miter)
            info.flag=values.fail_on_argument
            return info,options,values
    else:
        options.miter=1000
    if isfield_(options,char('tol')):
        if any_(options.tol <= 0):
            if options.verbose:
                fprintf_(char('\\n### ecdfo: incorrect value of some options.tol (should be > 0)\\n\\n'))
            info.flag=values.fail_on_argument
            return info,options,values
    else:
        options.tol=[[1e-06],[1e-06],[1e-06]]
    if not isfield_(options,char('df1')):
        options.df1=0
    if isfield_(options,char('hess_approx')):
        if char('bfgs') == lower__(regexprep__(strtrim__(options.hess_approx),char('  *'),char(' '))):
            options.hess_approx=values.bfgs
        else:
            if char('model') == lower__(regexprep__(strtrim__(options.hess_approx),char('  *'),char(' '))):
                options.hess_approx=values.model
            else:
                if options.verbose:
                    fprintf_(options.fout,char('\\n### ecdfo: options.hess_approx "%s" not recognized\\n\\n'),options.hess_approx)
                info.flag=values.fail_on_argument
                return info,options,values
    return info,options,values
