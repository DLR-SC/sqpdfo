# -*- coding: utf-8 -*-
"""
Created on Thu Nov 13 14:20:08 2014
% [] = ecdfo_finish (nb,mi,me,info,options,values)
%
% Prints output status
%
%-----------------------------------------------------------------------

% Authors: Jean Charles Gilbert, INRIA.
%      and Anke Troeltzsch, DLR.
%
% Copyright 2008, 2009, INRIA. 2013, DLR.
%
% ecdfo is distributed under the terms of the Q Public License version
% 1.0.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Q Public
% License version 1.0 for more details.
%
% You should have received a copy of the Q Public License version 1.0
% along with this program.  If not, see
% <http://doc.trolltech.com/3.0/license.html>.
%
%-----------------------------------------------------------------------

%===============================================================================

@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py ecdfo_finish.m

from __future__ import division
#try:
from runtime import *
#except ImportError:
    #from smop.runtime import *
def ecdfo_finish_(nb=None,mi=None,me=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[nb,mi,me,info,options,values].count(None)+len(args)

    if options.verbose >= 2:
        fprintf_(options.fout,char('%s\\n'),values.dline)
        fprintf_(options.fout,char('  Exit code %i: '),info.flag)
        if values.success == info.flag:
            fprintf_(options.fout,char('converged'))
        else:
            if values.fail_on_argument == info.flag:
                fprintf_(options.fout,char('wrong argument'))
            else:
                if values.fail_on_problem == info.flag:
                    fprintf_(options.fout,char('unaccepted problem structure'))
                else:
                    if values.fail_on_simul == info.flag:
                        fprintf_(options.fout,char('error when calling the simulator'))
                    else:
                        if values.stop_on_simul == info.flag:
                            fprintf_(options.fout,char('the simulator wants to stop'))
                        else:
                            if values.stop_on_max_iter == info.flag:
                                fprintf_(options.fout,char('max iteration reached'))
                            else:
                                if values.stop_on_max_simul == info.flag:
                                    fprintf_(options.fout,char('max simulation reached'))
                                else:
                                    if values.stop_on_dxmin == info.flag:
                                        fprintf_(options.fout,char('too small variation in x (dxmin active)'))
                                    else:
                                        if values.fail_on_non_decrease == info.flag:
                                            fprintf_(options.fout,char('the merit function cannot be decreased'))
                                        else:
                                            if values.fail_on_ascent_dir == info.flag:
                                                fprintf_(options.fout,char('ascent direction encountered in linesearch'))
                                            else:
                                                if values.fail_on_max_ls_iter == info.flag:
                                                    fprintf_(options.fout,char('too many stepsize trials in linesearch'))
                                                else:
                                                    if values.fail_on_ill_cond == info.flag:
                                                        fprintf_(options.fout,char('ill conditioning'))
                                                    else:
                                                        if values.fail_on_null_step == info.flag:
                                                            fprintf_(options.fout,char('null step d is solution of %0i QPs'),values.max_null_steps + 1)
                                                        else:
                                                            if values.fail_on_infeasible_QP == info.flag:
                                                                fprintf_(options.fout,char('infeasible QP'))
                                                            else:
                                                                if values.fail_on_unbounded_QP == info.flag:
                                                                    fprintf_(options.fout,char('unbounded QP'))
                                                                else:
                                                                    if values.fail_strange == info.flag:
                                                                        fprintf_(options.fout,char('strange failure, call a guru'))
                                                                    else:
                                                                        if values.stop_on_small_trust_region == info.flag:
                                                                            fprintf_(options.fout,char('trust region radius small'))
        fprintf_(options.fout,char('\\n'))
        fprintf_(options.fout,char('%s\\n'),values.dline)
        fprintf_(options.fout,char('  Final function value                     %12.5e\\n'),info.f)
        fprintf_(options.fout,char('  Optimality conditions:\\n'))
        if nb + mi + me > 0:
            fprintf_(options.fout,char('  . gradient of the Lagrangian (inf norm)  %11.5e\\n'),info.glagn)
            fprintf_(options.fout,char('  . feasibility                            %11.5e\\n'),info.feasn)
            if nb + mi:
                fprintf_(options.fout,char('  . complementarity                        %11.5e\\n'),info.compl)
        else:
            fprintf_(options.fout,char('  Gradient of the cost function (inf norm)  %11.5e\\n'),info.glagn)
        fprintf_(options.fout,char('  Counters:\\n'))
        fprintf_(options.fout,char('  . nbr of iterations                   %4i\\n'),info.niter)
        fprintf_(options.fout,char('  . nbr of function evaluations         %4i\\n'),info.nsimul(2) + info.nsimul(4))
        fprintf_(options.fout,char('  . nbr of gradient evaluations         %4i\\n'),info.nsimul(3) + info.nsimul(4))
    fprintf_(options.fout,char('%s\\n'),values.sline)
    return
#def ecdfo_finish_(nb=None,mi=None,me=None,info=None,options=None,values=None,*args,**kwargs):
#    #varargin = cellarray(args)
#    #nargin = 6-[nb,mi,me,info,options,values].count(None)+len(args)
#
#    if options.verbose >= 2:
#        fprintf_(options.fout,char('%s\\n'),values.dline)
#        fprintf_(options.fout,char('  Exit code %i: '),info.flag)
#        if values.success == info.flag:
#            fprintf_(options.fout,char('converged'))
#        else:
#            if values.fail_on_argument == info.flag:
#                fprintf_(options.fout,char('wrong argument'))
#            else:
#                if values.fail_on_problem == info.flag:
#                    fprintf_(options.fout,char('unaccepted problem structure'))
#                else:
#                    if values.fail_on_simul == info.flag:
#                        fprintf_(options.fout,char('error when calling the simulator'))
#                    else:
#                        if values.stop_on_simul == info.flag:
#                            fprintf_(options.fout,char('the simulator wants to stop'))
#                        else:
#                            if values.stop_on_max_iter == info.flag:
#                                fprintf_(options.fout,char('max iteration reached'))
#                            else:
#                                if values.stop_on_max_simul == info.flag:
#                                    fprintf_(options.fout,char('max simulation reached'))
#                                else:
#                                    if values.stop_on_dxmin == info.flag:
#                                        fprintf_(options.fout,char('too small variation in x (dxmin active)'))
#                                    else:
#                                        if values.fail_on_non_decrease == info.flag:
#                                            fprintf_(options.fout,char('the merit function cannot be decreased'))
#                                        else:
#                                            if values.fail_on_ascent_dir == info.flag:
#                                                fprintf_(options.fout,char('ascent direction encountered in linesearch'))
#                                            else:
#                                                if values.fail_on_max_ls_iter == info.flag:
#                                                    fprintf_(options.fout,char('too many stepsize trials in linesearch'))
#                                                else:
#                                                    if values.fail_on_ill_cond == info.flag:
#                                                        fprintf_(options.fout,char('ill conditioning'))
#                                                    else:
#                                                        if values.fail_on_null_step == info.flag:
#                                                            fprintf_(options.fout,char('null step d is solution of %0i QPs'),values.max_null_steps + 1)
#                                                        else:
#                                                            if values.fail_on_infeasible_QP == info.flag:
#                                                                fprintf_(options.fout,char('infeasible QP'))
#                                                            else:
#                                                                if values.fail_on_unbounded_QP == info.flag:
#                                                                    fprintf_(options.fout,char('unbounded QP'))
#                                                                else:
#                                                                    if values.fail_strange == info.flag:
#                                                                        fprintf_(options.fout,char('strange failure, call a guru'))
#                                                                    else:
#                                                                        if values.stop_on_small_trust_region == info.flag:
#                                                                            fprintf_(options.fout,char('trust region radius small'))
#        fprintf_(options.fout,char('\\n'))
#        fprintf_(options.fout,char('%s\\n'),values.dline)
#        fprintf_(options.fout,char('  Final function value                     %12.5e\\n'),info.f)
#        fprintf_(options.fout,char('  Optimality conditions:\\n'))
#        if nb + mi + me > 0:
#            fprintf_(options.fout,char('  . gradient of the Lagrangian (inf norm)  %11.5e\\n'),info.glagn)
#            fprintf_(options.fout,char('  . feasibility                            %11.5e\\n'),info.feasn)
#            if nb + mi:
#                fprintf_(options.fout,char('  . complementarity                        %11.5e\\n'),info.compl)
#        else:
#            fprintf_(options.fout,char('  Gradient of the cost function (inf norm)  %11.5e\\n'),info.glagn)
#        fprintf_(options.fout,char('  Counters:\\n'))
#        fprintf_(options.fout,char('  . nbr of iterations                   %4i\\n'),info.niter)
#        fprintf_(options.fout,char('  . nbr of function evaluations         %4i\\n'),info.nsimul[2] + info.nsimul[4])
#        fprintf_(options.fout,char('  . nbr of gradient evaluations         %4i\\n'),info.nsimul[3] + info.nsimul[4])
#    fprintf_(options.fout,char('%s\\n'),values.sline)
#    return
