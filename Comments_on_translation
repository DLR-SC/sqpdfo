Comments on translation
================

This file helps us find the bugs when doing the translation from matlab to python code.

BCDFO files :

These files have been (hand?)-translated by Dr. TrÃ¶ltzsch Anke and therefore use normal python arrays. We therefore have to be careful with indices.

Besides the known issues notified on gitlab, this is what we have to be careful with :
-Lot of bugs were found on bcdfo_solve_TR_MS/bcdfo_solve_TR_MS_bc and thus more tests if we have time could reveal more.
-Almost all functions were tested with whichmodel=0, therefore more tests if we have time with other values of whichmodel could be important.

ECDFO files :

These files have been translated by SMOP, i.e. automatic translation. These are the known points which give issues with this automatic translation :

-This kind of  matlab code
	Z  = [ ones( 1, m ); X(1:n,1:m); 0.5*X(1:ndiag,1:m).^2 ];
 is automatically converted like this :
    Z=matlabarray([[ones_(1,m)],[X[1:n,1:m]],[0.5 * X[1:ndiag,1:m] ** 2]])
 which does not work and has to be dealt with a code like this :
           Z[1,:]=ones_(1,m)
           Z[2:nlin+1,:]=X[1:nlin,1:m]
           Z[nlin+2:nlin+1+ndiag,:]=0.5 * X[1:ndiag,1:m] ** 2
  This is not easy to translate because we have to count the indices, but maybe there is a better way not found yet. => to test with code like (equivalent to end+1 in matlab I think)  :    
        a[a.shape[0]+1,1:3] = 123
        a[a.shape[0]+1,1:3] = 123
        a[a.shape[0]+1,1:3] = 123
  
-The matlab elsif are automatically translated with else..if instead of elif

-Analogue translation to (length_(find_(not isreal_(H))) != 0) are not correct, the correct version is to replace 'not' by '~'

-roots function from matlab has to be handled in python like in the following example :
   root  = roots([norm(V(:,imu))^2 2*V(:,imu)'*scri nscri^2-Delta^2]);
   s     = scri + root(1)*V(:,imu);
  IS TRANSLATED IN PYTHON BY :
    p2=poly1d_([norm_(V[:,imu]) ** 2,2 * V[:,imu].T * scri,nscri ** 2 - Delta ** 2])
    root=max(p2.r) #CAREFUL, p2.r is an ARRAY and not a MATLABARRAY, therefore we use max from numpy and not max_ from runtime
    s=scri + root * V[:,imu]

-The disp_ and fprint_ have not been dealt with yet, but they eventually will have to be modified.

-When multiplying a number by a matrix, the number must be first in python. For instance, 3*matlabarray([[-0.10526316,  0.9944444 ]]) and NOT matlabarray([[-0.10526316,  0.9944444 ]])*3.

-Python will addition matrix which do not have the same dimension without giving some kind of errors or warnings. Therefore checking dimensions of matrices might sometimes be useful.

PROBLEMS FROM AUTOMATIC TRANSLATION WHICH HAVE APPARENTLY BEEN DEALT WITH (but we are keeping them close just in case):

-Matrices like V[:,a] where a is a integer (and not an interval like 3:5) always gives as a result a line vector such as matlabarray([[-0.10526316,  0.9944444 ]]). Therefore we have to transpose it. I tried to figure out a way
to modify it inside runtime.py, but if I am not wrong, this vectorization as a line vector happens during the call to np.ndarry.__getitem__(self,indices) at the end of the function def(self,index), therefore it is difficult to modify it.

-cholesky function in python does not give an answer when the matrix is not definite positive (whereas matlab does) and raises instead an exception  : therefore they have to be handle differently (cf bcdfo_solve_TR_MS for an instance)

-The eig_(A,1) function in python give the eigenvalues like matlab BUT :
	the eig_(A,2) function gives FIRST the eigenvalues and only SECOND the eigenvectors, which is the reverse order in matlab.
	the eig_(A,2) function gives the eigenvalues(in the first place) as a VECTOR, whereas it is a diagonal matrix in matlab (in the second place).
	
-The U,S,V=svd_(A,0,nargout=3) function gives S as a vector and not as a diagonal matrix like in matlab 