Comments on translation
================

This file helps us find the bugs when doing the translation from matlab to python code.

BCDFO files translated by Dr. Tröltzsch Anke:

These files have been (hand?)-translated by Dr. Tröltzsch Anke and therefore use normal python arrays. We therefore have to be careful with indices.

Besides the known issues notified on gitlab, this is what we have to be careful with :
-Lot of bugs were found on bcdfo_solve_TR_MS/bcdfo_solve_TR_MS_bc and thus more tests if we have time could reveal more.
-Almost all functions were tested with whichmodel=0, therefore more tests if we have time with other values of whichmodel could be important.

BCDFO and ECDFO files automatically translated:

These files have been translated by SMOP, i.e. automatic translation. These are the known points which give issues with this automatic translation :

-This kind of  matlab code
	Z  = [ ones( 1, m ); X(1:n,1:m); 0.5*X(1:ndiag,1:m).^2 ];
 has to be dealt with a code like this :
    Z=concatenate_((ones_(1,m),X[0:n,0:m],0.5 * X[0:ndiag,0:m] ** 2), axis=0) (first indices from slices has to be decremented)
  NB : Axis=0 is the implicit value when nothing is said. To concatenate vertically, we then set axis=1. Either we recognize the dimensions of the matrix and  then we can choose 0 or 1, or else we can refer to the matlab code :
  [Y, Ynew] or [Y Ynew] in matlabcode should be replaced with axis=1 and [Y ; Ynew] should be replaced with axis =0
  
-Matrix multiplication with python arrays is A.dot(B), the translation with SMOP does not take well into account the differences between .* and * in matlab, we have to be careful.

- xbase=Y[:,1] should by replaced  xbase=copy(Y[:,0])

-Whenever we got a vector by slicing, it becomes in python an array such as array([1,2]) instead of array([[1,2]]) or array([[1],[2]). We have to be careful and reshape when necessary.
    
-Matlab code AAn(k,:) = []/Agn(k)=[] is translated with AAn[k,:]=[]/Agn[k]=[] in python but and should be replaced by np.delete(AAn, k-1, 0)/Agn = np.delete(Agn, k-1, 0). 0 means that the (k-1)-nth line will be deleted,
and 1 should be put when we want the (k-1)-nth column to be deleted. (k-1_nth line in python array which is the k_nth line in matlabarray)
Same thing applies when we in matlab only want to take a few columns : lm=I(:,ifree > 0) * sn is replaced by lm=np.delete(I, find_(ifree<=0)-1, 1)*sn.

-Matlab code X(:,m)=y where y is a column vector is translated by X[:,m]=y is OK only if columns_(X) <= M and if X is not the empty matrix. Otherwise, when not sure (in almost every case), we replace that by the following code :
		if isempty_(X):
		   X=copy_(y) #Note that the copy_ is obligatory, unless y is not a variable but a result of a function (sum, multiplication like y+z or z*y for instance)							
        else:
            X[:,m]=y
			
-Logicals operators from matlab & and | have to be replaced by logical_and_ and logical_or_.
	For instance find_(Y[:,i] < xl[indfree] or Y[:,i] > xu[indfree],1)) has to be replaced by find_(logical_or_(Y[:,i] < xl[indfree] , Y[:,i] > xu[indfree]),1))
	
-The matlab elsif are automatically translated with else..if instead of elif

-Analogue translation to (length_(find_(not isreal_(H))) != 0) are not correct, the correct version is to replace 'not' by '~' or one might later use (not isreal_(H).all) (or isreal_(H).any() when there is no negation) which may be quicker.

-The disp_ and fprint_ fundamentally do the same thing. Here are some automatically translated false python code and its correction :
                            fprintf_(1,char('%s%d%s %12.8e %s %12.8e\\n'),char(' bcdfo_solve_TR_MS_bc ('),i,char('): |s_i| = '),norms_b,char('  |bound_i| = '),delta_b)
							SHOULD BE TRANSLATED BY (Working with version 2.7):
							fprintf_(1,'%s%d%s %12.8e %s %12.8e\n' % (' bcdfo_solve_TR_MS_bc (',i,'): |s_i| = ',norms_b,'  |bound_i| = ',delta_b))
							
							NB:Please note that one backslash \ also had to be deleted for \\n 
							fid=fopen_(char('convhist.m'),char('w'))
							fprintf_(fid,char('function A=history \\n A=[ \\n'))
							SHOULD BE TRANSLATED BY :
							fid=fopen_('convhist.m','w')
							fprintf_(fid,'function A=history \n A=[ \n')
							
							fprintf_(options.fout,'VARIABLES:\\n')
							SHOULD BE TRANSLATED  BY:
							fprintf_(options.fout,'VARIABLES:\n') 


-The function isa(func,'function_handle') in matlab should be  translated by isinstance(evalfgh_, types.FunctionType) (with import types as a header of the file)
							
-When multiplying a number by a matrix, the number must be first in python. For instance, 3*matlabarray([[-0.10526316,  0.9944444 ]]) and NOT matlabarray([[-0.10526316,  0.9944444 ]])*3.

-Python will addition matrix which do not have the same dimension without giving some kind of errors or warnings. Therefore checking dimensions of matrices might sometimes be useful.

-When functions call each other in python code, arguments may be modified => we have to make copy of all the arguments which are modified by the function to make sure that there is  no unwanted modification, even if the
argument is returned at the end of the function. For instance, bcdfo_repair_Y modifies and returns Y, but it may be returned under an other name in matlab, for instance Yplus:
QZplus, RZplus, Yplus, replaced, maximprove, Y_radius, xbase, scale = bcdfo_repair_Y_( QZ, RZ, Y, 0.7, 10, 1.0e-10, 1.1, 0.001, xbase, 1, 0, 0, matlabarray([-10,-10]), matlabarray([10,10]), matlabarray([1,2]), 1, scale, 0, 1, 1e15 )
In this case, we would not want Y to be modified during the call. Therefore Y has to be copied in bcdfo_repair_Y, even though it is returned at the end. 

-Some copy_ should be transformed into copy when we do not want the objects to become matlabarray (imported with 'from copy import copy')

-When there may be complex numbers, A' should be replaced in python by A.conj().T and not A.T. This is for instance important in : A=0.5*(A + A.conj().T)

-There are some matlab functions which are not so common in this code so that implemtenting them completely is not necessary, and we deal with them case by case, those are the followings :

	-roots function from matlab has to be handled in python like in the following example :
	   root  = roots([norm(V(:,imu))^2 2*V(:,imu)'*scri nscri^2-Delta^2]);
	   s     = scri + root(1)*V(:,imu);
	  SHOULD BE TRANSLATED IN PYTHON BY :
		p2=poly1d_([norm_(V[:,imu]) ** 2,2 * V[:,imu].T * scri,nscri ** 2 - Delta ** 2])
		root=max(p2.r) #CAREFUL, p2.r is an ARRAY and not a MATLABARRAY, therefore we use max from numpy and not max_ from runtime
		s=scri + root * V[:,imu]
		
	-sort function from matlab has to be handled in python like in the following example :
	    dsorted,jsorted=sort_(d,char('descend'),nargout=2)
		SHOULD BE IN PYTHON BY :
		dsorted=matlabarray(sort_(np.asarray(d).reshape(-1))[::-1])
		jsorted=matlabarray(argsort_(np.asarray(d).reshape(-1))[::-1])+1 #NOTE THAT THE +1 IS IMPORTANT SINCE WE ARE DEALING WITH INDICES OF MATLABARRAY !
 
PROBLEMS FROM AUTOMATIC TRANSLATION WHICH HAVE APPARENTLY BEEN DEALT WITH BY MODIFYING THE RUNTIME.PY (but we are keeping them close just in case):

-Matrices like V[m:n,a] where a is a integer (or an interval containing a unique number like 4:4, but not an interval like 3:5) or matrices V[m:n] where V is a vertical vector always give as a result a line vector such as matlabarray([[-0.10526316,  0.9944444 ]]). Therefore we have to transpose it.
 This was also a problem for case V[M] where M is a matrix and V is a vertical vector.

-cholesky function in python does not give an answer when the matrix is not definite positive (whereas matlab does) and raises instead an exception  : therefore they have to be handle differently (cf bcdfo_solve_TR_MS for an instance)

-The eig_(A,1) function in python give the eigenvalues like matlab BUT :
	the eig_(A,2) function gives FIRST the eigenvalues and only SECOND the eigenvectors, which is the reverse order in matlab.
	the eig_(A,2) function gives the eigenvalues(in the first place) as a VECTOR, whereas it is a diagonal matrix in matlab (in the second place).
	
-The U,S,V=svd_(A,0,nargout=3) function gives S as a vector and not as a diagonal matrix like in matlab 