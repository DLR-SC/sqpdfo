# -*- coding: utf-8 -*-
"""
Created on Tue Nov 25 15:02:13 2014
% [n,nb,mi,me,x,lm,lb,ub,info,options,values] = ecdfo_prelim (func,x0,lm0,lb,ub,options);
%
% This function realizes the following preliminary jobs:
% - set default output arguments
% - set options (default values if absent, numeric values for lexical options)
% - check the given options
% - get the possible 'values' of options
% - compute function values and deduce dimensions
% - compute an initial multiplier (if not given)
% - initial printings
%
%-----------------------------------------------------------------------

% Authors: Jean Charles Gilbert, INRIA.
%      and Anke Troeltzsch, DLR.
%
% Copyright 2008, 2009, INRIA. 2013, DLR.
%
% EC-DFO is distributed under the terms of the Q Public License version
% 1.0.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Q Public
% License version 1.0 for more details.
%
% You should have received a copy of the Q Public License version 1.0
% along with this program.  If not, see
% <http://doc.trolltech.com/3.0/license.html>.
%
%-----------------------------------------------------------------------

%===============================================================================

% Set output arguments
@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py ecdfo_prelim.m

from __future__ import division
#try:
from runtime import *
#except ImportError:
#    from smop.runtime import *
#import sys
import types
import helper
import numpy as np
from sqplab_options import *
from bcdfo_build_QR_of_Y import bcdfo_build_QR_of_Y_
from bcdfo_poisedness_Y import bcdfo_poisedness_Y_
from bcdfo_computeP import bcdfo_computeP_
from bcdfo_gradP import bcdfo_gradP_
from bcdfo_projgrad import bcdfo_projgrad_
from ecdfo_augmX_evalf import ecdfo_augmX_evalf_
from sqplab_checkoptions import sqplab_checkoptions_
from sqplab_lsmult import sqplab_lsmult_
from ecdfo_optimality import ecdfo_optimality_
from copy import copy
from numpy import array, arange

def ecdfo_prelim_(func_=None,x0_=None,lm0_=None,Delta0_=None,lb_=None,ub_=None,scaleX_=None,scalefacX_=None,cur_degree_=None,rep_degree_=None,plin_=None,pdiag_=None,pquad_=None,c_=None,initial_Y_=None,kappa_ill_=None,whichmodel_=None,factor_FPR_=None,Lambda_FP_=None,Lambda_CP_=None,eps_L_=None,lSolver_=None,hardcons_=None,stratLam_=None,xstatus_=None,sstatus_=None,dstatus_=None,options_=None,*args,**kwargs):
#    varargin = cellarray(args)
#    nargin = 28-[func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options].count(None)+len(args)
    

    func=copy(func_)
    x0=copy(x0_)
    lm0=copy(lm0_)
    Delta0=copy(Delta0_)
    lb=copy(lb_)
    ub=copy(ub_)
    scaleX=copy(scaleX_)
    scalefacX=copy(scalefacX_)
    cur_degree=copy(cur_degree_)
    rep_degree=copy(rep_degree_)
    plin=copy(plin_)
    pdiag=copy(pdiag_)
    pquad=copy(pquad_)
    c=copy(c_)
    initial_Y=copy(initial_Y_)
    kappa_ill=copy(kappa_ill_)
    whichmodel=copy(whichmodel_)
    factor_FPR=copy(factor_FPR_)
    Lambda_FP=copy(Lambda_FP_)
    Lambda_CP=copy(Lambda_CP_)
    eps_L=copy(eps_L_)
    lSolver=copy(lSolver_)
    hardcons=copy(hardcons_)
    stratLam=copy(stratLam_)
    xstatus=copy(xstatus_)
    sstatus=copy(sstatus_)
    dstatus=copy(dstatus_)
    options=copy(options_)
    
    info = helper.dummyUnionStruct()
    info.nsimul = array([])
    
    
    Y = array([])
    gamma1 = 0.010000000000000
    eps =  2.220446049250313e-16
    stallfact=10 * eps
    
    nfix = None				
    indfix = None				
    xfix = None
    vstatus = None				
    QZ = None
    RZ = None
    scale = None
    poised = None
    Y_radius = None
    poised_model = None
    X = None
    fX = None
    #Y = None
    fY = None
    ciX = None
    ciY = None
    ceX = None
    ceY = None
    poisedness_known = None
    m = None
    normgx = None
    fcmodel = None
    ind_Y = None
    i_xbest = None
    indfree = None
    
    
    n=0
    nb=0
    mi=0
    me=0
    lm=array([])
    info.g=[]
    info.ai=[]
    info.ae=[]
    info.hl=[]
    info.niter=0
    shift_Y=1
    x=copy(np.NaN)
    fx=copy(np.NaN)
    gx=copy(np.NaN)
    checkoptions=1
    if isempty_(options):
        checkoptions=0
    info,options,values=sqplab_options_(info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.nsimul=np.zeros(values.nsimultype)
    n=size_(x0,1)
    if size_(x0,2) != 1:
        if options.verbose:
            fprintf_(options.fout,'### ecdfo: the initial x must be an n-vector\n\n')
        info.flag=values.fail_on_argument
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if n < 1:
        if options.verbose:
            fprintf_(options.fout,'### ecdfo: the initial x must be an n-vector with n > 0\n\n')
        info.flag=values.fail_on_argument
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if isempty_(lb):
        lb=- options.inf * ones_(n + mi,1)
    if isempty_(ub):
        ub=options.inf * ones_(n + mi,1)
    nb_lo=sum_(lb[0:n] > - options.inf)
    nb_up=sum_(ub[0:n] < options.inf)
    nb=sum_(min_((lb[0:n] > - options.inf) + (ub[0:n] < options.inf),1))
    zero=0.0
    nfix=0
    indfix=array([])
    xfix=zeros_(n,1)
    vstatus=zeros_(n,1)
    temp=zeros_(n,1)
    for j in range(0,n):
        if (lb[j] > ub[j]):
            disp_('Error: Lower bound of component ',int2str_(j),' exceeds upper bound !!')
            info.flag=2
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        temp[j]=ub[j] - lb[j]
        if (temp[j] < Delta0 + Delta0):
            if (temp[j] == zero):
                nfix=nfix + 1
                indfix=concatenate_([indfix,j],axis=1)
                vstatus[j]=c.alwaysfixed
                xfix[j]=lb[j]
                continue
            else:
                Delta0=0.5 * temp[j]
                disp_(' Diff. between lower and upper bound of component ',int2str_(j),' is less than 2*Delta0 !! New Delta0=',num2str_(Delta0))
        templ=lb[j] - x0[j]
        tempu=ub[j] - x0[j]
        if (templ >= - Delta0):
            x0[j]=lb[j] + Delta0
        else:
            if (tempu <= Delta0):
                x0[j]=ub[j] - Delta0
    if (scaleX):
        for i in range(0,n):
            if (scalefacX[i] > 0):
                x0[i]=x0[i] * scalefacX[i]
                lb[i]=lb[i] * scalefacX[i]
                ub[i]=ub[i] * scalefacX[i]
            else:
                scalefacX[i]=1
    if (nfix > 0):
        nfree=n - nfix
        if (nfree <= 0):
            disp_('No free variables. Please, enlarge search space!')
            info.flag=2
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        indfree=setdiff_(arange(0,n),indfix)
        x0=x0[indfree]
        if (cur_degree == plin):
            cur_degree=nfree + 1
        else:
            if (cur_degree == pdiag):
                cur_degree=2 * nfree + 1
            else:
                if (cur_degree == pquad):
                    cur_degree=((nfree + 1) * (nfree + 2)) / 2
        if (rep_degree == plin):
            rep_degree=nfree + 1
        else:
            if (rep_degree == pdiag):
                rep_degree=2 * nfree + 1
            else:
                if (rep_degree == pquad):
                    rep_degree=((nfree + 1) * (nfree + 2)) / 2
        plin=nfree + 1
        pdiag=2 * nfree + 1
        pquad=((nfree + 1) * (nfree + 2)) / 2
        n=copy(nfree)
    else:
        indfree=arange(0,n)
    x=copy(x0)
    getfY=1
    while (getfY):

        if (options.verbose > 2):
            disp_(' Degree of the initial  model = ',int2str_(cur_degree))
        if initial_Y=='random':
            Y[:,0]=x0
            ill_init=1
            while (ill_init):

                Y[:,1:cur_degree]=- ones_(n,cur_degree - 1) + 2 * rand_(n,cur_degree - 1)
                for j in range(1,cur_degree):
                    Y[:,j]=Y[:,0] + Y[:,j]*(Delta0 / norm_(Y[:,j]))
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                if (cond_(RZ) < kappa_ill):
                    ill_init=0

            QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y_(QZ,RZ,Y,Delta0,factor_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,1,kappa_ill,nargout=8)
            poisedness_known=1
        else:
            if initial_Y=='simplx':
                I=eye_(n)
                Y=zeros_(n,n+1)
                Y[:,0]=x0.reshape(-1)
#                    Y[:,1]=x0.T
                for j in range(0,n):
                    step1=- Delta0
                    Y[:,j + 1]=x0.reshape(-1) + step1 * I[:,j]
                    if (cur_degree >= pdiag):
                        step2=copy(Delta0)
                        Y[:,j + 1 + n]=x0.reshape(-1) + step2 * I[:,j]
                if (cur_degree == pquad):
                    k=2 * n + 2
                    for j in range(0,n):
                        for jj in range(j + 1,n+1):
                            Y[:,k-1]=0.5 * (Y[:,j + 1] + Y[:,jj + 1])
                            k=k + 1
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,x,1,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                poisedness_known=1
        poised_model=1
        X=array([])
        fX=array([])
        ciX=array([])
        ceX=array([])
        ind_Y=array([])
        for i in range(0,cur_degree):
            X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf_(func,Y[:,[i]],i,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,1e+25,info.nsimul[1],xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=9)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if (abs(fX[i]) > 1e+25):
                break
            if (i == cur_degree-1):
                getfY=0
            ind_Y=concatenate_([ind_Y,array([i])],axis=1)
        fY=copy(fX)
        ciY=copy(ciX)
        ceY=copy(ceX)
        xstatus=xstatus.T
        dstatus=dstatus.T
        if (getfY):
            Delta0=gamma1 * Delta0
            if (Delta0 < stallfact * norm_(x0)):
                disp_('Error: cannot find enough finite objective function values',' in the neighbourhood of the starting point! Terminating.')
                if (nfix > 0):
                    I=eye_(n + nfix)
                    x=I[:,indfix] * xl_(indfix) + I[:,indfree].dot( x )
                    gx=I[:,indfix] * zeros_(nfix,1) + I[:,indfree].dot( gx )
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values

    fx0=copy(fY[0])
    info.f=fx0
    m=copy(cur_degree)-1
    i_xbest=0
    initmodel=zeros_(1,pquad)
    rhsY=concatenate_([fY.reshape(1,-1),ciY,ceY], axis=0)
    fcmodel=bcdfo_computeP_(QZ,RZ,Y,rhsY,whichmodel,initmodel,ind_Y,0,0,gx,scale,shift_Y,Delta0)
    gx=bcdfo_gradP_(fcmodel[[0],:],x,x,scale,shift_Y)
    normgx,_=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
    if any_(size_(gx) != [n,1]):
        if options.verbose:
            fprintf_(options.fout,'### ecdfo: the computed gradient g has a wrong size, (%0i,%0i) instead of (%0i,1)\n\n'%(size_(gx),n))
        info.flag=values.fail_on_simul
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.g=gx
    mi=size_(ciY,1)
    if mi > 0:
        info.ci=copy(ciY[:,[0]])
        gci=zeros_(mi,n)
        for i in range(0,mi):
            gci[i,:]=bcdfo_gradP_(fcmodel[[1 + i],:],x,x,scale,shift_Y).T
        info.ai=copy(gci)
    else:
        info.ci=array([])
        info.ai=array([])
    me=size_(ceY,1)
    if me > 0:
        info.ce=copy(ceY[:,[0]])
        gce=zeros_(me,n)
        for i in range(0,me):
            gce[i,:]=bcdfo_gradP_(fcmodel[[1 + mi + i],:],x,x,scale,shift_Y).T
        info.ae=gce
    else:
        info.ce=array([])
        info.ae=array([])
    fprintf_('\n')
    fprintf_('**************************************************************************************\n')
    fprintf_('*                                                                                    *\n')
    fprintf_('*            EC-DFO: equality-constrained minimization without derivatives           *\n')
    fprintf_('*                                                                                    *\n')
    fprintf_('*                            (c)  A. Troeltzsch, 2013                                *\n')
    fprintf_('*                                                                                    *\n')
    fprintf_('**************************************************************************************\n')
    fprintf_('\n')
    values.dline='-------------------------------------------'
    values.dline=strcat_(values.dline,values.dline)
    values.eline='==========================================='
    values.eline=strcat_(values.eline,values.eline)
    values.sline='*******************************************'
    values.sline=strcat_(values.sline,values.sline)
    if options.verbose < 4:
        fprintf_(options.fout,'iter neval        fval            merit      ')
        if (nb + mi + me > 0):
            fprintf_(options.fout,' |grad Lag|   feasibility')
        else:
            fprintf_(options.fout,'gradient')
        fprintf_(options.fout,'     delta    stepsize')
        if options.algo_method == values.quasi_newton:
            fprintf_(options.fout,'  BFGS\n')
        else:
            fprintf_(options.fout,'  \n')
        fprintf_(options.fout,'  \n')
    if options.verbose >= 4:
        fprintf_(options.fout,'%s'%(values.sline))
        fprintf_(options.fout,'ecdfo optimization solver (Version 0.4.4, February 2009, entry point)\n\n')
        if isinstance(func, types.FunctionType):
            func_name=str(func)
        else:
            func_name=copy(func)
        fprintf_(options.fout,'  name: "%s"\n'%(func_name))
        fprintf_(options.fout,'  dimensions:\n')
        fprintf_(options.fout,'  . variables (n):               %4i\n'%(n))
        if nb > 0:
            fprintf_(options.fout,'  . bounds on variables (nb):    (%0i lower, %0i double, %0i upper)\n'%(nb,nb_lo,nb_up))
        if mi > 0:
            fprintf_(options.fout,'  . inequality constraints (mi): %4i\n'%(mi))
        if me > 0:
            fprintf_(options.fout,'  . equality constraints (me):   %4i\n'%(me))
        fprintf_(options.fout,'  required tolerances for optimality:\n')
        if nb + mi + me > 0:
            fprintf_(options.fout,'  . gradient of the Lagrangian      %8.2e\n'%(options.tol[0]))
            fprintf_(options.fout,'  . feasibility                     %8.2e\n'%(options.tol[1]))
            if nb + mi > 0:
                fprintf_(options.fout,'  . complementarity                 %8.2e\n'%(options.tol[2]))
        else:
            fprintf_(options.fout,'  . gradient of the cost function   %8.2e\n'%(options.tol[0]))
        fprintf_(options.fout,'  counters:\n')
        fprintf_(options.fout,'  . max iterations                  %4i\n'%(options.miter))
        fprintf_(options.fout,'  . max function evaluations        %4i\n'%(options.msimul))
        fprintf_(options.fout,'  algorithm:\n')
        if values.newton == options.algo_method:
            fprintf_(options.fout,'  . Newton method\n')
        else:
            if values.quasi_newton == options.algo_method:
                fprintf_(options.fout,'  . quasi-Newton method\n')
            else:
                if values.cheap_quasi_newton == options.algo_method:
                    fprintf_(options.fout,'  . cheap quasi-Newton method\n')
        if values.unit_stepsize == options.algo_globalization:
            fprintf_(options.fout,'  . unit step-size\n')
        else:
            if values.linesearch == options.algo_globalization:
                if options.algo_method == values.newton:
                    fprintf_(options.fout,"  . globalization by Armijo's linesearch\n")
                else:
                    if options.algo_method == values.quasi_newton:
                        if isfield_(options,'algo_descent'):
                            if options.algo_descent == values.powell:
                                fprintf_(options.fout,"  . globalization by Armijo's linesearch (descent ensured by Powell corrections)\n")
                            else:
                                if options.algo_descent == values.wolfe:
                                    if nb + mi + me == 0:
                                        fprintf_(options.fout,"  . globalization by Wolfe's linesearch\n")
                        else:
                            fprintf_(options.fout,"  . globalization by Armijo's linesearch\n")
            else:
                if values.trust_regions == options.algo_globalization:
                    fprintf_(options.fout,'  . globalization by trust regions\n')
        fprintf_(options.fout,'  various input/initial values:\n')
        if (options.algo_method == values.quasi_newton) and (nb + mi + me == 0) and (options.df1 > 0) and (info.f > 0):
            fprintf_(options.fout,'  . expected initial decrease       %8.2e\n'%(options.df1 * info.f))
        if nb + mi > 0:
            fprintf_(options.fout,'  . infinite bound threshold        %8.2e\n'%(options.inf))
        fprintf_(options.fout,'  . |x|_2                           %8.2e\n'%(norm_(x)))
    if (nb + mi + me > 0):
        if isempty_(lm0):
            lm,info=sqplab_lsmult_(x,[],[],info,options,values,nargout=2)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if options.verbose >= 4:
                fprintf_(options.fout,'  . |lm|_2                          %8.2e (default: least-squares value)\n'%(norm_(lm)))
        else:
            lm=copy(lm0)
            if options.verbose >= 4:
                fprintf_(options.fout,'  . |lm|_2                          %8.2e\n'%(norm_(lm)))
    feas,compl,info=ecdfo_optimality_(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if options.verbose >= 4:
        fprintf_(options.fout,'  . |g|_inf                         %8.2e\n'%(norm_(info.g,inf)))
        if nb + mi + me > 0:
            fprintf_(options.fout,'  . |glag|_inf                      %8.2e\n'%(norm_(info.glag,inf)))
        if nb:
            fprintf_(options.fout,'  . |x^#|_inf                       %8.2e\n'%(norm_(feas[0:n],inf)))
        if mi:
            fprintf_(options.fout,'  . |ci^#|_inf                      %8.2e\n'%(norm_(feas[n:n + mi],inf)))
        if me:
            fprintf_(options.fout,'  . |ce|_inf                        %8.2e\n'%(norm_(feas[n + mi:n + mi + me],inf)))
        if nb + mi > 0:
            fprintf_(options.fout,'  . |complementarity|_inf           %8.2e\n'%(norm_(compl,inf)))
        fprintf_(options.fout,'  tunings:\n')
        fprintf_(options.fout,'  . printing level                  %0i\n'%(options.verbose))
    info,options=sqplab_checkoptions_(nb,mi,me,0,info,options,values,nargout=2)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#def ecdfo_prelim_(func=None,x0=None,lm0=None,Delta0=None,lb=None,ub=None,scaleX=None,scalefacX=None,cur_degree=None,rep_degree=None,plin=None,pdiag=None,pquad=None,c=None,initial_Y=None,kappa_ill=None,whichmodel=None,factor_FPR=None,Lambda_FP=None,Lambda_CP=None,eps_L=None,lSolver=None,hardcons=None,stratLam=None,xstatus=None,sstatus=None,dstatus=None,options=None,*args,**kwargs):
#    #varargin = cellarray(args)
#    #nargin = 28-[func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options].count(None)+len(args)
#
#    info = helper.dummyUnionStruct()
#    info.nsimul = array([])
#    Y = array([])
#    gamma1 = 0.010000000000000
#    eps =  2.220446049250313e-16
#    stallfact=10 * eps
#    
#    nfix = None				
#    indfix = None				
#    xfix = None
#    vstatus = None				
#    QZ = None
#    RZ = None
#    scale = None
#    poised = None
#    Y_radius = None
#    poised_model = None
#    X = None
#    fX = None
#    #Y = None
#    fY = None
#    ciX = None
#    ciY = None
#    ceX = None
#    ceY = None
#    poisedness_known = None
#    m = None
#    normgx = None
#    fcmodel = None
#    ind_Y = None
#    i_xbest = None
#    indfree = None
#    print "Warning: set nfix, indfix, xfix, vstatus, QZ, RZ, scale, poised, Y_radius, poised_model, X, fX, Y, fY, ciX, ciY, ceX, ceY, poisedness_known, m, normgx, fcmodel, ind_Y, i_xbest, indfree = None\n in ecdfo_prelim."    				
#
#    n=0
#    nb=0
#    mi=0
#    me=0
#    lm=array([])
#    
#    info.g=[]
#    info.ai=[]
#    info.ae=[]
#    info.hl=[]
#    info.niter=0
#    shift_Y=1
#    x=copy(np.NaN)
#    fx=copy(np.NaN)
#    gx=copy(np.NaN)
#    checkoptions=1
#    if isempty_(options):
#        checkoptions=0
#    info,options,values=sqplab_options_(info,options,nargout=3)
#    if info.flag:
#        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#    info.nsimul[1:values.nsimultype]=0
#    n=size_(x0,1)
#    #Y = zeros_(array([n, n+1]))								
#    #print "n", n	
#    #print "Y initialized:\n", Y				
#    if size_(x0,2) != 1:
#        if options.verbose:
#            fprintf_(options.fout,char('### ecdfo: the initial x must be an n-vector\\n\\n'))
#        info.flag=values.fail_on_argument
#        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#    if n < 1:
#        if options.verbose:
#            fprintf_(options.fout,char('### ecdfo: the initial x must be an n-vector with n > 0\\n\\n'))
#        info.flag=values.fail_on_argument
#        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#    if isempty_(lb):
#        lb=- options.inf * ones_(n + mi,1)
#    if isempty_(ub):
#        ub=options.inf * ones_(n + mi,1)
#    nb_lo=sum_(lb[1:n] > - options.inf)
#    nb_up=sum_(ub[1:n] < options.inf)
#    nb=sum_(min_((lb[1:n] > - options.inf) + (ub[1:n] < options.inf),1))
#    zero=0.0
#    nfix=0
#    indfix=array([])
#    xfix=zeros_(n,1)
#    vstatus=zeros_(n,1)
#    temp=zeros_(n,1)
#    for j in arange_(1,n).reshape(-1):
#        if (lb[j] > ub[j]):
#            disp_([char('Error: Lower bound of component '),int2str_(j),char(' exceeds upper bound !!')])
#            info.flag=2
#            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#        temp[j]=ub[j] - lb[j]
#        if (temp[j] < Delta0 + Delta0):
#            if (temp[j] == zero):
#                nfix=nfix + 1
#                indfix=array([indfix,j])
#                vstatus[j]=c.alwaysfixed
#                xfix[j]=lb[j]
#                continue
#            else:
#                Delta0=0.5 * temp[j]
#                disp_([char(' Diff. between lower and upper bound of component '),int2str_(j),char(' is less than 2*Delta0 !! New Delta0='),num2str_(Delta0)])
#        templ=lb[j] - x0[j]
#        tempu=ub[j] - x0[j]
#        if (templ >= - Delta0):
#            x0[j]=lb[j] + Delta0
#        else:
#            if (tempu <= Delta0):
#                x0[j]=ub[j] - Delta0
#    if (scaleX):
#        for i in arange_(1,n).reshape(-1):
#            if (scalefacX[i] > 0):
#                x0[i]=x0[i] * scalefacX[i]
#                lb[i]=lb[i] * scalefacX[i]
#                ub[i]=ub[i] * scalefacX[i]
#            else:
#                scalefacX[i]=1
#    if (nfix > 0):
#        nfree=n - nfix
#        if (nfree <= 0):
#            disp_(char('No free variables. Please, enlarge search space!'))
#            info.flag=2
#            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#        indfree=setdiff_(arange_(1,n),indfix)
#        x0=x0[indfree]
#        if (cur_degree == plin):
#            cur_degree=nfree + 1
#        else:
#            if (cur_degree == pdiag):
#                cur_degree=2 * nfree + 1
#            else:
#                if (cur_degree == pquad):
#                    cur_degree=((nfree + 1) * (nfree + 2)) / 2
#        if (rep_degree == plin):
#            rep_degree=nfree + 1
#        else:
#            if (rep_degree == pdiag):
#                rep_degree=2 * nfree + 1
#            else:
#                if (rep_degree == pquad):
#                    rep_degree=((nfree + 1) * (nfree + 2)) / 2
#        plin=nfree + 1
#        pdiag=2 * nfree + 1
#        pquad=((nfree + 1) * (nfree + 2)) / 2
#        n=copy(nfree)
#    else:
#        indfree=arange_(1,n)
#    x=copy(x0)
#    getfY=1
#    while (getfY):
#
#        if (options.verbose > 2):
#            disp_([char(' Degree of the initial  model = '),int2str_(cur_degree)])
#        if (strcmp_(initial_Y,char('random'))):
#            Y[:,1]=x0
#            ill_init=1
#            while (ill_init):
#
#                Y[:,2:cur_degree]=- ones_(n,cur_degree - 1) + 2 * rand_(n,cur_degree - 1)
#                for j in arange_(2,cur_degree).reshape(-1):
#                    Y[:,j]=Y[:,1] + Y[:,j] * (Delta0 / norm_(Y[:,j]))
#                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
#                #print "RZ build QR of Y 1"																   
#                if (cond_(RZ) < kappa_ill):
#                    ill_init=0
#
#            QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y_(QZ,RZ,Y,Delta0,factor_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,1,kappa_ill,nargout=8)
#            #print "RZ repaired in Y"												
#            poisedness_known=1
#        else:
#            if (strcmp_(initial_Y,char('simplx'))):
#                I=eye_(n)
#                #Y[:,1]=x0
#                #print "x0\n", x0																
#                #print "Y before\n", Y																
#                ##Y = np.append(Y, x0, axis=0)																
#                if Y.shape[1] <= 1:
#                    Y = concatenate_([Y, x0], axis=1)
#                    #print "Y concatenation"																				
#                else:
#                    Y[:,1]=x0.T
#                #Y = copy(x0)#concatenate_([Y,x0], axis=1)																
#                #print "Y after\n", Y																
#                for j in arange_(1,n).reshape(-1):
#                    step1=- Delta0
#                    #print "x0", x0
#                    #print "step1", step1		
#                    #print "I[:,j]", I[:,j]
#                    ##print "Y[:,j + 1]", Y[:,j + 1]
#                    #print "step1 * I[:,j]", step1 * I[:,j]
#                    #yblablup = x0 + step1 * I[:,j].T#np.asarray(x0 + step1 * I[:,j])#.T)
#                    #print "x0 + step1 * I[:,j]", yblablup																				
#                    #print "yblablup.shape", yblablup.shape																				
#                    #print "Y:\n", Y																				   
#                    #print "j = ", j																				 
#                    #print "Y.shape", Y.shape																				
#                    ##print "Y[:,j + 1]", Y[:,j + 1]																				   
#                    
#                    ##Y[:,j + 1]=yblablup#x0 + step1 * I[:,j].T
#                    ##print "Y before", Y																				
#                    ###Y = concatenate_([Y, x0 + step1 * I[:,j]], axis=1 )																				
#                    if Y.shape[1] <= j + 1:
#                        #Y = concatenate_([Y, x0 + step1 * I[:,j]], axis=1)
#                        Y = concatenate_([Y, x0 + step1 * I[:,j].T], axis=1)
#                        #print "Y concatenation"																				
#                    else:
#                        #print "np.reshape(yblablup, (3,))", np.reshape(yblablup, (3,))																					
#                        #print "Y before\n", Y																				
#                        Yslice = Y[:,j + 1]
#                        #print "Yslice", Yslice
#                        #print "type Yslice", type(Yslice)																								  
#                        #print "Yslice.shape", Yslice.shape																								 
#                        Y[:,j + 1]=(x0 + step1 * I[:,j].T).T#yblablup.T#x0 + step1 * I[:,j]	#yblablup#
#                        #Y = Y.T																				
#                        #Y[j + 1]=(x0 + step1 * I[:,j]).T
#                        #Y = Y.T																								
#                    #print "Y after", Y																				
#																								
#                    if (cur_degree >= pdiag):
#                        step2=copy(Delta0)
#                        Y[:,j + 1 + n]=x0 + step2 * I[:,j]
#                if (cur_degree == pquad):
#                    k=2 * n + 2
#                    for j in arange_(1,n).reshape(-1):
#                        for jj in arange_(j + 1,n).reshape(-1):
#                            Y[:,k]=0.5 * (Y[:,j + 1] + Y[:,jj + 1])
#                            k=k + 1
#                #print "Y:\n", Y, "whichmodel =", whichmodel, "shift_Y = ", shift_Y, "Delta0 = ", Delta0, "kappa_ill =", kappa_ill																												
#                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
#                #print "RZ build QR of Y 2"
#                #return																
#                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,x,1,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
#                poisedness_known=1
#        poised_model=1
#        X=array([])
#        fX=array([])
#        ciX=array([])
#        ceX=array([])
#        ind_Y=array([])
#        for i in arange_(1,cur_degree).reshape(-1):
#            #print "Y[:,i]", Y[:,i]									
#            X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf_(func,Y[:,i].T,i,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,1e+25,info.nsimul[2],xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=9)
#            if info.flag:
#                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#            if (abs(fX[i]) > 1e+25):
#                break
#            if (i == cur_degree):
#                getfY=0
#            ind_Y=concatenate_([ind_Y,array([i])])#array([ind_Y,i]) #concatenade here!!!
#        fY=copy(fX)
#        ciY=copy(ciX)
#        ceY=copy(ceX)
#        xstatus=xstatus.T
#        dstatus=dstatus.T
#        if (getfY):
#            Delta0=gamma1 * Delta0
#            if (Delta0 < stallfact * norm_(x0)):
#                disp_(char('Error: cannot find enough finite objective function values'),char('in the neighbourhood of the starting point! Terminating.'))
#                if (nfix > 0):
#                    I=eye_(n + nfix)
#                    x=I[:,indfix] * xl_(indfix) + I[:,indfree] * x
#                    gx=I[:,indfix] * zeros_(nfix,1) + I[:,indfree] * gx
#                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#
#    fx0=fY[1]
#    info.f=fx0
#    m=copy(cur_degree)
#    i_xbest=1
#    initmodel=zeros_(1,pquad)
#    #print "fy:\n", fY
#    #print "ciY:\n", ciY
#    #print "ceY:\n", ceY
#    #skibbe = concatenate_([fY,ciY,ceY], axis=1)
#    #print "concatenate:", skibbe
#    rhsY=concatenate_([fY,ciY,ceY], axis=0)#array([[fY],[ciY],[ceY]])
#    fcmodel=bcdfo_computeP_(QZ,RZ,Y,rhsY,whichmodel,initmodel,ind_Y,0,0,gx,scale,shift_Y,Delta0)
#    gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
#    #print "lb", lb
#    #print "lb[indfree]", lb[indfree]				
#    #print "ub", ub
#    #print "ub[indfree]", ub[indfree]
#    #print "gx", gx
#    #print "size_(gx)", size_(gx)				
#    normgx=bcdfo_projgrad_(n,x,gx,lb[indfree].T,ub[indfree].T)
#    if any_(size_(gx) != [n,1]):
#        if options.verbose:
#            fprintf_(options.fout,char('### ecdfo: the computed gradient g has a wrong size, (%0i,%0i) instead of (%0i,1)\\n\\n'),size_(gx),n)
#        info.flag=values.fail_on_simul
#        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#    info.g=gx
#    mi=size_(ciY,1)
#    if mi > 0:
#        info.ci=ciY[:,1]
#        gci=zeros_(mi,n)
#        for i in arange_(1,mi).reshape(-1):
#            gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
#        info.ai=gci
#    else:
#        info.ci=array([])
#        info.ai=array([])
#    #print "size_(ceY,1)", size_(ceY,1)
#    me=size_(ceY,1)
#    if me > 0:
#        info.ce=ceY[:,1].T     								
#        #print "info.ce =", info.ce
#        #sys.exit(0)								
#        gce=zeros_(me,n)
#        for i in arange_(1,me).reshape(-1):
#            gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
#        info.ae=gce
#    else:
#        info.ce=[]
#        #print "info.ce = []"								
#        #sys.exit(0)								
#        info.ae=[]
#    fprintf_(char('\\n'))
#    fprintf_(char('**************************************************************************************\\n'))
#    fprintf_(char('*                                                                                    *\\n'))
#    fprintf_(char('*            EC-DFO: equality-constrained minimization without derivatives           *\\n'))
#    fprintf_(char('*                                                                                    *\\n'))
#    fprintf_(char('*                            (c)  A. Troeltzsch, 2013                                *\\n'))
#    fprintf_(char('*                                                                                    *\\n'))
#    fprintf_(char('**************************************************************************************\\n'))
#    fprintf_(char('\\n'))
#    values.dline=char('-------------------------------------------')
#    values.dline=strcat_(values.dline,values.dline)
#    values.eline=char('===========================================')
#    values.eline=strcat_(values.eline,values.eline)
#    values.sline=char('*******************************************')
#    values.sline=strcat_(values.sline,values.sline)
#    if options.verbose < 4:
#        fprintf_(options.fout,char('iter neval        fval            merit      '))
#        if (nb + mi + me > 0):
#            fprintf_(options.fout,char(' |grad Lag|   feasibility'))
#        else:
#            fprintf_(options.fout,char('gradient'))
#        fprintf_(options.fout,char('     delta    stepsize'))
#        if options.algo_method == values.quasi_newton:
#            fprintf_(options.fout,char('  BFGS\\n'))
#        else:
#            fprintf_(options.fout,char('  \\n'))
#        fprintf_(options.fout,char('  \\n'))
#    if options.verbose >= 4:
#        fprintf_(options.fout,char('%s'),values.sline)
#        fprintf_(options.fout,char('ecdfo optimization solver (Version 0.4.4, February 2009, entry point)\\n\\n'))
#        if isa_(func,char('function_handle')):
#            func_name=func2str_(func)
#        else:
#            func_name=copy(func)
#        fprintf_(options.fout,char('  name: "%s"\\n'),func_name)
#        fprintf_(options.fout,char('  dimensions:\\n'))
#        fprintf_(options.fout,char('  . variables (n):               %4i\\n'),n)
#        if nb > 0:
#            fprintf_(options.fout,char('  . bounds on variables (nb):    %4i (%0i lower, %0i double, %0i upper)\\n'),nb,nb_lo,nb_up)
#        if mi > 0:
#            fprintf_(options.fout,char('  . inequality constraints (mi): %4i\\n'),mi)
#        if me > 0:
#            fprintf_(options.fout,char('  . equality constraints (me):   %4i\\n'),me)
#        fprintf_(options.fout,char('  required tolerances for optimality:\\n'))
#        if nb + mi + me > 0:
#            fprintf_(options.fout,char('  . gradient of the Lagrangian      %8.2e\\n'),options.tol(1))
#            fprintf_(options.fout,char('  . feasibility                     %8.2e\\n'),options.tol(2))
#            if nb + mi > 0:
#                fprintf_(options.fout,char('  . complementarity                 %8.2e\\n'),options.tol(3))
#        else:
#            fprintf_(options.fout,char('  . gradient of the cost function   %8.2e\\n'),options.tol(1))
#        fprintf_(options.fout,char('  counters:\\n'))
#        fprintf_(options.fout,char('  . max iterations                  %4i\\n'),options.miter)
#        fprintf_(options.fout,char('  . max function evaluations        %4i\\n'),options.msimul)
#        fprintf_(options.fout,char('  algorithm:\\n'))
#        if values.newton == options.algo_method:
#            fprintf_(options.fout,char('  . Newton method\\n'))
#        else:
#            if values.quasi_newton == options.algo_method:
#                fprintf_(options.fout,char('  . quasi-Newton method\\n'))
#            else:
#                if values.cheap_quasi_newton == options.algo_method:
#                    fprintf_(options.fout,char('  . cheap quasi-Newton method\\n'))
#        if values.unit_stepsize == options.algo_globalization:
#            fprintf_(options.fout,char('  . unit step-size\\n'))
#        else:
#            if values.linesearch == options.algo_globalization:
#                if options.algo_method == values.newton:
#                    fprintf_(options.fout,char("  . globalization by Armijo's linesearch\\n"))
#                else:
#                    if options.algo_method == values.quasi_newton:
#                        if isfield_(options,char('algo_descent')):
#                            if options.algo_descent == values.powell:
#                                fprintf_(options.fout,char("  . globalization by Armijo's linesearch (descent ensured by Powell corrections)\\n"))
#                            else:
#                                if options.algo_descent == values.wolfe:
#                                    if nb + mi + me == 0:
#                                        fprintf_(options.fout,char("  . globalization by Wolfe's linesearch\\n"))
#                        else:
#                            fprintf_(options.fout,char("  . globalization by Armijo's linesearch\\n"))
#            else:
#                if values.trust_regions == options.algo_globalization:
#                    fprintf_(options.fout,char('  . globalization by trust regions\\n'))
#        fprintf_(options.fout,char('  various input/initial values:\\n'))
#        if (options.algo_method == values.quasi_newton) and (nb + mi + me == 0) and (options.df1 > 0) and (info.f > 0):
#            fprintf_(options.fout,char('  . expected initial decrease       %8.2e\\n'),options.df1 * info.f)
#        if nb + mi > 0:
#            fprintf_(options.fout,char('  . infinite bound threshold        %8.2e\\n'),options.inf)
#        fprintf_(options.fout,char('  . |x|_2                           %8.2e\\n'),norm_(x))
#    if (nb + mi + me > 0):
#        if isempty_(lm0):
#            #print "set info (ce) before = ", info.ce									
#            lm,info=sqplab_lsmult_(x,[],[],info,options,values,nargout=2)
#            #print "set info (ce) after = ", info.ce
#            #sys.exit(0)
#            if info.flag:
#                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#            if options.verbose >= 4:
#                fprintf_(options.fout,char('  . |lm|_2                          %8.2e (default: least-squares value)\\n'),norm_(lm))
#        else:
#            lm=copy(lm0)
#            if options.verbose >= 4:
#                fprintf_(options.fout,char('  . |lm|_2                          %8.2e\\n'),norm_(lm))
#    #print "lb", lb[indfree]
#    #print "ub", ub[indfree]
#    #sys.exit(0)				
#    feas,compl,info=ecdfo_optimality_(x,lm,lb[indfree].T,ub[indfree].T,info,options,nargout=3)
#    if info.flag:
#        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#    if options.verbose >= 4:
#        fprintf_(options.fout,char('  . |g|_inf                         %8.2e\\n'),norm_(info.g,inf))
#        if nb + mi + me > 0:
#            fprintf_(options.fout,char('  . |glag|_inf                      %8.2e\\n'),norm_(info.glag,inf))
#        if nb:
#            fprintf_(options.fout,char('  . |x^#|_inf                       %8.2e\\n'),norm_(feas[1:n],inf))
#        if mi:
#            fprintf_(options.fout,char('  . |ci^#|_inf                      %8.2e\\n'),norm_(feas[n + 1:n + mi],inf))
#        if me:
#            fprintf_(options.fout,char('  . |ce|_inf                        %8.2e\\n'),norm_(feas[n + mi + 1:n + mi + me],inf))
#        if nb + mi > 0:
#            fprintf_(options.fout,char('  . |complementarity|_inf           %8.2e\\n'),norm_(compl,inf))
#        fprintf_(options.fout,char('  tunings:\\n'))
#        fprintf_(options.fout,char('  . printing level                  %0i\\n'),options.verbose)
#    info,options=sqplab_checkoptions_(nb,mi,me,0,info,options,values,nargout=2)
#    if info.flag:
#        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
#    return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
