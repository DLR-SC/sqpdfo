# -*- coding: utf-8 -*-
"""
Created on Tue Nov 25 15:02:13 2014
% [n,nb,mi,me,x,lm,lb,ub,info,options,values] = ecdfo_prelim (func,x0,lm0,lb,ub,options);
%
% This function realizes the following preliminary jobs:
% - set default output arguments
% - set options (default values if absent, numeric values for lexical options)
% - check the given options
% - get the possible 'values' of options
% - compute function values and deduce dimensions
% - compute an initial multiplier (if not given)
% - initial printings
%
%-----------------------------------------------------------------------

% Authors: Jean Charles Gilbert, INRIA.
%      and Anke Troeltzsch, DLR.
%
% Copyright 2008, 2009, INRIA. 2013, DLR.
%
% EC-DFO is distributed under the terms of the Q Public License version
% 1.0.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Q Public
% License version 1.0 for more details.
%
% You should have received a copy of the Q Public License version 1.0
% along with this program.  If not, see
% <http://doc.trolltech.com/3.0/license.html>.
%
%-----------------------------------------------------------------------

%===============================================================================

% Set output arguments
@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py ecdfo_prelim.m

from __future__ import division
#try:
from runtime import *
#except ImportError:
#    from smop.runtime import *
#import sys
import helper
import numpy as np
from sqplab_options import *
from bcdfo_build_QR_of_Y import bcdfo_build_QR_of_Y_
from bcdfo_poisedness_Y import bcdfo_poisedness_Y_
from bcdfo_computeP import bcdfo_computeP_
from bcdfo_gradP import bcdfo_gradP_
from bcdfo_projgrad import bcdfo_projgrad_
from ecdfo_augmX_evalf import ecdfo_augmX_evalf_
from sqplab_checkoptions import sqplab_checkoptions_
from sqplab_lsmult import sqplab_lsmult_
from ecdfo_optimality import ecdfo_optimality_

def ecdfo_prelim_(func=None,x0=None,lm0=None,Delta0=None,lb=None,ub=None,scaleX=None,scalefacX=None,cur_degree=None,rep_degree=None,plin=None,pdiag=None,pquad=None,c=None,initial_Y=None,kappa_ill=None,whichmodel=None,factor_FPR=None,Lambda_FP=None,Lambda_CP=None,eps_L=None,lSolver=None,hardcons=None,stratLam=None,xstatus=None,sstatus=None,dstatus=None,options=None,*args,**kwargs):
    #varargin = cellarray(args)
    #nargin = 28-[func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options].count(None)+len(args)

    info = helper.dummyUnionStruct()
    info.nsimul = matlabarray([])
    Y = matlabarray([])
    
    #nfix = None				
    #indfix = None				
    #xfix = None
    #vstatus = None				
    #QZ = None
    #RZ = None
    #scale = None
    #poised = None
    #Y_radius = None
    #poised_model = None
    #X = None
    #fX = None
    #Y = None
    #fY = None
    #ciX = None
    #ciY = None
    #ceX = None
    #ceY = None
    #poisedness_known = None
    #m = None
    #normgx = None
    #fcmodel = None
    #ind_Y = None
    #i_xbest = None
    #indfree = None
    #print "Warning: set nfix, indfix, xfix, vstatus, QZ, RZ, scale, poised, Y_radius, poised_model, X, fX, Y, fY, ciX, ciY, ceX, ceY, poisedness_known, m, normgx, fcmodel, ind_Y, i_xbest, indfree = None\n in ecdfo_prelim."    				

    n=0
    nb=0
    mi=0
    me=0
    lm=matlabarray([])
    
    info.g=[]
    info.ai=[]
    info.ae=[]
    info.hl=[]
    info.niter=0
    shift_Y=1
    x=copy_(np.NaN)
    fx=copy_(np.NaN)
    gx=copy_(np.NaN)
    checkoptions=1
    if isempty_(options):
        checkoptions=0
    info,options,values=sqplab_options_(info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.nsimul[1:values.nsimultype]=0
    n=size_(x0,1)
    #Y = zeros_(matlabarray([n, n+1]))								
    #print "n", n	
    #print "Y initialized:\n", Y				
    if size_(x0,2) != 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo: the initial x must be an n-vector\\n\\n'))
        info.flag=values.fail_on_argument
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if n < 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo: the initial x must be an n-vector with n > 0\\n\\n'))
        info.flag=values.fail_on_argument
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if isempty_(lb):
        lb=- options.inf * ones_(n + mi,1)
    if isempty_(ub):
        ub=options.inf * ones_(n + mi,1)
    nb_lo=sum_(lb[1:n] > - options.inf)
    nb_up=sum_(ub[1:n] < options.inf)
    nb=sum_(min_((lb[1:n] > - options.inf) + (ub[1:n] < options.inf),1))
    zero=0.0
    nfix=0
    indfix=matlabarray([])
    xfix=zeros_(n,1)
    vstatus=zeros_(n,1)
    temp=zeros_(n,1)
    for j in arange_(1,n).reshape(-1):
        if (lb[j] > ub[j]):
            disp_([char('Error: Lower bound of component '),int2str_(j),char(' exceeds upper bound !!')])
            info.flag=2
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        temp[j]=ub[j] - lb[j]
        if (temp[j] < Delta0 + Delta0):
            if (temp[j] == zero):
                nfix=nfix + 1
                indfix=matlabarray([indfix,j])
                vstatus[j]=c.alwaysfixed
                xfix[j]=lb[j]
                continue
            else:
                Delta0=0.5 * temp[j]
                disp_([char(' Diff. between lower and upper bound of component '),int2str_(j),char(' is less than 2*Delta0 !! New Delta0='),num2str_(Delta0)])
        templ=lb[j] - x0[j]
        tempu=ub[j] - x0[j]
        if (templ >= - Delta0):
            x0[j]=lb[j] + Delta0
        else:
            if (tempu <= Delta0):
                x0[j]=ub[j] - Delta0
    if (scaleX):
        for i in arange_(1,n).reshape(-1):
            if (scalefacX[i] > 0):
                x0[i]=x0[i] * scalefacX[i]
                lb[i]=lb[i] * scalefacX[i]
                ub[i]=ub[i] * scalefacX[i]
            else:
                scalefacX[i]=1
    if (nfix > 0):
        nfree=n - nfix
        if (nfree <= 0):
            disp_(char('No free variables. Please, enlarge search space!'))
            info.flag=2
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        indfree=setdiff_(arange_(1,n),indfix)
        x0=x0[indfree]
        if (cur_degree == plin):
            cur_degree=nfree + 1
        else:
            if (cur_degree == pdiag):
                cur_degree=2 * nfree + 1
            else:
                if (cur_degree == pquad):
                    cur_degree=((nfree + 1) * (nfree + 2)) / 2
        if (rep_degree == plin):
            rep_degree=nfree + 1
        else:
            if (rep_degree == pdiag):
                rep_degree=2 * nfree + 1
            else:
                if (rep_degree == pquad):
                    rep_degree=((nfree + 1) * (nfree + 2)) / 2
        plin=nfree + 1
        pdiag=2 * nfree + 1
        pquad=((nfree + 1) * (nfree + 2)) / 2
        n=copy_(nfree)
    else:
        indfree=arange_(1,n)
    x=copy_(x0)
    getfY=1
    while (getfY):

        if (options.verbose > 2):
            disp_([char(' Degree of the initial  model = '),int2str_(cur_degree)])
        if (strcmp_(initial_Y,char('random'))):
            Y[:,1]=x0
            ill_init=1
            while (ill_init):

                Y[:,2:cur_degree]=- ones_(n,cur_degree - 1) + 2 * rand_(n,cur_degree - 1)
                for j in arange_(2,cur_degree).reshape(-1):
                    Y[:,j]=Y[:,1] + Y[:,j] * (Delta0 / norm_(Y[:,j]))
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                #print "RZ build QR of Y 1"																   
                if (cond_(RZ) < kappa_ill):
                    ill_init=0

            QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y_(QZ,RZ,Y,Delta0,factor_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,1,kappa_ill,nargout=8)
            #print "RZ repaired in Y"												
            poisedness_known=1
        else:
            if (strcmp_(initial_Y,char('simplx'))):
                I=eye_(n)
                #Y[:,1]=x0
                #print "x0\n", x0																
                #print "Y before\n", Y																
                ##Y = np.append(Y, x0, axis=0)																
                if Y.shape[1] <= 1:
                    Y = concatenate_([Y, x0], axis=1)
                    #print "Y concatenation"																				
                else:
                    Y[:,1]=x0
                #Y = copy_(x0)#concatenate_([Y,x0], axis=1)																
                #print "Y after\n", Y																
                for j in arange_(1,n).reshape(-1):
                    step1=- Delta0
                    #print "x0", x0
                    #print "step1", step1		
                    #print "I[:,j]", I[:,j]
                    ##print "Y[:,j + 1]", Y[:,j + 1]
                    #print "step1 * I[:,j]", step1 * I[:,j]
                    #yblablup = x0 + step1 * I[:,j].T#np.asarray(x0 + step1 * I[:,j])#.T)
                    #print "x0 + step1 * I[:,j]", yblablup																				
                    #print "yblablup.shape", yblablup.shape																				
                    #print "Y:\n", Y																				   
                    #print "j = ", j																				 
                    #print "Y.shape", Y.shape																				
                    ##print "Y[:,j + 1]", Y[:,j + 1]																				   
                    
                    ##Y[:,j + 1]=yblablup#x0 + step1 * I[:,j].T
                    ##print "Y before", Y																				
                    ###Y = concatenate_([Y, x0 + step1 * I[:,j]], axis=1 )																				
                    if Y.shape[1] <= j + 1:
                        #Y = concatenate_([Y, x0 + step1 * I[:,j]], axis=1)
                        Y = concatenate_([Y, x0 + step1 * I[:,j].T], axis=1)
                        #print "Y concatenation"																				
                    else:
                        #print "np.reshape(yblablup, (3,))", np.reshape(yblablup, (3,))																					
                        #print "Y before\n", Y																				
                        Yslice = Y[:,j + 1]
                        #print "Yslice", Yslice
                        #print "type Yslice", type(Yslice)																								  
                        #print "Yslice.shape", Yslice.shape																								 
                        Y[:,j + 1]=x0 + step1 * I[:,j].T#yblablup.T#x0 + step1 * I[:,j]	#yblablup#
                        #Y = Y.T																				
                        #Y[j + 1]=(x0 + step1 * I[:,j]).T
                        #Y = Y.T																								
                    #print "Y after", Y																				
																								
                    if (cur_degree >= pdiag):
                        step2=copy_(Delta0)
                        Y[:,j + 1 + n]=x0 + step2 * I[:,j]
                if (cur_degree == pquad):
                    k=2 * n + 2
                    for j in arange_(1,n).reshape(-1):
                        for jj in arange_(j + 1,n).reshape(-1):
                            Y[:,k]=0.5 * (Y[:,j + 1] + Y[:,jj + 1])
                            k=k + 1
                #print "Y:\n", Y, "whichmodel =", whichmodel, "shift_Y = ", shift_Y, "Delta0 = ", Delta0, "kappa_ill =", kappa_ill																												
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                #print "RZ build QR of Y 2"
                #return																
                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,x,1,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                poisedness_known=1
        poised_model=1
        X=matlabarray([])
        fX=matlabarray([])
        ciX=matlabarray([])
        ceX=matlabarray([])
        ind_Y=matlabarray([])
        for i in arange_(1,cur_degree).reshape(-1):
            #print "Y[:,i]", Y[:,i]									
            X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf_(func,Y[:,i].T,i,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,1e+25,info.nsimul[2],xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=9)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if (abs_(fX[i]) > 1e+25):
                break
            if (i == cur_degree):
                getfY=0
            ind_Y=matlabarray([ind_Y,i])
        fY=copy_(fX)
        ciY=copy_(ciX)
        ceY=copy_(ceX)
        xstatus=xstatus.T
        dstatus=dstatus.T
        if (getfY):
            Delta0=gamma1 * Delta0
            if (Delta0 < stallfact * norm_(x0)):
                disp_(char('Error: cannot find enough finite objective function values'),char('in the neighbourhood of the starting point! Terminating.'))
                if (nfix > 0):
                    I=eye_(n + nfix)
                    x=I[:,indfix] * xl_(indfix) + I[:,indfree] * x
                    gx=I[:,indfix] * zeros_(nfix,1) + I[:,indfree] * gx
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values

    fx0=fY[1]
    info.f=fx0
    m=copy_(cur_degree)
    i_xbest=1
    initmodel=zeros_(1,pquad)
    #print "fy:\n", fY
    #print "ciY:\n", ciY
    #print "ceY:\n", ceY
    #skibbe = concatenate_([fY,ciY,ceY], axis=1)
    #print "concatenate:", skibbe
    rhsY=concatenate_([fY,ciY,ceY], axis=0)#matlabarray([[fY],[ciY],[ceY]])
    fcmodel=bcdfo_computeP_(QZ,RZ,Y,rhsY,whichmodel,initmodel,ind_Y,0,0,gx,scale,shift_Y,Delta0)
    gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
    #print "lb", lb
    #print "lb[indfree]", lb[indfree]				
    #print "ub", ub
    #print "ub[indfree]", ub[indfree]
    #print "gx", gx
    #print "size_(gx)", size_(gx)				
    normgx=bcdfo_projgrad_(n,x,gx,lb[indfree].T,ub[indfree].T)
    if any_(size_(gx) != [n,1]):
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo: the computed gradient g has a wrong size, (%0i,%0i) instead of (%0i,1)\\n\\n'),size_(gx),n)
        info.flag=values.fail_on_simul
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.g=gx
    mi=size_(ciY,1)
    if mi > 0:
        info.ci=ciY[:,1]
        gci=zeros_(mi,n)
        for i in arange_(1,mi).reshape(-1):
            gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
        info.ai=gci
    else:
        info.ci=matlabarray([])
        info.ai=matlabarray([])
    #print "size_(ceY,1)", size_(ceY,1)
    me=size_(ceY,1)
    if me > 0:
        info.ce=ceY[:,1].T     								
        #print "info.ce =", info.ce
        #sys.exit(0)								
        gce=zeros_(me,n)
        for i in arange_(1,me).reshape(-1):
            gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
        info.ae=gce
    else:
        info.ce=[]
        #print "info.ce = []"								
        sys.exit(0)								
        info.ae=[]
    fprintf_(char('\\n'))
    fprintf_(char('**************************************************************************************\\n'))
    fprintf_(char('*                                                                                    *\\n'))
    fprintf_(char('*            EC-DFO: equality-constrained minimization without derivatives           *\\n'))
    fprintf_(char('*                                                                                    *\\n'))
    fprintf_(char('*                            (c)  A. Troeltzsch, 2013                                *\\n'))
    fprintf_(char('*                                                                                    *\\n'))
    fprintf_(char('**************************************************************************************\\n'))
    fprintf_(char('\\n'))
    values.dline=char('-------------------------------------------')
    values.dline=strcat_(values.dline,values.dline)
    values.eline=char('===========================================')
    values.eline=strcat_(values.eline,values.eline)
    values.sline=char('*******************************************')
    values.sline=strcat_(values.sline,values.sline)
    if options.verbose < 4:
        fprintf_(options.fout,char('iter neval        fval            merit      '))
        if (nb + mi + me > 0):
            fprintf_(options.fout,char(' |grad Lag|   feasibility'))
        else:
            fprintf_(options.fout,char('gradient'))
        fprintf_(options.fout,char('     delta    stepsize'))
        if options.algo_method == values.quasi_newton:
            fprintf_(options.fout,char('  BFGS\\n'))
        else:
            fprintf_(options.fout,char('  \\n'))
        fprintf_(options.fout,char('  \\n'))
    if options.verbose >= 4:
        fprintf_(options.fout,char('%s'),values.sline)
        fprintf_(options.fout,char('ecdfo optimization solver (Version 0.4.4, February 2009, entry point)\\n\\n'))
        if isa_(func,char('function_handle')):
            func_name=func2str_(func)
        else:
            func_name=copy_(func)
        fprintf_(options.fout,char('  name: "%s"\\n'),func_name)
        fprintf_(options.fout,char('  dimensions:\\n'))
        fprintf_(options.fout,char('  . variables (n):               %4i\\n'),n)
        if nb > 0:
            fprintf_(options.fout,char('  . bounds on variables (nb):    %4i (%0i lower, %0i double, %0i upper)\\n'),nb,nb_lo,nb_up)
        if mi > 0:
            fprintf_(options.fout,char('  . inequality constraints (mi): %4i\\n'),mi)
        if me > 0:
            fprintf_(options.fout,char('  . equality constraints (me):   %4i\\n'),me)
        fprintf_(options.fout,char('  required tolerances for optimality:\\n'))
        if nb + mi + me > 0:
            fprintf_(options.fout,char('  . gradient of the Lagrangian      %8.2e\\n'),options.tol(1))
            fprintf_(options.fout,char('  . feasibility                     %8.2e\\n'),options.tol(2))
            if nb + mi > 0:
                fprintf_(options.fout,char('  . complementarity                 %8.2e\\n'),options.tol(3))
        else:
            fprintf_(options.fout,char('  . gradient of the cost function   %8.2e\\n'),options.tol(1))
        fprintf_(options.fout,char('  counters:\\n'))
        fprintf_(options.fout,char('  . max iterations                  %4i\\n'),options.miter)
        fprintf_(options.fout,char('  . max function evaluations        %4i\\n'),options.msimul)
        fprintf_(options.fout,char('  algorithm:\\n'))
        if values.newton == options.algo_method:
            fprintf_(options.fout,char('  . Newton method\\n'))
        else:
            if values.quasi_newton == options.algo_method:
                fprintf_(options.fout,char('  . quasi-Newton method\\n'))
            else:
                if values.cheap_quasi_newton == options.algo_method:
                    fprintf_(options.fout,char('  . cheap quasi-Newton method\\n'))
        if values.unit_stepsize == options.algo_globalization:
            fprintf_(options.fout,char('  . unit step-size\\n'))
        else:
            if values.linesearch == options.algo_globalization:
                if options.algo_method == values.newton:
                    fprintf_(options.fout,char("  . globalization by Armijo's linesearch\\n"))
                else:
                    if options.algo_method == values.quasi_newton:
                        if isfield_(options,char('algo_descent')):
                            if options.algo_descent == values.powell:
                                fprintf_(options.fout,char("  . globalization by Armijo's linesearch (descent ensured by Powell corrections)\\n"))
                            else:
                                if options.algo_descent == values.wolfe:
                                    if nb + mi + me == 0:
                                        fprintf_(options.fout,char("  . globalization by Wolfe's linesearch\\n"))
                        else:
                            fprintf_(options.fout,char("  . globalization by Armijo's linesearch\\n"))
            else:
                if values.trust_regions == options.algo_globalization:
                    fprintf_(options.fout,char('  . globalization by trust regions\\n'))
        fprintf_(options.fout,char('  various input/initial values:\\n'))
        if (options.algo_method == values.quasi_newton) and (nb + mi + me == 0) and (options.df1 > 0) and (info.f > 0):
            fprintf_(options.fout,char('  . expected initial decrease       %8.2e\\n'),options.df1 * info.f)
        if nb + mi > 0:
            fprintf_(options.fout,char('  . infinite bound threshold        %8.2e\\n'),options.inf)
        fprintf_(options.fout,char('  . |x|_2                           %8.2e\\n'),norm_(x))
    if (nb + mi + me > 0):
        if isempty_(lm0):
            #print "set info (ce) before = ", info.ce									
            lm,info=sqplab_lsmult_(x,[],[],info,options,values,nargout=2)
            #print "set info (ce) after = ", info.ce
            #sys.exit(0)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if options.verbose >= 4:
                fprintf_(options.fout,char('  . |lm|_2                          %8.2e (default: least-squares value)\\n'),norm_(lm))
        else:
            lm=copy_(lm0)
            if options.verbose >= 4:
                fprintf_(options.fout,char('  . |lm|_2                          %8.2e\\n'),norm_(lm))
    #print "lb", lb[indfree]
    #print "ub", ub[indfree]
    #sys.exit(0)				
    feas,compl,info=ecdfo_optimality_(x,lm,lb[indfree].T,ub[indfree].T,info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if options.verbose >= 4:
        fprintf_(options.fout,char('  . |g|_inf                         %8.2e\\n'),norm_(info.g,inf))
        if nb + mi + me > 0:
            fprintf_(options.fout,char('  . |glag|_inf                      %8.2e\\n'),norm_(info.glag,inf))
        if nb:
            fprintf_(options.fout,char('  . |x^#|_inf                       %8.2e\\n'),norm_(feas[1:n],inf))
        if mi:
            fprintf_(options.fout,char('  . |ci^#|_inf                      %8.2e\\n'),norm_(feas[n + 1:n + mi],inf))
        if me:
            fprintf_(options.fout,char('  . |ce|_inf                        %8.2e\\n'),norm_(feas[n + mi + 1:n + mi + me],inf))
        if nb + mi > 0:
            fprintf_(options.fout,char('  . |complementarity|_inf           %8.2e\\n'),norm_(compl,inf))
        fprintf_(options.fout,char('  tunings:\\n'))
        fprintf_(options.fout,char('  . printing level                  %0i\\n'),options.verbose)
    info,options=sqplab_checkoptions_(nb,mi,me,0,info,options,values,nargout=2)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
