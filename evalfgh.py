# -*- coding: utf-8 -*-
"""
Created on Fri Nov 14 16:27:59 2014
%
% [msg] = evalfgh (key,xy);
% [msg,f,ci,ce] = evalfgh (key,xy)
% [msg,hl] = evalfgh (key,xy,lm)
%
% On entry:
%   key switches between three options, possible values are:
%      1: free 
%      2: compute f, ci, and ce
%      5: compute hl
%   xy: variables to optimize 
%   lm: KKT (or Lagrange) multiplier associated with the constraints
%     lm(1:n) is associated with bound constraints on xy 
%     lm(n+1:n+mi) is associated with the inequality constraints 
%     lm(n+mi+1:n+mi+me) is associated with the equality constraints 
%
% On return
%   msg describes the result of the simulation
%     0: the required computation has been done
%    -1: xy is out of an implicit domain
%    -2: stop the optimization please (something wrong)
%   f: cost-function value (here the potential energy of the chain)
%   ci: inequality constraint value (here the floor contraint values)
%   ce: equality constraint value (here the gap between the bar lengths and
%     there required values)
%   hl: Hessian of the Lagrangian
@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py evalfgh.m

#from __future__ import division
#try:
from runtime import *
from ecdfo_func import *
#except ImportError:
#    from smop.runtime import *

simul_not_initialized = 1

def set_simul_not_initialized(val):
	global simul_not_initialized
	simul_not_initialized = val

def evalfgh_(key=None,xy=None,lm=None,*args,**kwargs):
    #varargin = cellarray(args)
    nargin = 3-[key,xy,lm].count(None)+len(args)

    global fileoutput,simul_not_initialized
    global foutxy
    global n,nb,mi,me,_iter,prob
    msg=matlabarray([])
    out2=matlabarray([])
    out3=matlabarray([])
    out4=matlabarray([])
    #out5=matlabarray([])
    #out6=matlabarray([])
    #out7=matlabarray([])
    #out8=matlabarray([])
    if simul_not_initialized:
        foutxy=fopen_('results.out','w')
        _iter=0
        simul_not_initialized=0
    if key == 1:
        if nargin < 1:
            fprintf_(fileoutput,'\n(simulopt) >>> not enough input arguments (%0i < 1) with key = %0i\n\n'%(nargin,key))
            msg=- 2
            return msg,out2,out3,out4
    else:
        if key == 2:
            if nargin < 2:
                fprintf_(fileoutput,'\n(simulopt) >>> not enough input arguments (%0i < 2) with key = %0i\n\n'%(nargin,key))
                msg=- 2
                return msg,out2,out3,out4
            msg,out2,out3,out4=ecdfo_func_(xy,nargout=4)
        else:
            if key == 5:
                if nargin < 3:
                    fprintf_(fileoutput,'\n(simulopt) >>> not enough input arguments (%0i < 3) with key = %0i\n\n'%(nargin,key))
                    msg=- 2
                    return msg,out2,out3,out4
                if nargout < 2:
                    fprintf_(fileoutput,'\n(simulopt) >>> not enough output arguments (%0i < 2) with key = %0i\n\n'%(nargout,key))
                    msg=- 2
                    return msg,out2,out3,out4
                msg,out2=ecdfo_hessian_lagr_(xy,lm,nargout=2)
            else:
                fprintf_(fileoutput,'\n(simulopt) >>> unexpected value of key (=%i)\n\n'%(key))
                msg=- 2
                return msg,out2,out3,out4
    return msg,out2,out3,out4
