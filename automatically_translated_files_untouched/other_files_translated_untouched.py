# Autogenerated with SMOP version 
# main.py otherfiles/*
from __future__ import division
def sqplab_tcg(A=None,b=None,delta=None,max_iter=None,tol=None,plevel=None,fout=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 7-[A,b,delta,max_iter,tol,plevel,fout].count(None)+len(args)

    x=zeros(size(b))
    cost=0
    g=- b
    g2=g.T * g
    tol2=tol * tol
    delta2=delta * delta
    dAd=matlabarray([])
    if plevel:
        fprintf(fout,char('    TCG solver; required tolerance %8.2e\n'),tol)
        fprintf(fout,char('    iter       cost        |res|   curvature  stepsize   |step|\n'))
    iter_=0
    while 1:

        iter_=iter_ + 1
        if plevel:
            fprintf(fout,char('    %4i  %14.7e  %7.1e'),iter_,cost,sqrt(g2))
        if g2 <= tol2:
            info.flag = copy(0)
            break
        if iter_ > max_iter:
            iter_=copy(max_iter)
            info.flag = copy(- 1)
            break
        if iter_ == 1:
            d=- g
        else:
            d=- g + (g2 / g2_) * d
        Ad=A * d
        dAd=d.T * Ad
        if plevel:
            fprintf(fout,char('  %9.2e'),dAd / (d.T * d))
        if dAd <= 0:
            x,alpha=dogleg(x,x + d,delta,nargout=2)
            info.flag = copy(2)
            if plevel:
                fprintf(fout,char('  %8.2e  %8.2e\n'),alpha,norm(x))
                cost=0.5 * (x.T * A * x) - b.T * x
                fprintf(fout,char('    %4i  %14.7e  %7.1e\n'),iter_ + 1,cost)
            break
        alpha=- (g.T * d) / dAd
        xx=x + alpha * d
        if plevel:
            fprintf(fout,char('  %8.2e'),alpha)
        if xx.T * xx > delta2:
            x,alpha=dogleg(x,xx,delta,nargout=2)
            info.flag = copy(1)
            if plevel:
                fprintf(fout,char('  %8.2e  %8.2e\n'),alpha,norm(x))
                cost=0.5 * (x.T * A * x) - b.T * x
                fprintf(fout,char('    %4i  %14.7e  %7.1e\n'),iter_ + 1,cost)
            break
        else:
            x=copy(xx)
        if plevel:
            fprintf(fout,char('  %8.2e\n'),norm(x))
        g=g + alpha * Ad
        g2_=copy(g2)
        g2=g.T * g
        if plevel:
            cost=0.5 * (x.T * (g - b))

    info.iter = copy(iter_)
    info.prec = copy(sqrt(g2))
    if not isempty(dAd):
        info.curv = copy(dAd / (d.T * d))
    return x,info
def dogleg(dc=None,dn=None,delta=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 3-[dc,dn,delta].count(None)+len(args)

    dd=dn - dc
    aa=dd.T * dd
    if aa == 0:
        dd=copy(dc)
        t=0
        return dd,t
    bb=dc.T * dd
    cc=dc.T * dc - delta ** 2
    if cc >= 0:
        dd=copy(dc)
        t=0
        return dd,t
    t=(sqrt(bb ** 2 - aa * cc) - bb) / aa
    dd=dc + t * dd
    return dd,t
def blls(A=None,b=None,lb=None,ub=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 4-[A,b,lb,ub].count(None)+len(args)

    m,n=size(A,nargout=2)
    verbose=0
    epsfeas=1e-12
    epsconv=1e-10
    epsres=1e-11
    maxiter=2 * n
    epsdzer=1e-14
    armijob=0.5
    armijor=0.01
    maxback=15
    inds=matlabarray(cat(arange(1,n)))
    nit=0
    nuns=0
    ssub=zeros(n,1)
    exitc=0
    s=min(max(pinv(A) * b,lb),ub)
    res=A * s - b
    resn=norm(res)
    g=A.T * res
    stry=min(max(s - g,lb),ub) - s
    opt=norm(stry)
    free=find(stry).T
    atlb=find(abs_(max(s - g,lb) - s) <= epsfeas).T
    atub=find(abs_(min(s - g,ub) - s) <= epsfeas).T
    latlb=length(atlb)
    latub=length(atub)
    lfree=length(free)
    if (verbose > 0):
        disp(char(' '))
        disp(char('   **************************************************************'))
        disp(char('   *                                                            *'))
        disp(char('   *                          BLLS                              *'))
        disp(char('   *                                                            *'))
        disp(char('   *   a direct bound-constrained linear least-squares solver   *'))
        disp(char('   *                                                            *'))
        disp(char('   *                                                            *'))
        disp(char('   *     (c) Ph. Sampaio, Ph. L. Toint, A. Troeltzsch, 2014     *'))
        disp(char('   *                                                            *'))
        disp(char('   **************************************************************'))
        disp(char(' '))
        disp(cat(char('     The problem has '),int2str(n),char(' variables and '),int2str(m),char(' rows.')))
        disp(char(' '))
        if (verbose > 2):
            problem_matrix=copy(A)
            right_hand_side=b.T
            lower_bounds=lb.T
            upper_bounds=ub.T
            disp(char(' '))
        fprintf(char('     nit     ||r||    optimality'))
        fprintf(char('                 nfr nlow nupp\n\n'))
        fprintf(char('   %5d  %.4e  %.4e                %4d %4d %4d\n'),nit,resn,opt,lfree,latlb,latub)
        if (verbose > 1):
            if (verbose > 2):
                unconstrained_solution=s.T
            disp(char(' '))
            disp(char('   --------------------------------------------------------------'))
            disp(char(' '))
    if (opt <= epsconv or resn <= epsres):
        maxit=0
    else:
        maxit=copy(maxiter)
    for i in arange(1,maxit).reshape(-1):
        nit=nit + 1
        if (verbose > 1):
            disp(cat(char('   Iteration '),int2str(i)))
            disp(char(' '))
            fprintf(char('   Cauchy point projected search\n'))
            fprintf(char('       k     ||r||     stepsize'))
            fprintf(char('                  nfr nlow nupp\n'))
            fprintf(char('   %5d  %.4e                            %4d %4d %4d'),0,resn,lfree,latlb,latub)
        g=A.T * res
        alpha=(norm(g) / norm(A * g)) ** 2
        for kc in arange(1,maxback).reshape(-1):
            stry=min(max(s - alpha * g,lb),ub)
            dtry=stry - s
            ltry=g.T * dtry
            qtry=ltry + 0.5 * norm(A * dtry) ** 2
            if (verbose > 1):
                fprintf(char('\n   %5d  %.4e  %.4e'),kc,norm(A * stry - b),alpha)
            if (qtry <= armijor * ltry):
                break
            else:
                alpha=armijob * alpha
        if (kc >= maxback):
            exitc=- 1
            break
        atlb=inds[find(abs_(stry - lb) <= epsfeas)]
        atub=inds[find(abs_(stry - ub) <= epsfeas)]
        atb=matlabarray(cat(atlb,atub))
        latlb=length(atlb)
        latub=length(atub)
        free=copy(inds)
        free[atb]=[]
        lfree=length(free)
        s[atlb]=lb[atlb]
        s[atub]=ub[atub]
        s[free]=stry[free]
        res=A * s - b
        resn=norm(res)
        if (verbose > 1):
            fprintf(char('                %4d %4d %4d\n'),lfree,latlb,latub)
            if (verbose > 2):
                Cauchy_point=s.T
                indices_of_free_variables=copy(free)
                indices_of_variables_at_their_lower_bound=copy(atlb)
                indices_of_variables_at_their_upper_bound=copy(atub)
        if (lfree == 0 or resn <= epsres):
            if (verbose > 1):
                fprintf(char('   No nested subspace search\n'))
            opt=0
        else:
            if (verbose > 1):
                fprintf(char('   Nested subspace search\n'))
                fprintf(char('       k     ||r||     stepsize      ||r*||'))
                fprintf(char('      nfr nlow nupp\n'))
                fprintf(char('   %5d  %.4e                            %4d %4d %4d\n'),0,resn,lfree,latlb,latub)
            for k in arange(1,n).reshape(-1):
                if (verbose > 2):
                    disp(cat(char('    > Solving in subspace '),int2str(k)))
                    indices_of_free_variables=copy(free)
                    indices_of_variables_at_their_lower_bound=copy(atlb)
                    indices_of_variables_at_their_upper_bound=copy(atub)
                rhs=copy(b)
                if not isempty(atlb):
                    rhs=rhs - A[1:m,atlb] * lb[atlb]
                if not isempty(atub):
                    rhs=rhs - A[1:m,atub] * ub[atub]
                ssub[free]=pinv(A[1:m,free]) * rhs
                ssub[atlb]=lb[atlb]
                ssub[atub]=ub[atub]
                rsubo=A * ssub - b
                rsubon=norm(rsubo)
                natlb=find(ssub[free] < lb[free])
                natub=find(ssub[free] > ub[free])
                lnatb=length(natlb) + length(natub)
                if (lnatb > 0):
                    alpha=1
                    dtry=ssub - s
                    rred=rsubon - resn
                    found=0
                    nback=4 * (1 - nuns)
                    for kb in arange(1,nback).reshape(-1):
                        stry=(1 - alpha) * s + alpha * ssub
                        natlbt=free[find(stry[free] < lb[free])]
                        natubt=free[find(stry[free] > ub[free])]
                        lnatbt=length(natlbt) + length(natubt)
                        stry=min(max(stry,lb),ub)
                        if (verbose >= 1):
                            rtry=A * stry - b
                            rtryn=norm(rtry)
                            atlbt=matlabarray(cat(atlb,natlbt))
                            atubt=matlabarray(cat(atub,natubt))
                            atbt=matlabarray(cat(atlbt,atubt))
                            freet=copy(inds)
                            freet[atbt]=[]
                            latlbt=length(atlbt)
                            latubt=length(atubt)
                            lfreet=length(freet)
                            fprintf(char('   %5dp %.4e  %.4e   %.4e   %4d %4d %4d\n'),kb,rtryn,alpha,rsubon,lfreet,latlbt,latubt)
                        if (lnatbt == 0):
                            break
                        if (verbose == 0):
                            rtry=A * stry - b
                            rtryn=norm(rtry)
                        if (rtryn <= resn - armijor * alpha * rred):
                            s=copy(stry)
                            res=copy(rtry)
                            resn=copy(rtryn)
                            if (verbose == 0):
                                atlb=matlabarray(cat(atlb,natlbt))
                                atub=matlabarray(cat(atub,natubt))
                                atb=matlabarray(cat(atlb,atub))
                                free=copy(inds)
                                free[atb]=[]
                                latlb=length(atlb)
                                latub=length(atub)
                                lfree=length(free)
                            else:
                                atlb=copy(atlbt)
                                atub=copy(atubt)
                                free=copy(freet)
                                latlb=copy(latlbt)
                                latub=copy(latubt)
                                lfree=copy(lfreet)
                            found=1
                            break
                        alpha=armijob * alpha
                    if (found):
                        break
                    else:
                        if (kb >= nback):
                            nuns=nuns + 1
                        alpha=1
                        for kf in arange(1,length(free)).reshape(-1):
                            kk=free[kf]
                            if (dtry[kk] >= epsdzer):
                                alpha=min(alpha,(ub[kk] - s[kk]) / dtry[kk])
                            else:
                                if (dtry[kk] <= - epsdzer):
                                    alpha=min(alpha,(lb[kk] - s[kk]) / dtry[kk])
                        ssub=s + alpha * dtry
                        rsub=(1 - alpha) * res + alpha * rsubo
                        rsubn=norm(rsub)
                        if (verbose > 1):
                            fprintf(char('   %5ds %.4e  %.4e   %.4e   %4d %4d %4d\n'),k,rsubn,alpha,rsubon,lfree,latlb,latub)
                        natlb=free[find(abs_(ssub[free] - lb[free]) <= epsfeas)]
                        natub=free[find(abs_(ssub[free] - ub[free]) <= epsfeas)]
                        atlb=matlabarray(cat(atlb,natlb))
                        atub=matlabarray(cat(atub,natub))
                        atb=matlabarray(cat(atlb,atub))
                        free=copy(inds)
                        free[atb]=[]
                        latlb=length(atlb)
                        latub=length(atub)
                        lfree=length(free)
                        if (verbose > 2):
                            current_subspace_solution=ssub.T
                            indices_of_free_variables=copy(free)
                            indices_of_variables_at_their_lower_bound=copy(atlb)
                            indices_of_variables_at_their_upper_bound=copy(atub)
                        s=copy(ssub)
                        res=copy(rsub)
                        resn=copy(rsubn)
                else:
                    s=copy(ssub)
                    res=copy(rsubo)
                    resn=copy(rsubon)
                    if (verbose > 1):
                        fprintf(char('   %5df %.4e  %.4e   %.4e   %4d %4d %4d\n'),k,resn,1,resn,lfree,latlb,latub)
                        if (verbose > 2):
                            current_subspace_solution=ssub.T
                            indices_of_variables_at_their_lower_bound=copy(atlb)
                            indices_of_variables_at_their_upper_bound=copy(atub)
                            free
                    break
            opt=norm(min(max(s - A.T * res,lb),ub) - s)
        if (verbose == 1):
            fprintf(char('   %5d  %.4e  %.4e                %4d %4d %4d\n'),nit,resn,opt,lfree,latlb,latub)
        else:
            if (verbose > 1):
                disp(char(' '))
                fprintf(char('     nit    ||r||     optimality'))
                fprintf(char('                 nfr nlow nupp\n\n'))
                fprintf(char('   %5d  %.4e  %.4e                %4d %4d %4d\n'),nit,resn,opt,lfree,latlb,latub)
                if (verbose > 2):
                    current_solution=s.T
                    indices_of_free_variables=copy(free)
                    indices_of_variables_at_their_lower_bound=copy(atlb)
                    indices_of_variables_at_their_upper_bound=copy(atub)
                disp(char('   --------------------------------------------------------------'))
                disp(char(' '))
        if (opt <= epsconv or resn <= epsres):
            break
    if (exitc == 0 and nit >= maxiter):
        exitc=1
    if (verbose > 0):
        disp(char(' '))
        if (verbose > 2):
            indices_of_free_variables=copy(free)
            indices_of_variables_at_their_lower_bound=copy(atlb)
            indices_of_variables_at_their_upper_bound=copy(atub)
            final_solution=s.T
            final_residual=res.T
        if (exitc == 1):
            disp(char('   !!! maxit reached !!!'))
            keyboard
        else:
            if (exitc == - 1):
                disp(char('   !!! Cauchy point calculation failure :-(  !!!'))
            else:
                disp(char('   ---> Solved.'))
        disp(char(' '))
    return s,resn,opt,exitc
def history(*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 0-[].count(None)+len(args)

    A=matlabarray(cat(0,NaN,1.0))
    return A
def evalfgh(key=None,xy=None,lm=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 3-[key,xy,lm].count(None)+len(args)

    global fileoutput,simul_not_initialized
    global foutxy
    global n,nb,mi,me,iter_,prob
    msg=matlabarray([])
    out2=matlabarray([])
    out3=matlabarray([])
    out4=matlabarray([])
    out5=matlabarray([])
    out6=matlabarray([])
    out7=matlabarray([])
    out8=matlabarray([])
    if simul_not_initialized:
        foutxy=fopen(char('results.out'),char('w'))
        iter_=0
        simul_not_initialized=0
    if key == 1:
        if nargin < 1:
            fprintf(fileoutput,char('\n(simulopt) >>> not enough input arguments (%0i < 1) with key = %0i\n\n'),nargin,key)
            msg=- 2
            return msg,out2,out3,out4
    else:
        if key == 2:
            if nargin < 2:
                fprintf(fileoutput,char('\n(simulopt) >>> not enough input arguments (%0i < 2) with key = %0i\n\n'),nargin,key)
                msg=- 2
                return msg,out2,out3,out4
            msg,out2,out3,out4=ecdfo_func(xy,nargout=4)
        else:
            if key == 5:
                if nargin < 3:
                    fprintf(fileoutput,char('\n(simulopt) >>> not enough input arguments (%0i < 3) with key = %0i\n\n'),nargin,key)
                    msg=- 2
                    return msg,out2,out3,out4
                if nargout < 2:
                    fprintf(fileoutput,char('\n(simulopt) >>> not enough output arguments (%0i < 2) with key = %0i\n\n'),nargout,key)
                    msg=- 2
                    return msg,out2,out3,out4
                msg,out2=ecdfo_hessian_lagr(xy,lm,nargout=2)
            else:
                fprintf(fileoutput,char('\n(simulopt) >>> unexpected value of key (=%i)\n\n'),key)
                msg=- 2
                return msg,out2,out3,out4
    return msg,out2,out3,out4
def sqplab_badsimul(outdic=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 4-[outdic,info,options,values].count(None)+len(args)

    if outdic == 2:
        if options.verbose:
            fprintf(options.fout,char('\n\n### sqplab: the simulator wants to stop\n'))
        info.flag = copy(values.stop_on_simul)
    else:
        if outdic > 2:
            if options.verbose:
                fprintf(options.fout,char('\n\n### sqplab: error with the simulator (outdic = %0i)\n'),outdic)
            info.flag = copy(values.fail_on_simul)
    return info
def sqplab_bfgs(M=None,y=None,s=None,first=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 7-[M,y,s,first,info,options,values].count(None)+len(args)

    eta=0.2
    n=length(s)
    pc=1
    info.flag = copy(values.success)
    if norm(s) == 0:
        info.flag = copy(values.fail_strange)
        if options.verbose >= 3:
            fprintf(options.fout,char('\n### sqplab_bfgs: null step s\n\n'))
        return M,pc,info,values
    ys=y.T * s
    if options.verbose >= 4:
        fprintf(options.fout,char(" y'*s/(s'*s) = %9.3e\n"),ys / (s.T * s))
    Ms=M * s
    sMs=s.T * Ms
    if sMs <= 0:
        info.flag = copy(values.fail_strange)
        if options.verbose >= 3:
            fprintf(options.fout,char('\n### sqplab_bfgs: BFGS Hessian approximation is not positive definite:\n'))
            fprintf(options.fout,char("            s'*M*s = %g <= 0\n\n"),sMs)
        return M,pc,info,values
    if (options.algo_descent == values.powell) and (ys < eta * sMs):
        pc=(1 - eta) * sMs / (sMs - ys)
        if options.verbose >= 4:
            fprintf(options.fout,char("  Powell's corrector = %7.1e\n"),pc)
        y=pc * y + (1 - pc) * Ms
        ys=y.T * s
        if options.verbose >= 4:
            fprintf(options.fout,char(" (new y'*s/(s'*s) = %7.1e\n)"),ys / (s.T * s))
        if ys <= 0:
            info.flag = copy(values.fail_strange)
            if options.verbose >= 4:
                fprintf(options.fout,char("\n### sqplab_bfgs: y'*s = %9.3e not positive despite correction:\n\n"),ys).T
            return M,pc,info,values
    else:
        if ys <= 0:
            if options.verbose >= 4:
                fprintf(options.fout,char("\n### sqplab_bfgs: y'*s = %9.3e is nonpositive\n\n"),ys).T
            info.flag = copy(values.fail_strange)
            return M,pc,info,values
    if first:
        ol=(y.T * y) / ys
        M=ol * eye(n)
        if options.verbose >= 4:
            fprintf(options.fout,char('  OL coefficient = %g\n'),ol)
        Ms=ol * s
        sMs=s.T * Ms
    M=M - (Ms * Ms.T) / sMs + (y * y.T) / ys
    if options.verbose >= 6:
        eigM=sort(eig(M))
        fprintf(options.fout,char('  eig(M): min = %g, max = %g, cond = %g\n'),min(eigM),max(eigM),max(eigM) / min(eigM))
    return M,pc,info,values
def sqplab_checkoptions(nb=None,mi=None,me=None,ms=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 7-[nb,mi,me,ms,info,options,values].count(None)+len(args)

    info.flag = copy(values.success)
    if options.algo_method == values.cheap_quasi_newton:
        if options.verbose:
            fprintf(options.fout,char('\n### sqplab_checkoptions: the cheap quasi-Newton method is not a valid\n'))
            fprintf(options.fout,char('### approach when there is no state constraint\n\n'))
        info.flag = copy(values.fail_on_problem)
        return info,options
    if values.unit_stepsize == options.algo_globalization:
        if options.algo_method != values.newton:
            if not isfield(options,char('algo_descent')):
                if options.verbose:
                    fprintf(options.fout,char('\n### sqplab_checkoptions: positive definiteness of the matrices is ensured\n'))
                    fprintf(options.fout,char('### by Powell corrections\n\n'))
                options.algo_descent = copy(values.powell)
            else:
                if options.algo_descent == values.wolfe:
                    if options.verbose:
                        fprintf(options.fout,char('\n### sqplab_checkoptions: positive definiteness of the matrices cannot be ensured\n'))
                        fprintf(options.fout,char('### by the Wolfe linesearch when unit stepsize is required; Powell corrections\n'))
                        fprintf(options.fout,char('### will be used instead\n\n'))
                    options.algo_descent = copy(values.powell)
    else:
        if values.linesearch == options.algo_globalization:
            if options.algo_method == values.newton:
                if isfield(options,char('algo_descent')):
                    if options.verbose:
                        fprintf(options.fout,char("\n### sqplab_checkoptions: descent cannot be ensured for Newton's method\n"))
                        fprintf(options.fout,char('### by using Powell corrections or Wolfe linesearch\n\n'))
                    info.flag = copy(values.fail_on_argument)
                    return info,options
                else:
                    if options.verbose:
                        fprintf(options.fout,char("\n### sqplab_checkoptions: Armijo's linesearch can fail with Newton's method,\n"))
                        fprintf(options.fout,char('###                      use unit step-size instead\n\n'))
            else:
                if not isfield(options,char('algo_descent')):
                    if options.verbose:
                        fprintf(options.fout,char('\n### sqplab_checkoptions: descent ensured by Powell corrections\n'))
                        if nb + mi + me + ms == 0:
                            fprintf(options.fout,char("### setting "options.algo_descent = 'Wolfe'" should be better\n\n"))
                    options.algo_descent = copy(values.powell)
                else:
                    if (options.algo_descent == values.wolfe) and (nb + mi + me + ms != 0):
                        if options.verbose:
                            fprintf(options.fout,char('\n### sqplab_checkoptions: positive definiteness of the matrices cannot be ensured\n'))
                            fprintf(options.fout,char('### by the Wolfe linesearch when constraints are present; Powell corrections\n'))
                            fprintf(options.fout,char('### will be used instead\n\n'))
                        options.algo_descent = copy(values.powell)
    return info,options
def sqplab_lsmult(x=None,lb=None,ub=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[x,lb,ub,info,options,values].count(None)+len(args)

    lm=matlabarray([])
    info.flag = copy(values.success)
    badcond=0
    n=length(info.g)
    me=0
    if (nargin >= 3):
        me=size(info.ae,1)
    if (nargin < 4) or isempty(lb):
        lb=- options.inf * ones(n,1)
    else:
        lb=lb[:]
        if any(size(lb) != cat(n,1)):
            fprintf(char('\n### sqplab_lsmult: incorrect size of lb\n\n'))
            info.flag = copy(values.fail_strange)
            return lm,info
    if (nargin < 5) or isempty(ub):
        ub=options.inf * ones(n,1)
    else:
        ub=ub[:]
        if any(size(ub) != cat(n,1)):
            fprintf(char('\n### sqplab_lsmult: incorrect size of ub\n\n'))
            info.flag = copy(values.fail_strange)
            return lm,info
    A=matlabarray(cat([eye(n)],[info.ae]))
    lo=- inf * ones(n + me,1)
    up=inf * ones(n + me,1)
    for i in arange(1,n).reshape(-1):
        if (lb[i] <= - options.inf):
            lo[i]=0
        if (ub[i] >= options.inf):
            up[i]=0
        if (lb[i] > - options.inf) and (abs_(x[i] - lb[i]) < options.dxmin):
            up[i]=0
        if (ub[i] < options.inf) and (abs_(x[i] - ub[i]) < options.dxmin):
            lo[i]=0
    AA=A * A.T
    check_condition=0
    if check_condition:
        cthreshold=1e+17
        AA,badcond=ecdfo_check_cond(AA,cthreshold,options,nargout=2)
    check_convex=1
    if check_convex:
        AA=ecdfo_check_convex(AA,options)
    Ag=A * info.g
    AAn=copy(AA)
    Agn=copy(Ag)
    lon=copy(lo)
    upn=copy(up)
    ifree=ones(size(lo))
    k=1
    for i in arange(1,length(lo)).reshape(-1):
        if lo[i] == up[i]:
            AAn[k,:]=[]
            AAn[:,k]=[]
            Agn[k]=[]
            lon[k]=[]
            upn[k]=[]
            ifree[i]=0
        else:
            k=k + 1
    if not isempty(ifree[ifree > 0]):
        sn,rn,op,exitc=blls(AAn,- Agn,lon,upn,nargout=4)
        I=eye(length(lo))
        lm=I[:,ifree > 0] * sn
    else:
        lm=zeros(size(lo))
    return lm,info
def sqplab_options(info=None,options=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 2-[info,options].count(None)+len(args)

    values.success = copy(0)
    values.fail_on_argument = copy(1)
    values.fail_on_problem = copy(2)
    values.fail_on_simul = copy(3)
    values.stop_on_simul = copy(4)
    values.stop_on_max_iter = copy(5)
    values.stop_on_max_simul = copy(6)
    values.stop_on_dxmin = copy(7)
    values.fail_on_non_decrease = copy(8)
    values.fail_on_ascent_dir = copy(9)
    values.fail_on_max_ls_iter = copy(10)
    values.fail_on_ill_cond = copy(11)
    values.stop_on_small_trust_region = copy(15)
    values.fail_on_null_step = copy(20)
    values.fail_on_infeasible_QP = copy(21)
    values.fail_on_unbounded_QP = copy(22)
    values.fail_strange = copy(99)
    values.nsimultype = copy(16)
    values.max_null_steps = copy(1)
    values.newton = copy(100)
    values.quasi_newton = copy(101)
    values.cheap_quasi_newton = copy(102)
    values.unit_stepsize = copy(110)
    values.linesearch = copy(111)
    values.trust_regions = copy(112)
    values.powell = copy(120)
    values.wolfe = copy(121)
    values.bfgs = copy(130)
    values.model = copy(131)
    info.flag = copy(values.success)
    if isempty(options):
        options.xxx = copy(0)
    if isfield(options,char('fout')):
        if options.fout < 0:
            fprintf(char("\n### ecdfo: options.fout = "%0i" is not a valid file identifier (use 'fopen' to have a valid one)"),options.fout)
            fprintf(char('\n            options.fout is set to 1\n\n'))
            options.fout = copy(1)
    else:
        options.fout = copy(1)
    if isfield(options,char('verbose')):
        if (options.verbose < 0) or (options.verbose > 6):
            fprintf(options.fout,char('\n### ecdfo: options.verbose = "%0i" and should be in [0,6], reset to 1\n\n'),options.verbose)
            options.verbose = copy(1)
    else:
        options.verbose = copy(1)
    if isfield(options,char('algo_method')):
        if char('newton') == lower(regexprep(strtrim(options.algo_method),char('  *'),char(' '))):
            options.algo_method = copy(values.newton)
        else:
            if cellarray([char('quasi-newton'),char('quasi newton'),char('quasinewton')]) == lower(regexprep(strtrim(options.algo_method),char('  *'),char(' '))):
                options.algo_method = copy(values.quasi_newton)
            else:
                if cellarray([char('cheap quasi-newton'),char('cheap quasi newton'),char('cheap quasinewton')]) == lower(regexprep(strtrim(options.algo_method),char('  *'),char(' '))):
                    options.algo_method = copy(values.cheap_quasi_newton)
                else:
                    if options.verbose:
                        fprintf(options.fout,char('\n### ecdfo: options.algo_method "%s" not recognized\n\n'),options.algo_method)
                    info.flag = copy(values.fail_on_argument)
                    return info,options,values
    else:
        options.algo_method = copy(values.quasi_newton)
    if isfield(options,char('algo_globalization')):
        if cellarray([char('unit step-size'),char('unit stepsize')]) == lower(regexprep(strtrim(options.algo_globalization),char('  *'),char(' '))):
            options.algo_globalization = copy(values.unit_stepsize)
        else:
            if cellarray([char('line-search'),char('linesearch')]) == lower(regexprep(strtrim(options.algo_globalization),char('  *'),char(' '))):
                options.algo_globalization = copy(values.linesearch)
            else:
                if cellarray([char('trust regions'),char('trust-regions'),char('trustregions')]) == lower(regexprep(strtrim(options.algo_globalization),char('  *'),char(' '))):
                    options.algo_globalization = copy(values.trust_regions)
                else:
                    if options.verbose:
                        fprintf(options.fout,char('\n### ecdfo: options.algo_globalization "%s" not recognized\n\n'),options.algo_globalization)
                    info.flag = copy(values.fail_on_argument)
                    return info,options,values
    else:
        options.algo_globalization = copy(values.linesearch)
    if isfield(options,char('algo_descent')):
        if char('powell') == lower(regexprep(strtrim(options.algo_descent),char('  *'),char(' '))):
            options.algo_descent = copy(values.powell)
        else:
            if char('wolfe') == lower(regexprep(strtrim(options.algo_descent),char('  *'),char(' '))):
                options.algo_descent = copy(values.wolfe)
            else:
                if options.verbose:
                    fprintf(options.fout,char('\n### ecdfo: options.algo_descent "%s" not recognized\n\n'),options.algo_descent)
                info.flag = copy(values.fail_on_argument)
                return info,options,values
    if isfield(options,char('dxmin')):
        if (options.dxmin <= 0):
            if options.verbose:
                fprintf(options.fout,char('\n### ecdfo: options.dxmin = %g must be > 0\n\n'),options.dxmin)
            info.flag = copy(values.fail_on_argument)
            return info,options,values
    else:
        options.dxmin = copy(1e-08)
    if isfield(options,char('inf')):
        if options.inf <= 0:
            if options.verbose:
                fprintf(char('\n### ecdfo: incorrect value of options.inf %g (should be > 0)\n\n'),options.inf)
            info.flag = copy(values.fail_on_argument)
            return info,options,values
    else:
        options.inf = copy(inf)
    if isfield(options,char('miter')):
        if options.miter <= 0:
            if options.verbose:
                fprintf(char('\n### ecdfo: incorrect value of options.miter %g (should be > 0)\n\n'),options.miter)
            info.flag = copy(values.fail_on_argument)
            return info,options,values
    else:
        options.miter = copy(1000)
    if isfield(options,char('tol')):
        if any(options.tol <= 0):
            if options.verbose:
                fprintf(char('\n### ecdfo: incorrect value of some options.tol (should be > 0)\n\n'))
            info.flag = copy(values.fail_on_argument)
            return info,options,values
    else:
        options.tol = copy(cat([1e-06],[1e-06],[1e-06]))
    if not isfield(options,char('df1')):
        options.df1 = copy(0)
    if isfield(options,char('hess_approx')):
        if char('bfgs') == lower(regexprep(strtrim(options.hess_approx),char('  *'),char(' '))):
            options.hess_approx = copy(values.bfgs)
        else:
            if char('model') == lower(regexprep(strtrim(options.hess_approx),char('  *'),char(' '))):
                options.hess_approx = copy(values.model)
            else:
                if options.verbose:
                    fprintf(options.fout,char('\n### ecdfo: options.hess_approx "%s" not recognized\n\n'),options.hess_approx)
                info.flag = copy(values.fail_on_argument)
                return info,options,values
    return info,options,values
