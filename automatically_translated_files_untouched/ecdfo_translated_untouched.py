# Autogenerated with SMOP version 
# main.py ecdfofiles/*
from __future__ import division
def ecdfo_swap_in_Y(i=None,j=None,QZ=None,RZ=None,Y=None,ind_Y=None,fY=None,ciY=None,ceY=None,xbase=None,whichmodel=None,scale=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 16-[i,j,QZ,RZ,Y,ind_Y,fY,ciY,ceY,xbase,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill].count(None)+len(args)

    if (i > j):
        ii=copy(j)
        jj=copy(i)
    else:
        if (i < j):
            ii=copy(i)
            jj=copy(j)
        else:
            return QZ,RZ,Y,ind_Y,fY,ciY,ceY,xbase,scale
    y=Y[:,ii]
    Y[:,ii]=Y[:,jj]
    Y[:,jj]=y
    ind=ind_Y[ii]
    ind_Y[ii]=ind_Y[jj]
    ind_Y[jj]=ind
    f=fY[ii]
    fY[ii]=fY[jj]
    fY[jj]=f
    if not isempty(ciY):
        ci=ciY[:,ii]
        ciY[:,ii]=ciY[:,jj]
        ciY[:,jj]=ci
    if not isempty(ceY):
        ce=ceY[:,ii]
        ceY[:,ii]=ceY[:,jj]
        ceY[:,jj]=ce
    QZ,RZ,xbase,scale=bcdfo_build_QR_of_Y(Y,whichmodel,shift_Y,Delta,normgx,kappa_ill,nargout=4)
    return QZ,RZ,Y,ind_Y,fY,ciY,ceY,xbase,scale
clear(char('all'))
close(char('all'))
format_(char('long'))
global n,nb,mi,me,prob,threshold
prob=1
x,lx,ux,dxmin,li,ui,dcimin,infb,n,nb,mi,me,info=ecdfo_init_prob(prob,nargout=13)
lb[arange(1,n)]=lx
ub[arange(1,n)]=ux
if mi:
    lb[arange(n + 1,n + mi)]=li
    ub[arange(n + 1,n + mi)]=ui
threshold=1e-08
options.algo_method = copy(char('quasi-Newton'))
options.algo_globalization = copy(char('trust regions'))
options.hess_approx = copy(char('model'))
options.bfgs_restart = copy(0)
options.algo_descent = copy(char('Powell'))
if nb + mi + me == 0:
    options.algo_descent = copy(char('Wolfe'))
options.tol[1]=1e-05
options.tol[2]=1e-05
options.tol[3]=1e-05
options.dxmin = copy(dxmin)
options.miter = copy(500)
options.msimul = copy(500)
options.verbose = copy(2)
lm=[]
x,lm,info=ecdfo(evalfgh,x,lm,lb,ub,options,nargout=3)
x
def ecdfo(func=None,x0=None,lm0=None,lb=None,ub=None,options=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[func,x0,lm0,lb,ub,options].count(None)+len(args)

    global prob,threshold
    c.free = copy(0)
    c.fixed = copy(1)
    c.alwaysfixed = copy(2)
    c.in = copy(1)
    c.out = copy(0)
    c.unused = copy(0)
    c.inY = copy(1)
    c.dummy = copy(1)
    c.nodummy = copy(0)
    x=copy(NaN)
    fx=copy(NaN)
    gx=copy(NaN)
    nit=0
    nitold=0
    neval=0
    errg=copy(Inf)
    X=matlabarray([])
    fX=matlabarray([])
    xstatus=matlabarray([])
    sstatus=matlabarray([])
    dstatus=matlabarray([])
    sspace_save=matlabarray([])
    xspace_save=matlabarray([])
    ndummyY=0
    info.flag = copy(0)
    rand(char('seed'),pi / sqrt(2))
    randn(char('seed'),5)
    if (size(x0,1) == 1 and size(x0,2) > 1):
        x0=x0.T
    n=length(x0)
    pquad=((n + 1) * (n + 2)) / 2
    pdiag=2 * n + 1
    plin=n + 1
    msg=char('Unexpected exit')
    poisedness_known=0
    eps_rho=1e-14
    stallfact=10 * eps
    factor_Dmax=100000.0
    factor_fmax=1e+20
    CNTsin=0
    Delta0=1
    cur_degree=copy(plin)
    rep_degree=copy(plin)
    epsilon=1e-05
    maxeval=200 * n
    maxit=copy(maxeval)
    verbose=1
    show_errg=0
    initial_Y=char('simplx')
    eta1=0.0001
    eta2=0.9
    gamma1=0.01
    gamma2=0.5
    gamma3=2.0
    interpol_TR=1
    factor_CV=100
    Lambda_XN=1e-10
    Lambda_CP=1.2
    Lambda_FP=1e-10
    factor_FPU=1
    factor_FPR=10
    criterion_S=char('distance')
    criterion_FP=char('distance')
    criterion_CP=char('standard')
    mu0=0
    mu=0
    theta=1
    eps_TR=0.0001
    eps_L=0.001
    shift_Y=1
    lSolver=1
    stratLam=1
    kappa_ill=1e+15
    kappa_th=2000
    eps_bnd=epsilon / 10
    whichmodel=0
    hardcons=0
    noisy=0
    scaleX=0
    scalefacX=ones(1,n)
    shrink_Delta=1
    Deltamax=factor_Dmax * Delta0
    if nargin < 2:
        fprintf(char('\n### EC-DFO: the first 2 arguments are required\n\n'))
        x=matlabarray([])
        lm=matlabarray([])
        info.flag = copy(1)
        return x,lm,info
    if nargin < 3:
        lm0=matlabarray([])
    else:
        lm0=lm0[:]
    if nargin < 4:
        lb=matlabarray([])
    else:
        lb=lb[:]
    if nargin < 5:
        ub=matlabarray([])
    else:
        ub=ub[:]
    if nargin < 6:
        options.fout = copy(1)
        options.verbose = copy(1)
    if prob == 100:
        Delta0=0.01
        epsilon=0.001
        if exist(char('fvalues_ecdfo_karmanogive.dat'),char('file')) == 2:
            delete(char('fvalues_ecdfo_karmanogive.dat'))
    x0
    n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values=ecdfo_prelim(func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options,nargout=47)
    if info.flag:
        return x,lm,info
    x0=copy(x)
    eps_current=max(mu0 * normgx,epsilon)
    fxmax=min(1e+25,factor_fmax * abs_(fx))
    M=eye(n)
    if (verbose):
        fid=fopen(char('convhist.m'),char('w'))
        fprintf(fid,char('function A=history \n A=[ \n'))
        fprintf(fid,char('%6d  %+.14e %.2e \n'),neval,fx,normgx)
        fclose(fid)
    nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,Delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info=ecdfo_main(func,n,nb,mi,me,lm,nitold,nit,i_xbest,lb,ub,m,X,fX,ciX,ceX,ind_Y,QZ,RZ,Delta,cur_degree,neval,maxeval,maxit,fcmodel,gx,normgx,show_errg,pquad,pdiag,plin,stallfact,eps_rho,Deltamax,rep_degree,epsilon,verbose,eta1,eta2,gamma1,gamma2,gamma3,interpol_TR,factor_CV,Lambda_XN,Lambda_CP,factor_FPU,factor_FPR,Lambda_FP,criterion_S,criterion_FP,criterion_CP,mu,theta,eps_TR,eps_L,lSolver,stratLam,eps_current,vstatus,xstatus,sstatus.T,dstatus,ndummyY,sspace_save,xspace_save,xfix,fxmax,poised_model,M,kappa_ill,kappa_th,eps_bnd,poised,Y_radius,c,char('toplevel'),whichmodel,hardcons,noisy,scaleX,scalefacX,CNTsin,shrink_Delta,scale,shift_Y,info,options,values,nargout=29)
    if (verbose):
        fid=fopen(char('convhist.m'),char('a'))
        fprintf(fid,char('];'))
        fclose(fid)
    if (nfix > 0):
        I=eye(n + nfix)
        x=I[:,indfix] * xfix[indfix] + I[:,indfree] * x
        gx=I[:,indfix] * zeros(nfix,1) + I[:,indfree] * gx
        Ilm=eye(n + nfix + me + mi)
        indfree_lm=setdiff(arange(1,n + nfix + me + mi),indfix)
        lm=Ilm[:,indfix] * zeros(nfix,1) + Ilm[:,indfree_lm] * lm
        n=n + nfix
    if (scaleX):
        x=x / scalefacX
    info_best=copy(info)
    info_best.f = copy(fx)
    x=X[:,i_xbest]
    ecdfo_finish(nb,mi,me,info_best,options,values)
    if options.verbose > 2:
        if nb:
            fprintf(options.fout,char('VARIABLES:\n'))
            fprintf(options.fout,char('i     lower bound          x            upper bound       multiplier\n'))
            for i in arange(1,min(n,40)).reshape(-1):
                fprintf(options.fout,char('%0i %+16.6e %+16.6e %+16.6e %+16.6e\n'),i,lb[i],x[i],ub[i],lm[i])
            if (n > 40):
                fprintf(options.fout,char('.....\n'))
            else:
                fprintf(options.fout,char('\n'))
        else:
            fprintf(options.fout,char('VARIABLES:\n'))
            fprintf(options.fout,char('%16.6e\n'),x[1:min(n,40)])
            if (n > 40):
                fprintf(options.fout,char('.....\n'))
            else:
                fprintf(options.fout,char('\n'))
        if mi:
            fprintf(options.fout,char('INEQUALITY CONSTRAINTS:\n'))
            fprintf(options.fout,char('i     lower bound          ci           upper bound       multiplier\n'))
            for i in arange(1,min(mi,40)).reshape(-1):
                fprintf(options.fout,char('%0i %+16.6e %+16.6e %+16.6e %+16.6e\n'),i,lb[n + i],ciX[i,i_xbest],ub[n + i],lm[n + i])
            if (mi > 40):
                fprintf(options.fout,char('\n.....'))
            else:
                fprintf(options.fout,char('\n'))
        if me:
            fprintf(options.fout,char('EQUALITY CONSTRAINTS:\n'))
            fprintf(options.fout,char('i         ce            multiplier\n'))
            for i in arange(1,min(me,40)).reshape(-1):
                fprintf(options.fout,char('%0i %+16.6e %+16.6e\n'),i,ceX[i,i_xbest],lm[n + mi + i])
            if (me > 40):
                fprintf(options.fout,char('.....\n'))
            else:
                fprintf(options.fout,char('\n'))
    return x,lm,info
def ecdfo_augmX_evalf(f=None,y=None,m=None,X=None,fX=None,ciX=None,ceX=None,nfix=None,xfix=None,indfix=None,indfree=None,fxmax=None,neval=None,xstatus=None,xstatus_val=None,sstatus=None,dstatus=None,scaleX=None,scalefacX=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 22-[f,y,m,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,fxmax,neval,xstatus,xstatus_val,sstatus,dstatus,scaleX,scalefacX,info,options,values].count(None)+len(args)

    full_n=length(xfix)
    I=eye(full_n)
    xstatus[m]=xstatus_val
    sstatus[m]=1
    dstatus[m]=0
    if (nfix > 0):
        yfull=I[:,indfix] * xfix[indfix] + I[:,indfree] * y
        X[:,m]=yfull
        if (scaleX):
            yfull=yfull / scalefacX
        info.nsimul[2]=info.nsimul(2) + 1
        outdic,fvalue,info.ci,info.ce=f[2,yfull]
        info.f = copy(fvalue)
    else:
        X[:,m]=y
        if (scaleX):
            y=y / scalefacX
        info.nsimul[2]=info.nsimul(2) + 1
        outdic,fvalue,info.ci,info.ce=f[2,y]
        info.f = copy(fvalue)
    if outdic == 1:
        if options.verbose:
            fprintf(options.fout,char('### ecdfo_augmX_evalf: initial point x is out of domain\n\n'))
        info.flag = copy(values.fail_on_simul)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if isnan(fvalue):
        if options.verbose:
            fprintf(options.fout,char('### ecdfo_augmX_evalf: f is NaN at the point x\n\n'))
            x=copy(y)
        info.flag = copy(values.fail_on_simul)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if isinf(fvalue):
        if options.verbose:
            fprintf(options.fout,char('### ecdfo_augmX_evalf: f is Inf at the point x\n\n'))
            x=copy(y)
        info.flag = copy(values.fail_on_simul)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if outdic:
        info=sqplab_badsimul(outdic,info,options,values)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if not isempty(info.ci) and size(info.ci,2) != 1:
        if options.verbose:
            fprintf(options.fout,char('### ecdfo_augmX_evalf: the computed ci must be a row vector\n\n'))
        info.flag = copy(values.fail_on_simul)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if not isempty(info.ce) and size(info.ce,2) != 1:
        if options.verbose:
            fprintf(options.fout,char('### ecdfo_augmX_evalf: the computed ce must be a row vector\n\n'))
        info.flag = copy(values.fail_on_simul)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    fX[m]=min(fxmax,real(fvalue))
    if not isempty(info.ci):
        ciX[:,m]=real(info.ci.T)
    if not isempty(info.ce):
        ceX[:,m]=real(info.ce.T)
    neval=neval + 1
    return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
def ecdfo_check_cond(A=None,cthreshold=None,options=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 3-[A,cthreshold,options].count(None)+len(args)

    badcond=0
    eps=1e-14
    if (isempty(find(isnan(A))) and isempty(find(isinf(A)))):
        condA=cond(A)
        if (condA > cthreshold):
            badcond=1
    else:
        badcond=1
    if (badcond):
        U,S,V=svd(A,0,nargout=3)
        Sdiag=diag(S)
        Sdiag[Sdiag < 1e-07]=1e-07
        S=diag(Sdiag)
        A=(V * S * U.T).T
        if norm(A - A.T,inf) > eps:
            if options.verbose >= 3:
                disp(cat(char('### ecdfo_check_cond: '),char("matrix is non symmetric. Resetting A=(A+A')/2.")))
            A=(A + A.T) * 0.5
    return A,badcond
def ecdfo_check_convex(A=None,options=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 2-[A,options].count(None)+len(args)

    ev=eig(A)
    evneg=ev[ev < 0]
    if not isempty(evneg):
        ZERO=1e-10
        EPS=1e-09
        v,d=eig(A,nargout=2)
        d=diag(d)
        d[d < ZERO]=EPS
        d=diag(d)
        A=v * d * v.T
        if not isempty(find(not isreal(A),1)):
            if options.verbose >= 3:
                disp(char('### ecdfo_check_convex: matrix is non symmetric. Resetting A.'))
            A=(A + A.T) * 0.5
    return A
def ecdfo_computeHessian(simul=None,x=None,null_step=None,constrained_pbl=None,lm=None,M=None,n=None,me=None,mi=None,s=None,gx=None,gci=None,gce=None,info=None,options=None,values=None,fcmodel=None,Y=None,fY=None,ciY=None,ceY=None,sigma=None,scale=None,shift_Y=None,QZ=None,RZ=None,whichmodel=None,ind_Y=None,i_xbest=None,m=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 30-[simul,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m].count(None)+len(args)

    pc=1.0
    if options.algo_method == values.newton:
        info.nsimul[3]=info.nsimul(3) + 1
        outdic,tmp,tmp,tmp,tmp,info.g,info.ai,info.ae=simul[3,x]
        if outdic:
            info=sqplab_badsimul(outdic,info,options,values)
            return M,pc,info
        info.nsimul[5]=info.nsimul(5) + 1
        outdic,M=simul[5,x,lm]
        if outdic:
            info=sqplab_badsimul(outdic,info,options,values)
            return M,pc,info
    else:
        if not null_step:
            if options.hess_approx == values.bfgs:
                if options.verbose >= 4:
                    if constrained_pbl:
                        fprintf(options.fout,char('\nBFGS update:\n'))
                    else:
                        fprintf(options.fout,char('\nBFGS inverse update:\n'))
                y=- info.g
                if me:
                    y=y - info.ae.T * lm[n + mi + 1:n + mi + me]
                info.g = copy(gx)
                info.ai = copy(gci)
                info.ae = copy(gce)
                y=y + info.g
                if me:
                    y=y + info.ae.T * lm[n + mi + 1:n + mi + me]
                if options.bfgs_restart > 0 and mod(info.nsimul(2),options.bfgs_restart) == 0:
                    M=eye(size(M))
                    pc=2.0
                else:
                    first=0
                    if info.niter == 1:
                        first=1
                    M,pc,info,values=sqplab_bfgs(M,y,s,first,info,options,values,nargout=4)
                    if info.flag == values.fail_strange:
                        M=eye(size(M))
                        M,pc,info,values=sqplab_bfgs(M,y,s,first,info,options,values,nargout=4)
                        if info.flag == values.fail_strange:
                            return M,pc,info
            else:
                if options.hess_approx == values.model:
                    info.g = copy(gx)
                    info.ai = copy(gci)
                    info.ae = copy(gce)
                    cur_degree=size(Y,2)
                    if me + mi > 0:
                        if length(ceY) > 0:
                            for i in arange(1,cur_degree).reshape(-1):
                                norm_ceY[i]=norm(ceY[:,i])
                        else:
                            norm_ceY=zeros(1,cur_degree)
                        meritfY=fY + sigma.dot(norm_ceY)
                        model=bcdfo_computeP(QZ,RZ,Y,meritfY,whichmodel,fcmodel[1,:],ind_Y,i_xbest,m,gx,scale,shift_Y)
                        M=bcdfo_hessP(model,x,x,scale,shift_Y)
                    else:
                        M=bcdfo_hessP(fcmodel[1,:],x,x,scale,shift_Y)
                else:
                    if options.verbose:
                        fprintf(options.fout,char('\n### ecdfo: options.hess_approx not recognized\n\n'))
                    info.flag = copy(values.fail_on_argument)
                    return M,pc,info
    return M,pc,info
def ecdfo_find_smallf(c=None,QZ=None,RZ=None,Y=None,fY=None,ciY=None,ceY=None,ind_Y=None,i_xbest=None,cur_degree=None,indfree=None,x=None,xl=None,xu=None,fx=None,dstatus=None,whichmodel=None,scale=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,sigma=None,info=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 24-[c,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,cur_degree,indfree,x,xl,xu,fx,dstatus,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,sigma,info].count(None)+len(args)

    dummy_set=find(dstatus == c.dummy)
    ind_insideBounds=matlabarray([])
    for i in arange(1,cur_degree).reshape(-1):
        if ((isempty(find(Y[:,i] < xl[indfree] or Y[:,i] > xu[indfree],1))) and (isempty(find(dummy_set == ind_Y[i],1)))):
            ind_insideBounds[i]=i
        else:
            ind_insideBounds[i]=1
    if length(ceY) > 0:
        for i in arange(1,cur_degree).reshape(-1):
            norm_ceY[i]=norm(ceY[:,i])
    else:
        norm_ceY=zeros(1,cur_degree)
    meritY=fY + sigma.dot(norm_ceY)
    fmin,imin=min(meritY[ind_insideBounds],nargout=2)
    if (imin != 1 and fmin < meritY[1]):
        QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=ecdfo_swap_in_Y(1,imin,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,nargout=9)
        fx=fY[1]
        i_xbest=ind_Y[1]
        if (not shift_Y):
            x=Y[:,1]
    info.f = copy(fY[1])
    if length(ceY) > 0:
        info.ce = copy(ceY[:,1])
    if length(ciY) > 0:
        info.ci = copy(ciY[:,1])
    return x,fx,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,scale,info
def ecdfo_finish(nb=None,mi=None,me=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[nb,mi,me,info,options,values].count(None)+len(args)

    if options.verbose >= 2:
        fprintf(options.fout,char('%s\n'),values.dline)
        fprintf(options.fout,char('  Exit code %i: '),info.flag)
        if values.success == info.flag:
            fprintf(options.fout,char('converged'))
        else:
            if values.fail_on_argument == info.flag:
                fprintf(options.fout,char('wrong argument'))
            else:
                if values.fail_on_problem == info.flag:
                    fprintf(options.fout,char('unaccepted problem structure'))
                else:
                    if values.fail_on_simul == info.flag:
                        fprintf(options.fout,char('error when calling the simulator'))
                    else:
                        if values.stop_on_simul == info.flag:
                            fprintf(options.fout,char('the simulator wants to stop'))
                        else:
                            if values.stop_on_max_iter == info.flag:
                                fprintf(options.fout,char('max iteration reached'))
                            else:
                                if values.stop_on_max_simul == info.flag:
                                    fprintf(options.fout,char('max simulation reached'))
                                else:
                                    if values.stop_on_dxmin == info.flag:
                                        fprintf(options.fout,char('too small variation in x (dxmin active)'))
                                    else:
                                        if values.fail_on_non_decrease == info.flag:
                                            fprintf(options.fout,char('the merit function cannot be decreased'))
                                        else:
                                            if values.fail_on_ascent_dir == info.flag:
                                                fprintf(options.fout,char('ascent direction encountered in linesearch'))
                                            else:
                                                if values.fail_on_max_ls_iter == info.flag:
                                                    fprintf(options.fout,char('too many stepsize trials in linesearch'))
                                                else:
                                                    if values.fail_on_ill_cond == info.flag:
                                                        fprintf(options.fout,char('ill conditioning'))
                                                    else:
                                                        if values.fail_on_null_step == info.flag:
                                                            fprintf(options.fout,char('null step d is solution of %0i QPs'),values.max_null_steps + 1)
                                                        else:
                                                            if values.fail_on_infeasible_QP == info.flag:
                                                                fprintf(options.fout,char('infeasible QP'))
                                                            else:
                                                                if values.fail_on_unbounded_QP == info.flag:
                                                                    fprintf(options.fout,char('unbounded QP'))
                                                                else:
                                                                    if values.fail_strange == info.flag:
                                                                        fprintf(options.fout,char('strange failure, call a guru'))
                                                                    else:
                                                                        if values.stop_on_small_trust_region == info.flag:
                                                                            fprintf(options.fout,char('trust region radius small'))
        fprintf(options.fout,char('\n'))
        fprintf(options.fout,char('%s\n'),values.dline)
        fprintf(options.fout,char('  Final function value                     %12.5e\n'),info.f)
        fprintf(options.fout,char('  Optimality conditions:\n'))
        if nb + mi + me > 0:
            fprintf(options.fout,char('  . gradient of the Lagrangian (inf norm)  %11.5e\n'),info.glagn)
            fprintf(options.fout,char('  . feasibility                            %11.5e\n'),info.feasn)
            if nb + mi:
                fprintf(options.fout,char('  . complementarity                        %11.5e\n'),info.compl)
        else:
            fprintf(options.fout,char('  Gradient of the cost function (inf norm)  %11.5e\n'),info.glagn)
        fprintf(options.fout,char('  Counters:\n'))
        fprintf(options.fout,char('  . nbr of iterations                   %4i\n'),info.niter)
        fprintf(options.fout,char('  . nbr of function evaluations         %4i\n'),info.nsimul(2) + info.nsimul(4))
        fprintf(options.fout,char('  . nbr of gradient evaluations         %4i\n'),info.nsimul(3) + info.nsimul(4))
    fprintf(options.fout,char('%s\n'),values.sline)
    return
def ecdfo_func(x=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    global prob
    msg=matlabarray([])
    f=matlabarray([])
    ci=matlabarray([])
    ce=matlabarray([])
    if prob == 1:
        f=- (5 - (x[1] - 2) ** 2 - 2 * (x[2] - 1) ** 2)
        ce=x[1] + 4 * x[2] - 3
    else:
        if prob == 2:
            f=2 * x[1] ** 2 + x[2] ** 2
            ce=x[1] + x[2] - 1
        else:
            if prob == 3:
                f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2
                ce[1]=x[1] + x[2] + x[3]
                ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                ce=ce.T
            else:
                if prob == 4:
                    f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4]
                    ce[1]=x[1] + x[2] + x[3]
                    ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                    ce[3]=x[4] ** 3 - 1
                    ce=ce.T
                else:
                    if prob == 5:
                        f=exp(x[1] * x[2] * x[3] * x[4] * x[5])
                        ce[1]=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4] ** 2 + x[5] ** 2 - 10
                        ce[2]=x[2] * x[3] - 5 * x[4] * x[5]
                        ce[3]=x[1] ** 3 + x[2] ** 3 + 1
                        ce=ce.T
    msg=0
    return msg,f,ci,ce
def ecdfo_func_grad(indic=None,x=None,n=None,me=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 4-[indic,x,n,me].count(None)+len(args)

    global prob
    outdic=matlabarray([])
    f=matlabarray([])
    ci=matlabarray([])
    ce=matlabarray([])
    g=matlabarray([])
    ai=matlabarray([])
    ae=matlabarray([])
    if prob == 0:
        if (indic == 2) or (indic == 4):
            f,ce=cuter_objcons(x,nargout=2)
    else:
        if prob == 1:
            if (indic == 2) or (indic == 4):
                f=- (5 - (x[1] - 2) ** 2 - 2 * (x[2] - 1) ** 2)
                ce=x[1] + 4 * x[2] - 3
            if (indic == 3) or (indic == 4):
                pass
        else:
            if prob == 2:
                if (indic == 2) or (indic == 4):
                    f=2 * x[1] ** 2 + x[2] ** 2
                    ce=x[1] + x[2] - 1
                if (indic == 3) or (indic == 4):
                    pass
            else:
                if prob == 3:
                    if (indic == 2) or (indic == 4):
                        f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2
                        ce[1]=x[1] + x[2] + x[3]
                        ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                        ce=ce.T
                    if (indic == 3) or (indic == 4):
                        pass
                else:
                    if prob == 4:
                        if (indic == 2) or (indic == 4):
                            f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4] + x[5] ** 2
                            ce[1]=x[1] + x[2] + x[3]
                            ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                            ce[3]=x[4] ** 3 + x[5] - 1
                            ce=ce.T
                        if (indic == 3) or (indic == 4):
                            pass
                    else:
                        if prob == 5:
                            if indic == 2 or indic == 4:
                                f=exp(x[1] * x[2] * x[3] * x[4] * x[5])
                                ce[1]=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4] ** 2 + x[5] ** 2 - 10
                                ce[2]=x[2] * x[3] - 5 * x[4] * x[5]
                                ce[3]=x[1] ** 3 + x[2] ** 3 + 1
                                ce=ce.T
                        else:
                            if prob == 100:
                                oldFolder=cd(char('../../code_lokal/VonKarmanOgive'))
                                fid=fopen(char('IN_IOSO.DAT'),char('w'))
                                for i in arange(1,length(x)).reshape(-1):
                                    fprintf(fid,char('%f\n'),x[i])
                                fclose(fid)
                                not test.exe
                                fid=fopen(char('OUT_IOSO.dat'),char('r'))
                                f_orig=str2double(fgetl(fid))
                                ce=str2double(fgetl(fid)) - 0.0655
                                fclose(fid)
                                cd(oldFolder)
                                if (f_orig > 1e+16):
                                    f_orig
                                    oldFolder=cd(char('../../code_lokal/VonKarmanOgive'))
                                    not test.exe
                                    fid=fopen(char('OUT_IOSO.dat'),char('r'))
                                    f_orig=str2double(fgetl(fid))
                                    ce=str2double(fgetl(fid)) - 0.0655
                                    fclose(fid)
                                    cd(oldFolder)
                                    if (f_orig > 1e+16):
                                        f_orig
                                        load(char('fvalues_ecdfo_karmanogive.dat'))
                                        sz_fval=size(fvalues_ecdfo_karmanogive,1)
                                        if sz_fval > 10:
                                            val_new=sum_(fvalues_ecdfo_karmanogive(arange(sz_fval - 9,sz_fval),arange()),1) / 10
                                        else:
                                            val_new=sum_(fvalues_ecdfo_karmanogive,1) / sz_fval
                                        f=val_new[2]
                                        ce=val_new[3]
                                    else:
                                        f=copy(f_orig)
                                else:
                                    f=copy(f_orig)
                                fid=fopen(char('fvalues_ecdfo_karmanogive.dat'),char('a'))
                                fprintf(fid,char('%f %f %f\n'),f_orig,f,ce)
                                fclose(fid)
                                disp(cat(char('fval = '),num2str(f),char(', cval = '),num2str(ce)))
    outdic=0
    return outdic,f,ci,ce,g,ai,ae
def hessian_lagr(xy=None,lm=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 2-[xy,lm].count(None)+len(args)

    outdic=matlabarray([])
    hl=matlabarray([])
    x=xy[1:HC_nj]
    y=xy[HC_nj + 1:n]
    i=cat(arange(1,HC_nj - 1)).T
    j=cat(arange(2,HC_nj)).T
    v=- 2 * lm[n + 2:n + HC_nj]
    hl=sparse(i,j,v,HC_nj,HC_nj)
    hl=hl.T + 2 * sparse(diag(lm[n + 1:n + HC_nj] + lm[n + 2:n + nbars])) + hl
    hl=matlabarray(cat([hl,zeros(HC_nj)],[zeros(HC_nj),hl]))
    outdic=0
    return outdic,hl
def ecdfo_init_prob(prob=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 1-[prob].count(None)+len(args)

    global fileoutput,simul_not_initialized
    x0=matlabarray([])
    lx=matlabarray([])
    ux=matlabarray([])
    li=matlabarray([])
    ui=matlabarray([])
    fileoutput=1
    simul_not_initialized=1
    dxmin=1e-06
    dcimin=sqrt(eps)
    infb=1e+20
    if prob == 1:
        n=2
        nb=2
        mi=0
        me=1
        x0=matlabarray(cat([4.6],[0.0]))
        lx=matlabarray(cat(1.95,- 1e+20))
        ux=matlabarray(cat(1e+20,0.3))
    else:
        if prob == 2:
            n=2
            nb=0
            mi=0
            me=1
            x0=matlabarray(cat([- 1],[2.54378]))
            lx=- inf * ones(n,1)
            ux=inf * ones(n,1)
        else:
            if prob == 3:
                nb=0
                mi=0
                me=2
                x0=matlabarray(cat([0.0],[0.0],[0.5]))
                n=length(x0)
                lx=matlabarray(cat(- 0.5,0.0,- inf))
                ux=matlabarray(cat(inf,inf,inf))
            else:
                if prob == 4:
                    nb=0
                    mi=0
                    me=3
                    x0=matlabarray(cat([1.0],[1.0],[1.0],[0.0]))
                    n=length(x0)
                    lx=- inf * ones(n,1)
                    ux=inf * ones(n,1)
                else:
                    if prob == 5:
                        nb=0
                        mi=0
                        me=3
                        x0=matlabarray(cat([- 2.0],[2.0],[2.0],[1.0],[1.0]))
                        n=5
                        lx=- inf * ones(n,1)
                        ux=inf * ones(n,1)
    info=0
    return x0,lx,ux,dxmin,li,ui,dcimin,infb,n,nb,mi,me,info
def ecdfo_iter_printout(info=None,old_delta=None,norms=None,pc=None,itype=None,values=None,nb=None,mi=None,options=None,constrained_pbl=None,merit=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 11-[info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit].count(None)+len(args)

    if options.verbose < 4:
        fprintf(options.fout,char('%4i  %4i'),info.niter,info.nsimul(2) + info.nsimul(4))
        fprintf(options.fout,char('  %+14.8e  %+14.8e  '),info.f,merit)
        if constrained_pbl:
            fprintf(options.fout,char('%10.4e  %14.8e'),info.glagn,info.feasn)
        else:
            fprintf(options.fout,char('%10.4e'),info.glagn)
        if info.niter > 1:
            fprintf(options.fout,char('  %8.2e'),old_delta)
            fprintf(options.fout,char('  %8.2e'),norms)
            fprintf(options.fout,char('  %4.2f'),pc)
            fprintf(options.fout,char('  %5s\n'),itype)
        else:
            fprintf(options.fout,char('  \n'))
    if options.verbose >= 4:
        fprintf(options.fout,char('%s\n'),values.dline)
        fprintf(options.fout,char('iter %i,'),info.niter)
        fprintf(options.fout,char('  cost %12.5e'),info.f)
        if constrained_pbl:
            fprintf(options.fout,char(',  glagn %11.5e,  feas %11.5e'),info.glagn,info.feasn)
            if (nb + mi > 0):
                fprintf(options.fout,char(',  compl %11.5e'),info.compl)
        else:
            fprintf(options.fout,char(',  grad %11.5e'),info.glagn)
        if info.niter > 1:
            fprintf(options.fout,char('  %4.2f\n'),pc)
        else:
            fprintf(options.fout,char('  \n'))
    return
def ecdfo_main(func=None,n=None,nb=None,mi=None,me=None,lm=None,nitold=None,nit=None,i_xbest=None,lb=None,ub=None,m=None,X=None,fX=None,ciX=None,ceX=None,ind_Y=None,QZ=None,RZ=None,delta=None,cur_degree=None,neval=None,maxeval=None,maxit=None,fcmodel=None,gx=None,normgx=None,show_errg=None,pquad=None,pdiag=None,plin=None,stallfact=None,eps_rho=None,Deltamax=None,rep_degree=None,epsilon=None,verbose=None,eta1=None,eta2=None,gamma1=None,gamma2=None,gamma3=None,interpol_TR=None,factor_CV=None,Lambda_XN=None,Lambda_CP=None,factor_FPU=None,factor_FPR=None,Lambda_FP=None,criterion_S=None,criterion_FP=None,criterion_CP=None,mu=None,theta=None,eps_TR=None,eps_L=None,lSolver=None,stratLam=None,eps_current=None,vstatus=None,xstatus=None,sstatus=None,dstatus=None,ndummyY=None,sspace_save=None,xspace_save=None,xfix=None,fxmax=None,poised_model=None,M=None,kappa_ill=None,kappa_th=None,eps_bnd=None,poised=None,Y_radius=None,c=None,level=None,whichmodel=None,hardcons=None,noisy=None,scaleX=None,scalefacX=None,CNTsin=None,shrink_Delta=None,scale=None,shift_Y=None,info=None,options=None,values=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 89-[func,n,nb,mi,me,lm,nitold,nit,i_xbest,lb,ub,m,X,fX,ciX,ceX,ind_Y,QZ,RZ,delta,cur_degree,neval,maxeval,maxit,fcmodel,gx,normgx,show_errg,pquad,pdiag,plin,stallfact,eps_rho,Deltamax,rep_degree,epsilon,verbose,eta1,eta2,gamma1,gamma2,gamma3,interpol_TR,factor_CV,Lambda_XN,Lambda_CP,factor_FPU,factor_FPR,Lambda_FP,criterion_S,criterion_FP,criterion_CP,mu,theta,eps_TR,eps_L,lSolver,stratLam,eps_current,vstatus,xstatus,sstatus,dstatus,ndummyY,sspace_save,xspace_save,xfix,fxmax,poised_model,M,kappa_ill,kappa_th,eps_bnd,poised,Y_radius,c,level,whichmodel,hardcons,noisy,scaleX,scalefacX,CNTsin,shrink_Delta,scale,shift_Y,info,options,values].count(None)+len(args)

    old_delta=copy(delta)
    sigma=1
    rho_factor=0.3
    tau1=copy(gamma2)
    tau2=copy(gamma3)
    tau3=5
    constrained_pbl=copy(me)
    null_step=0
    merit=info.f + sigma * norm(info.ce)
    msg=char('Unexpected message from ecdfo_main')
    m=size(X,2)
    indfree=find(vstatus == c.free)
    indfix=find(vstatus >= c.fixed)
    nfix=length(indfix)
    Y=X[indfree,ind_Y]
    x=X[indfree,i_xbest]
    n=size(Y,1)
    fY=fX[ind_Y]
    fx=fX[i_xbest]
    itype=char(' ')
    pc=0
    norms=0
    pred=0
    if mi > 0:
        ciY=ciX[:,ind_Y]
    else:
        ciY=matlabarray([])
        gci=matlabarray([])
    if me > 0:
        ceY=ceX[:,ind_Y]
    else:
        ceY=matlabarray([])
        gce=matlabarray([])
    radius_has_been_rejected=copy(false)
    while 1:

        if info.niter >= options.miter:
            info.flag = copy(values.stop_on_max_iter)
            ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        if info.nsimul(2) >= options.msimul:
            info.flag = copy(values.stop_on_max_simul)
            ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        xk=copy(x)
        lbounds=- inf * ones(size(x))
        ubounds=inf * ones(size(x))
        ilb=abs_(lb[indfree] - x) < 1e-05
        iub=abs_(ub[indfree] - x) < 1e-05
        lbounds[ilb]=lb[indfree[ilb]]
        ubounds[iub]=ub[indfree[iub]]
        lm,info=sqplab_lsmult(x,lbounds,ubounds,info,options,values,nargout=2)
        feas,comp,info=ecdfo_optimality(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
        if info.flag:
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        info.glagn = copy(norm(info.glag,inf))
        info.feasn = copy(norm(feas,inf))
        info.compl = copy(norm(comp,inf))
        if (info.niter > 0) and (options.verbose >= 3):
            fprintf(options.fout,char('\nOptimality:\n'))
            if constrained_pbl:
                fprintf(options.fout,char('  |grad Lag|      = %12.5e\n'),info.glagn)
                fprintf(options.fout,char('  feasibility     = %12.5e\n'),info.feasn)
            else:
                fprintf(options.fout,char(' |grad f| = %12.5e\n'),info.glagn)
        if ((info.glagn <= options.tol(1)) and (info.feasn <= options.tol(2)) and (info.compl <= options.tol(3))) or delta <= epsilon * 1e-05 or (pred == - 1.0):
            augment=rep_degree - cur_degree
            if (augment <= 0):
                poised,Y_radius=bcdfo_poisedness_Y(QZ,RZ,Y,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                poisedness_known=1
                errg=poised * Y_radius / factor_CV
                if options.verbose >= 3:
                    disp(cat(char('error on gradient before set improvement = '),num2str(errg)))
                if ((((info.glagn <= options.tol(1)) and (info.feasn <= options.tol(2)) and (info.compl <= options.tol(3)) and errg <= epsilon) or delta <= epsilon * 1e-05) and strcmp(level,char('toplevel'))):
                    info.niter = copy(info.niter + 1)
                    itype=char('conv')
                    ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
                    info.flag = copy(values.success)
                    msg=matlabarray(cat(char(' Convergence in '),int2str(neval),char(' evaluations of the objective function.')))
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                else:
                    info.niter = copy(info.niter + 1)
                    ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
            if options.verbose >= 3:
                disp(char('not immediately converged - improve set!'))
            itype=char('impr')
            if (augment <= 0):
                eps_current=max(mu * eps_current,epsilon)
            if (normgx <= epsilon):
                effective_FPR=1
            else:
                effective_FPR=copy(factor_FPR)
            if (augment > 0):
                itype=char('augm')
                if (info.glagn <= epsilon):
                    if (lSolver == 2):
                        delta=epsilon / sqrt(n)
                        eps_current=epsilon / sqrt(n)
                    else:
                        delta=copy(epsilon)
                        eps_current=copy(epsilon)
                ynew=- delta * ones(n,1) + 2 * delta * rand(n,1)
                cur_degree,QZ,RZ,Y,xbase,scale=bcdfo_augment_Y(ynew,Y[:,1:cur_degree],whichmodel,shift_Y,delta,normgx,kappa_ill,nargout=6)
                ind_Y[cur_degree]=cur_degree
                if (hardcons):
                    ynew,improvement=bcdfo_find_new_yj_bc(QZ,RZ,Y,cur_degree,delta,eps_L,xbase,lSolver,whichmodel,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
                else:
                    ynew,improvement=bcdfo_find_new_yj(QZ,RZ,Y,cur_degree,delta,eps_L,xbase,lSolver,whichmodel,scale,shift_Y,nargout=2)
                QZ,RZ,Y,xbase,scale=bcdfo_replace_in_Y(QZ,RZ,ynew,Y,cur_degree,xbase,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=5)
                replaced=matlabarray(cat(cur_degree))
            else:
                if (info.glagn <= factor_CV * epsilon):
                    if (lSolver == 2):
                        radius=min(delta / sqrt(n),epsilon / sqrt(n))
                    else:
                        radius=min(delta,epsilon)
                else:
                    radius=max(delta,eps_current)
                QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y(QZ,RZ,Y,radius,effective_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,normgx,kappa_ill,nargout=8)
                if options.verbose >= 3:
                    disp(cat(char('improve interpolation set (in radius = '),num2str(radius),char(') : replaced = '),num2str(replaced),char(', poised = '),num2str(poised),char(', Y_radius = '),num2str(Y_radius)))
            if (options.verbose >= 4):
                poised,Y_radius=bcdfo_poisedness_Y(QZ,RZ,Y,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                disp(cat(char(' poisedness(Y) = '),num2str(poised)))
            poised_model=1
            for i in arange(1,length(replaced)).reshape(-1):
                j=replaced[i]
                m=m + 1
                xstatus[ind_Y[j]]=c.unused
                ind_Y[j]=m
                xstatus[m]=c.inY
                X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf(func,Y[:,j],m,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,fxmax,neval,xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=10)
                fY[j]=fX[m]
                if mi > 0:
                    ciY[:,j]=info.ci.T
                if me > 0:
                    ceY[:,j]=info.ce.T
                poised_model=0
                if (strcmp(msg[1:5],char('Error'))):
                    if (strcmp(level,char('toplevel'))):
                        disp(msg)
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            i_xold=copy(i_xbest)
            x,fx,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,scale,info=ecdfo_find_smallf(c,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,cur_degree,indfree,x,lb,ub,fx,dstatus,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,sigma,info,nargout=12)
            fcmodel=bcdfo_computeP(QZ,RZ,Y,cat([fY],[ciY],[ceY]),whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
            gx=bcdfo_gradP(fcmodel[1,:],x,x,scale,shift_Y)
            normgx=bcdfo_projgrad(n,x,gx,lb[indfree],ub[indfree])
            if mi > 0:
                gci=zeros(mi,n)
                for i in arange(1,mi).reshape(-1):
                    gci[i,:]=bcdfo_gradP(fcmodel[1 + i,:],x,x,scale,shift_Y).T
            if me > 0:
                gce=zeros(me,n)
                for i in arange(1,me).reshape(-1):
                    gce[i,:]=bcdfo_gradP(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
            M,pc,info=ecdfo_computeHessian(func,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m,nargout=3)
            lbounds=- inf * ones(size(x))
            ubounds=inf * ones(size(x))
            ilb=abs_(lb[indfree] - x) < 1e-05
            iub=abs_(ub[indfree] - x) < 1e-05
            lbounds[ilb]=lb[indfree[ilb]]
            ubounds[iub]=ub[indfree[iub]]
            lm,info=sqplab_lsmult(x,lbounds,ubounds,info,options,values,nargout=2)
            feas,comp,info=ecdfo_optimality(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
            if info.flag:
                return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            info.glagn = copy(norm(info.glag,inf))
            info.feasn = copy(norm(feas,inf))
            info.compl = copy(norm(comp,inf))
            if (info.niter > 0) and (options.verbose >= 3):
                fprintf(options.fout,char('\nOptimality:\n'))
                if constrained_pbl:
                    fprintf(options.fout,char('  |grad Lag|      = %12.5e\n'),info.glagn)
                    fprintf(options.fout,char('  feasibility     = %12.5e\n'),info.feasn)
                else:
                    fprintf(options.fout,char(' |grad f| = %12.5e\n'),info.glagn)
            errg=poised * Y_radius / factor_CV
            if options.verbose >= 3:
                disp(cat(char('error on gradient after set improvement = '),num2str(errg)))
            if ((info.glagn / factor_CV <= options.tol(1)) and (info.feasn / factor_CV <= options.tol(2)) and (info.compl / factor_CV <= options.tol(3)) and errg <= epsilon and cur_degree >= rep_degree and strcmp(level,char('toplevel'))):
                info.niter = copy(info.niter + 1)
                itype=char('conv')
                ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
                msg=matlabarray(cat(char(' Convergence in '),int2str(neval),char(' evaluations of the objective function.')))
                return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            if options.verbose >= 3:
                disp(char('not converged after improvement of interpolation set'))
            delta=copy(radius)
        if radius_has_been_rejected == false:
            f0=info.f
            ce0=info.ce
            ce0n=norm(ce0)
            merit0=f0 + sigma * ce0n
            prec_r=options.tol(2) / 10
            prec_t=options.tol(1) / 10
            if options.verbose >= 5:
                fprintf(options.fout,char('\nStep computation: merit = %12.5e\n'),merit0)
            if options.verbose == 4:
                fprintf(options.fout,char('   radius     |r|      |t|      |s|     sigma     rho\n'))
        info.niter = copy(info.niter + 1)
        ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
        if options.verbose >= 5:
            fprintf(options.fout,char('  Trust radius = %8.2e\n'),delta)
        old_delta=copy(delta)
        xnew,deltaTR,rpred,active_r,active_t,lm_computed,lm,info=ecdfo_solve_TR_bc(func,x,lb[indfree],ub[indfree],delta,mi,me,M,prec_r,prec_t,info,options,values,radius_has_been_rejected,lm,ceY,ciY,gx,nargout=8)
        if info.flag == values.fail_strange:
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        s=xnew - xk
        x=copy(xk)
        norms=norm(s)
        if options.verbose >= 3:
            fprintf(options.fout,char('  Full step:\n    |s| = %8.2e\n'),norms)
        qcost=info.g.T * s + 0.5 * (s.T * M * s)
        if rpred == 0:
            sigmab=0
        else:
            sigmab=qcost / ((1 - rho_factor) * rpred)
        if sigma < sigmab:
            sigma=max(sigmab,1.5 * sigma)
            merit0=f0 + sigma * ce0n
        if options.verbose >= 4:
            fprintf(options.fout,char('  Penalty parameter = %8.2e (threshold %8.2e)\n'),sigma,sigmab)
        if (interpol_TR == 1):
            gTs=gx.T * s
        xplus=x + s
        m=m + 1
        X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf(func,xplus,m,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,fxmax,neval,xstatus,0,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=10)
        if (info.flag):
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        else:
            fxplus=fX[m]
        if outdic:
            if outdic == 1:
                if options.verbose >= 5:
                    fprintf(options.fout,char('  Step rejected (out of an implicit domain)\n'))
            else:
                if outdic == 2:
                    if options.verbose:
                        fprintf(options.fout,char('\n### ecdfo_main: the simulator wants to stop\n\n'))
                    info.flag = copy(values.stop_on_simul)
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                else:
                    if options.verbose:
                        fprintf(options.fout,char('\n### ecdfo_main: error in the simulator (outdic = %0i)\n\n'),outdic)
                    info.flag = copy(values.fail_on_simul)
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            itype=char('xfail')
            radius_has_been_rejected=copy(true)
            if options.verbose >= 5:
                fprintf(options.fout,char('  rho = %8.2e \n'),rho)
            info.ce = copy(ce0)
            delta=tau1 * delta
            if options.verbose == 3 or options.verbose >= 5:
                fprintf(options.fout,char('  Step rejected due to failure in function evaluation\n'))
        else:
            merit=info.f + sigma * norm(info.ce)
            if options.verbose >= 3:
                fprintf(options.fout,char('  Merit function: %15.8e -> %15.8e\n'),merit0,merit)
            ared=merit0 - merit
            pred=- qcost + sigma * rpred
            if pred < 0:
                if options.verbose:
                    fprintf(options.fout,char('\n### ecdfo_main: pred = %9.2e should be positive\n\n'),pred)
                info.flag = copy(values.fail_strange)
                return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            else:
                if pred == 0:
                    pred=- 1.0
                    disp(char('### ecdfo_main : Warning : predicted reduction is 0 ###'))
            rho=ared / pred
            if pred == - 1.0:
                rho=- 1.0
            if (rho >= eta1):
                succ=1
            else:
                succ=0
            if options.verbose == 4:
                fprintf(options.fout,char('  %8.2e  %7.1e  %7.1e  %7.1e  %7.1e  %9.2e\n'),delta,norm_r,norm(t),norms,sigma,rho)
            i_xold=copy(i_xbest)
            pos=0
            if (rho >= eta1):
                if options.verbose >= 5:
                    fprintf(options.fout,char('  Step accepted (rho = %9.2e; ared = %9.2e, pred = %9.2e)\n'),rho,ared,pred)
                if (merit >= merit0):
                    info.flag = copy(values.fail_on_non_decrease)
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                if (cur_degree < pquad or (whichmodel == 3 and cur_degree < pquad + pquad)):
                    cur_degree,QZ,RZ,Y,xbase,scale=bcdfo_augment_Y(xplus,Y[:,1:cur_degree],whichmodel,shift_Y,delta,normgx,kappa_ill,nargout=6)
                    pos=copy(cur_degree)
                else:
                    QZ,RZ,Y,pos,x,scale=bcdfo_include_in_Y(xplus,QZ,RZ,Y,arange(1,cur_degree),Lambda_XN,criterion_S,x,whichmodel,succ,scale,shift_Y,delta,normgx,kappa_ill,nargout=6)
                    if (pos > 0):
                        xstatus[ind_Y[pos]]=c.unused
                if (pos > 0):
                    itype=char('succ')
                    if (options.verbose >= 3):
                        disp(cat(char(' replacing/including interpolation point '),int2str(pos),char(' (successful)')))
                    xstatus[m]=c.inY
                    ind_Y[pos]=m
                    fY[pos]=fxplus
                    if mi > 0:
                        ciY[:,pos]=info.ci.T
                    if me > 0:
                        ceY[:,pos]=info.ce.T
                    QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=ecdfo_swap_in_Y(1,pos,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=9)
                    fx=copy(fxplus)
                    i_xbest=copy(m)
                    if (not shift_Y):
                        x=Y[:,1]
                    poised_model=0
                    fcmodel=bcdfo_computeP(QZ,RZ,Y,cat([fY],[ciY],[ceY]),whichmodel,fcmodel[1,:],ind_Y,i_xold,m,gx,scale,shift_Y)
                    gx=bcdfo_gradP(fcmodel[1,:],x,x,scale,shift_Y)
                    normgx=bcdfo_projgrad(n,x,gx,lb[indfree],ub[indfree])
                    if mi > 0:
                        gci=zeros(mi,n)
                        for i in arange(1,mi).reshape(-1):
                            gci[i,:]=bcdfo_gradP(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                    if me > 0:
                        gce=zeros(me,n)
                        for i in arange(1,me).reshape(-1):
                            gce[i,:]=bcdfo_gradP(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                    if rho >= eta2:
                        if (active_r or active_t):
                            delta=delta * tau3
                        else:
                            delta=min(max(tau3 * norms,delta),Deltamax)
                    else:
                        if rho >= eta1:
                            if (active_r or active_t):
                                delta=delta * tau2
                            else:
                                delta=min(max(tau2 * norms,delta),Deltamax)
                    radius_has_been_rejected=copy(false)
                    if lm_computed == 0:
                        lbounds=- inf * ones(size(x))
                        ubounds=inf * ones(size(x))
                        ilb=abs_(lb[indfree] - x) < 1e-05
                        iub=abs_(ub[indfree] - x) < 1e-05
                        lbounds[ilb]=lb[indfree[ilb]]
                        ubounds[iub]=ub[indfree[iub]]
                        lm,info=sqplab_lsmult(x,lbounds,ubounds,info,options,values,nargout=2)
                    M,pc,info=ecdfo_computeHessian(func,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m,nargout=3)
            if pred == - 1.0:
                pos=1
                rho=1
            if (rho < eta1) or (pos == 0):
                itype=char('repD,repF,repC,redD')
                itype=char('unsuc')
                radius_has_been_rejected=copy(true)
                if options.verbose == 3 or options.verbose >= 5:
                    fprintf(options.fout,char('  Step rejected (rho = %9.2e; ared = %9.2e, pred = %9.2e)\n'),rho,ared,pred)
                if (((cur_degree < pquad) or (whichmodel == 3 and cur_degree < pquad + pquad)) and (rho < eta1)):
                    cur_degree,QZ,RZ,Y,xbase,scale=bcdfo_augment_Y(xplus,Y[:,1:cur_degree],whichmodel,shift_Y,delta,normgx,kappa_ill,nargout=6)
                    if (options.verbose >= 3):
                        disp(cat(char(' including interpolation point '),int2str(cur_degree),char(' (augm)')))
                    xstatus[m]=c.inY
                    ind_Y[cur_degree]=m
                    fY[cur_degree]=fxplus
                    if mi > 0:
                        ciY[:,cur_degree]=info.ci.T
                    if me > 0:
                        ceY[:,cur_degree]=info.ce.T
                    poised_model=0
                    fcmodel=bcdfo_computeP(QZ,RZ,Y,cat([fY],[ciY],[ceY]),whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
                    gx=bcdfo_gradP(fcmodel[1,:],x,x,scale,shift_Y)
                    normgx=bcdfo_projgrad(n,x,gx,lb[indfree],ub[indfree])
                    if mi > 0:
                        gci=zeros(mi,n)
                        for i in arange(1,mi).reshape(-1):
                            gci[i,:]=bcdfo_gradP(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                    if me > 0:
                        gce=zeros(me,n)
                        for i in arange(1,me).reshape(-1):
                            gce[i,:]=bcdfo_gradP(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                    itype=char('augm')
                    pos=copy(m)
                    if (shrink_Delta == 1 and delta > epsilon):
                        delta=gamma2 * delta
                if (cur_degree >= pquad or pos == 0):
                    if ((pos == 0) and (poised_model == 0 or delta <= eps_current)):
                        d=zeros(1,cur_degree)
                        if (rho >= eta1):
                            for j in arange(1,cur_degree).reshape(-1):
                                if (lSolver == 1):
                                    d[j]=norm(Y[:,j] - xplus)
                                else:
                                    d[j]=norm(Y[:,j] - xplus,inf)
                        else:
                            for j in arange(2,cur_degree).reshape(-1):
                                if (lSolver == 1):
                                    d[j]=norm(Y[:,j] - x)
                                else:
                                    d[j]=norm(Y[:,j] - x,inf)
                        FPlength=factor_FPU * (1 + eps_TR) * delta
                        if (rho >= eta1):
                            criterion_FPn=char('weighted')
                        else:
                            criterion_FPn=copy(criterion_FP)
                        QZ,RZ,Y,pos,x,scale=bcdfo_include_in_Y(xplus,QZ,RZ,Y,find(d > FPlength),Lambda_FP,criterion_FPn,x,whichmodel,succ,scale,shift_Y,delta,normgx,kappa_ill,nargout=6)
                        if (pos > 0):
                            itype=char('repF')
                            if (options.verbose >= 3):
                                disp(cat(char(' replacing interpolation point '),int2str(pos),char(' (far)')))
                            xstatus[ind_Y[pos]]=c.unused
                            xstatus[m]=c.inY
                            ind_Y[pos]=m
                            fY[pos]=fxplus
                            if mi > 0:
                                ciY[:,pos]=info.ci.T
                            if me > 0:
                                ceY[:,pos]=info.ce.T
                            if (rho >= eta1):
                                QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=bcdfo_swap_in_Y(1,pos,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=9)
                                fx=copy(fxplus)
                                info.f = copy(fx)
                                if mi > 0:
                                    info.ci = copy(ciY[:,1])
                                if me > 0:
                                    info.ce = copy(ceY[:,1])
                                i_xbest=copy(m)
                                if (not shift_Y):
                                    x=Y[:,1]
                                poised_model=0
                                if (options.verbose >= 3):
                                    disp(cat(char(' swapped point to position 1')))
                                itype=char('repFs')
                                delta=min(max(gamma3 * norms,delta),Deltamax)
                            else:
                                if (shrink_Delta == 1 and delta > epsilon):
                                    delta=gamma2 * delta
                            fcmodel=bcdfo_computeP(QZ,RZ,Y,cat([fY],[ciY],[ceY]),whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
                            gx=bcdfo_gradP(fcmodel[1,:],x,x,scale,shift_Y)
                            normgx=bcdfo_projgrad(n,x,gx,lb[indfree],ub[indfree])
                            if mi > 0:
                                gci=zeros(mi,n)
                                for i in arange(1,mi).reshape(-1):
                                    gci[i,:]=bcdfo_gradP(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                            if me > 0:
                                gce=zeros(me,n)
                                for i in arange(1,me).reshape(-1):
                                    gce[i,:]=bcdfo_gradP(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                        if (pos == 0):
                            if (rho >= eta1):
                                criterion_CPn=char('standard')
                            else:
                                criterion_CPn=copy(criterion_CP)
                            if (rho >= eta1):
                                Lambda_CPn=1e-15
                            else:
                                Lambda_CPn=copy(Lambda_CP)
                                d[1]=2 * FPlength
                            QZ,RZ,Y,pos,x,scale=bcdfo_include_in_Y(xplus,QZ,RZ,Y,find(d <= FPlength),Lambda_CPn,criterion_CPn,x,whichmodel,succ,scale,shift_Y,delta,normgx,kappa_ill,nargout=6)
                            if (pos > 0):
                                itype=char('repC')
                                if (pos == 1):
                                    i_xold=ind_Y[2]
                                if (options.verbose >= 3):
                                    disp(cat(char(' replacing interpolation point '),int2str(pos),char(' (close)')))
                                xstatus[ind_Y[pos]]=c.unused
                                xstatus[m]=c.inY
                                ind_Y[pos]=m
                                fY[pos]=fxplus
                                if mi > 0:
                                    ciY[:,pos]=info.ci.T
                                if me > 0:
                                    ceY[:,pos]=info.ce.T
                                if (rho >= eta1):
                                    QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=bcdfo_swap_in_Y(1,pos,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=9)
                                    fx=copy(fxplus)
                                    info.f = copy(fx)
                                    if mi > 0:
                                        info.ci = copy(ciY[:,1])
                                    if me > 0:
                                        info.ce = copy(ceY[:,1])
                                    i_xbest=copy(m)
                                    if (not shift_Y):
                                        x=Y[:,1]
                                    poised_model=0
                                    if (options.verbose >= 3):
                                        disp(cat(char(' swapped point to position 1')))
                                    itype=char('repCs')
                                    delta=min(max(gamma3 * norms,delta),Deltamax)
                                else:
                                    if (shrink_Delta == 1 and delta > epsilon):
                                        delta=gamma2 * delta
                                fcmodel=bcdfo_computeP(QZ,RZ,Y,cat([fY],[ciY],[ceY]),whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
                                gx=bcdfo_gradP(fcmodel[1,:],x,x,scale,shift_Y)
                                normgx=bcdfo_projgrad(n,x,gx,lb[indfree],ub[indfree])
                                if mi > 0:
                                    gci=zeros(mi,n)
                                    for i in arange(1,mi).reshape(-1):
                                        gci[i,:]=bcdfo_gradP(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                                if me > 0:
                                    gce=zeros(me,n)
                                    for i in arange(1,me).reshape(-1):
                                        gce[i,:]=bcdfo_gradP(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                    if (pos == 0):
                        if (options.verbose >= 3):
                            disp(char(' decreasing the TR radius'))
                        xstatus[m]=c.unused
                        if (interpol_TR == 1):
                            curvature=- pred - gTs
                            gam_inter=(eta2 - 1) * gTs / (fxplus - fx - gTs - eta2 * curvature)
                            delta=max(gamma1,min(gam_inter,gamma2)) * min(delta,norms)
                        else:
                            delta=gamma2 * norms
                        itype=char('redD')
                        if (delta < stallfact * norm(x) or delta < epsilon * 1e-05):
                            if (options.verbose >= 2 and strcmp(level,char('toplevel'))):
                                ecdfo_iter_printout(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
                                if (show_errg):
                                    disp(cat(char('************************************* Trust-region'),char(' radius small *********************************')))
                                else:
                                    disp(cat(char('******************************** Trust-region'),char(' radius small ****************************')))
                            msg=matlabarray(cat(char('Algorithm stopped after '),int2str(neval),char(' evaluations of the objective function because Delta small.')))
                            info.flag = copy(values.stop_on_small_trust_region)
                            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                info.ce = copy(ce0)
                info.f = copy(f0)
                lbounds=- inf * ones(size(x))
                ubounds=inf * ones(size(x))
                ilb=abs_(lb[indfree] - x) < 1e-05
                iub=abs_(ub[indfree] - x) < 1e-05
                lbounds[ilb]=lb[indfree[ilb]]
                ubounds[iub]=ub[indfree[iub]]
                lm,info=sqplab_lsmult(x,lbounds,ubounds,info,options,values,nargout=2)
                M,pc,info=ecdfo_computeHessian(func,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m,nargout=3)

    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
def ecdfo_optimality(x=None,lm=None,lb=None,ub=None,info=None,options=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 6-[x,lm,lb,ub,info,options].count(None)+len(args)

    global threshold
    n=length(info.g)
    mi=length(info.ci)
    me=length(info.ce)
    info.glag = copy(info.g)
    gradlag=info.g
    bounds=(abs_(lb - x) < 1e-05) + (abs_(ub - x) < 1e-05)
    if options.verbose >= 4:
        fprintf(char('\n     lb             x            ub             g            lm\n'))
        for i in arange(1,n).reshape(-1):
            fprintf(char('%12.5e  %12.5e  %12.5e  %12.5e  %12.5e\n'),lb[i],x[i],ub[i],info.glag(i),lm[i])
    I=find(bounds[1:n])
    info.glag[I]=info.glag(I) + lm[I]
    boundsmult=lm[I]
    gradlag=info.glag
    if mi > 0:
        I=find(bounds[n + 1:n + mi])
        info.glag = copy(info.glag + info.ai(I,arange()).T * lm[n + I])
    if me > 0:
        derivequcons=info.ae
        equmult=lm[n + mi + 1:n + mi + me]
        info.glag = copy(info.glag + info.ae.T * lm[n + mi + 1:n + mi + me])
        gradlag=info.glag
    feas=matlabarray(cat([max(0,max(cat([x],[info.ci]) - ub,lb - cat([x],[info.ci])))],[info.ce]))
    v=matlabarray(cat([x],[info.ci]))
    compl=zeros(n + mi,1)
    I=find((lb > - options.inf) and (abs_(lb - v) > options.dxmin))
    if not isempty(I):
        compl[I]=max(compl[I],max(0,- lm[I]))
    I=find((ub < options.inf) and (abs_(ub - v) > options.dxmin))
    if not isempty(I):
        compl[I]=max(compl[I],max(0,lm[I]))
    return feas,compl,info
def ecdfo_prelim(func=None,x0=None,lm0=None,Delta0=None,lb=None,ub=None,scaleX=None,scalefacX=None,cur_degree=None,rep_degree=None,plin=None,pdiag=None,pquad=None,c=None,initial_Y=None,kappa_ill=None,whichmodel=None,factor_FPR=None,Lambda_FP=None,Lambda_CP=None,eps_L=None,lSolver=None,hardcons=None,stratLam=None,xstatus=None,sstatus=None,dstatus=None,options=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 28-[func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options].count(None)+len(args)

    n=0
    nb=0
    mi=0
    me=0
    lm=matlabarray([])
    info.g = copy([])
    info.ai = copy([])
    info.ae = copy([])
    info.hl = copy([])
    info.niter = copy(0)
    shift_Y=1
    x=copy(NaN)
    fx=copy(NaN)
    gx=copy(NaN)
    checkoptions=1
    if isempty(options):
        checkoptions=0
    info,options,values=sqplab_options(info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.nsimul[1:values.nsimultype]=0
    n=size(x0,1)
    if size(x0,2) != 1:
        if options.verbose:
            fprintf(options.fout,char('### ecdfo: the initial x must be an n-vector\n\n'))
        info.flag = copy(values.fail_on_argument)
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if n < 1:
        if options.verbose:
            fprintf(options.fout,char('### ecdfo: the initial x must be an n-vector with n > 0\n\n'))
        info.flag = copy(values.fail_on_argument)
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if isempty(lb):
        lb=- options.inf * ones(n + mi,1)
    if isempty(ub):
        ub=options.inf * ones(n + mi,1)
    nb_lo=sum_(lb[1:n] > - options.inf)
    nb_up=sum_(ub[1:n] < options.inf)
    nb=sum_(min((lb[1:n] > - options.inf) + (ub[1:n] < options.inf),1))
    zero=0.0
    nfix=0
    indfix=matlabarray([])
    xfix=zeros(n,1)
    vstatus=zeros(n,1)
    temp=zeros(n,1)
    for j in arange(1,n).reshape(-1):
        if (lb[j] > ub[j]):
            disp(cat(char('Error: Lower bound of component '),int2str(j),char(' exceeds upper bound !!')))
            info.flag = copy(2)
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        temp[j]=ub[j] - lb[j]
        if (temp[j] < Delta0 + Delta0):
            if (temp[j] == zero):
                nfix=nfix + 1
                indfix=matlabarray(cat(indfix,j))
                vstatus[j]=c.alwaysfixed
                xfix[j]=lb[j]
                continue
            else:
                Delta0=0.5 * temp[j]
                disp(cat(char(' Diff. between lower and upper bound of component '),int2str(j),char(' is less than 2*Delta0 !! New Delta0='),num2str(Delta0)))
        templ=lb[j] - x0[j]
        tempu=ub[j] - x0[j]
        if (templ >= - Delta0):
            x0[j]=lb[j] + Delta0
        else:
            if (tempu <= Delta0):
                x0[j]=ub[j] - Delta0
    if (scaleX):
        for i in arange(1,n).reshape(-1):
            if (scalefacX[i] > 0):
                x0[i]=x0[i] * scalefacX[i]
                lb[i]=lb[i] * scalefacX[i]
                ub[i]=ub[i] * scalefacX[i]
            else:
                scalefacX[i]=1
    if (nfix > 0):
        nfree=n - nfix
        if (nfree <= 0):
            disp(char('No free variables. Please, enlarge search space!'))
            info.flag = copy(2)
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        indfree=setdiff(arange(1,n),indfix)
        x0=x0[indfree]
        if (cur_degree == plin):
            cur_degree=nfree + 1
        else:
            if (cur_degree == pdiag):
                cur_degree=2 * nfree + 1
            else:
                if (cur_degree == pquad):
                    cur_degree=((nfree + 1) * (nfree + 2)) / 2
        if (rep_degree == plin):
            rep_degree=nfree + 1
        else:
            if (rep_degree == pdiag):
                rep_degree=2 * nfree + 1
            else:
                if (rep_degree == pquad):
                    rep_degree=((nfree + 1) * (nfree + 2)) / 2
        plin=nfree + 1
        pdiag=2 * nfree + 1
        pquad=((nfree + 1) * (nfree + 2)) / 2
        n=copy(nfree)
    else:
        indfree=arange(1,n)
    x=copy(x0)
    getfY=1
    while (getfY):

        if (options.verbose > 2):
            disp(cat(char(' Degree of the initial  model = '),int2str(cur_degree)))
        if (strcmp(initial_Y,char('random'))):
            Y[:,1]=x0
            ill_init=1
            while (ill_init):

                Y[:,2:cur_degree]=- ones(n,cur_degree - 1) + 2 * rand(n,cur_degree - 1)
                for j in arange(2,cur_degree).reshape(-1):
                    Y[:,j]=Y[:,1] + Y[:,j] * (Delta0 / norm(Y[:,j]))
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                if (cond(RZ) < kappa_ill):
                    ill_init=0

            QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y(QZ,RZ,Y,Delta0,factor_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,1,kappa_ill,nargout=8)
            poisedness_known=1
        else:
            if (strcmp(initial_Y,char('simplx'))):
                I=eye(n)
                Y[:,1]=x0
                for j in arange(1,n).reshape(-1):
                    step1=- Delta0
                    Y[:,j + 1]=x0 + step1 * I[:,j]
                    if (cur_degree >= pdiag):
                        step2=copy(Delta0)
                        Y[:,j + 1 + n]=x0 + step2 * I[:,j]
                if (cur_degree == pquad):
                    k=2 * n + 2
                    for j in arange(1,n).reshape(-1):
                        for jj in arange(j + 1,n).reshape(-1):
                            Y[:,k]=0.5 * (Y[:,j + 1] + Y[:,jj + 1])
                            k=k + 1
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                poised,Y_radius=bcdfo_poisedness_Y(QZ,RZ,Y,eps_L,x,1,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                poisedness_known=1
        poised_model=1
        X=matlabarray([])
        fX=matlabarray([])
        ciX=matlabarray([])
        ceX=matlabarray([])
        ind_Y=matlabarray([])
        for i in arange(1,cur_degree).reshape(-1):
            X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info=ecdfo_augmX_evalf(func,Y[:,i],i,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,1e+25,info.nsimul(2),xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=9)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if (abs_(fX[i]) > 1e+25):
                break
            if (i == cur_degree):
                getfY=0
            ind_Y=matlabarray(cat(ind_Y,i))
        fY=copy(fX)
        ciY=copy(ciX)
        ceY=copy(ceX)
        xstatus=xstatus.T
        dstatus=dstatus.T
        if (getfY):
            Delta0=gamma1 * Delta0
            if (Delta0 < stallfact * norm(x0)):
                disp(char('Error: cannot find enough finite objective function values'),char('in the neighbourhood of the starting point! Terminating.'))
                if (nfix > 0):
                    I=eye(n + nfix)
                    x=I[:,indfix] * xl(indfix) + I[:,indfree] * x
                    gx=I[:,indfix] * zeros(nfix,1) + I[:,indfree] * gx
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values

    fx0=fY[1]
    info.f = copy(fx0)
    m=copy(cur_degree)
    i_xbest=1
    initmodel=zeros(1,pquad)
    rhsY=matlabarray(cat([fY],[ciY],[ceY]))
    fcmodel=bcdfo_computeP(QZ,RZ,Y,rhsY,whichmodel,initmodel,ind_Y,0,0,gx,scale,shift_Y,Delta0)
    gx=bcdfo_gradP(fcmodel[1,:],x,x,scale,shift_Y)
    normgx=bcdfo_projgrad(n,x,gx,lb[indfree],ub[indfree])
    if any(size(gx) != cat(n,1)):
        if options.verbose:
            fprintf(options.fout,char('### ecdfo: the computed gradient g has a wrong size, (%0i,%0i) instead of (%0i,1)\n\n'),size(gx),n)
        info.flag = copy(values.fail_on_simul)
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.g = copy(gx)
    mi=size(ciY,1)
    if mi > 0:
        info.ci = copy(ciY[:,1])
        gci=zeros(mi,n)
        for i in arange(1,mi).reshape(-1):
            gci[i,:]=bcdfo_gradP(fcmodel[1 + i,:],x,x,scale,shift_Y).T
        info.ai = copy(gci)
    else:
        info.ci = copy([])
        info.ai = copy([])
    me=size(ceY,1)
    if me > 0:
        info.ce = copy(ceY[:,1])
        gce=zeros(me,n)
        for i in arange(1,me).reshape(-1):
            gce[i,:]=bcdfo_gradP(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
        info.ae = copy(gce)
    else:
        info.ce = copy([])
        info.ae = copy([])
    fprintf(char('\n'))
    fprintf(char('**************************************************************************************\n'))
    fprintf(char('*                                                                                    *\n'))
    fprintf(char('*            EC-DFO: equality-constrained minimization without derivatives           *\n'))
    fprintf(char('*                                                                                    *\n'))
    fprintf(char('*                            (c)  A. Troeltzsch, 2013                                *\n'))
    fprintf(char('*                                                                                    *\n'))
    fprintf(char('**************************************************************************************\n'))
    fprintf(char('\n'))
    values.dline = copy(char('-------------------------------------------'))
    values.dline = copy(strcat(values.dline,values.dline))
    values.eline = copy(char('==========================================='))
    values.eline = copy(strcat(values.eline,values.eline))
    values.sline = copy(char('*******************************************'))
    values.sline = copy(strcat(values.sline,values.sline))
    if options.verbose < 4:
        fprintf(options.fout,char('iter neval        fval            merit      '))
        if (nb + mi + me > 0):
            fprintf(options.fout,char(' |grad Lag|   feasibility'))
        else:
            fprintf(options.fout,char('gradient'))
        fprintf(options.fout,char('     delta    stepsize'))
        if options.algo_method == values.quasi_newton:
            fprintf(options.fout,char('  BFGS\n'))
        else:
            fprintf(options.fout,char('  \n'))
        fprintf(options.fout,char('  \n'))
    if options.verbose >= 4:
        fprintf(options.fout,char('%s'),values.sline)
        fprintf(options.fout,char('ecdfo optimization solver (Version 0.4.4, February 2009, entry point)\n\n'))
        if isa(func,char('function_handle')):
            func_name=func2str(func)
        else:
            func_name=copy(func)
        fprintf(options.fout,char('  name: "%s"\n'),func_name)
        fprintf(options.fout,char('  dimensions:\n'))
        fprintf(options.fout,char('  . variables (n):               %4i\n'),n)
        if nb > 0:
            fprintf(options.fout,char('  . bounds on variables (nb):    %4i (%0i lower, %0i double, %0i upper)\n'),nb,nb_lo,nb_up)
        if mi > 0:
            fprintf(options.fout,char('  . inequality constraints (mi): %4i\n'),mi)
        if me > 0:
            fprintf(options.fout,char('  . equality constraints (me):   %4i\n'),me)
        fprintf(options.fout,char('  required tolerances for optimality:\n'))
        if nb + mi + me > 0:
            fprintf(options.fout,char('  . gradient of the Lagrangian      %8.2e\n'),options.tol(1))
            fprintf(options.fout,char('  . feasibility                     %8.2e\n'),options.tol(2))
            if nb + mi > 0:
                fprintf(options.fout,char('  . complementarity                 %8.2e\n'),options.tol(3))
        else:
            fprintf(options.fout,char('  . gradient of the cost function   %8.2e\n'),options.tol(1))
        fprintf(options.fout,char('  counters:\n'))
        fprintf(options.fout,char('  . max iterations                  %4i\n'),options.miter)
        fprintf(options.fout,char('  . max function evaluations        %4i\n'),options.msimul)
        fprintf(options.fout,char('  algorithm:\n'))
        if values.newton == options.algo_method:
            fprintf(options.fout,char('  . Newton method\n'))
        else:
            if values.quasi_newton == options.algo_method:
                fprintf(options.fout,char('  . quasi-Newton method\n'))
            else:
                if values.cheap_quasi_newton == options.algo_method:
                    fprintf(options.fout,char('  . cheap quasi-Newton method\n'))
        if values.unit_stepsize == options.algo_globalization:
            fprintf(options.fout,char('  . unit step-size\n'))
        else:
            if values.linesearch == options.algo_globalization:
                if options.algo_method == values.newton:
                    fprintf(options.fout,char("  . globalization by Armijo's linesearch\n"))
                else:
                    if options.algo_method == values.quasi_newton:
                        if isfield(options,char('algo_descent')):
                            if options.algo_descent == values.powell:
                                fprintf(options.fout,char("  . globalization by Armijo's linesearch (descent ensured by Powell corrections)\n"))
                            else:
                                if options.algo_descent == values.wolfe:
                                    if nb + mi + me == 0:
                                        fprintf(options.fout,char("  . globalization by Wolfe's linesearch\n"))
                        else:
                            fprintf(options.fout,char("  . globalization by Armijo's linesearch\n"))
            else:
                if values.trust_regions == options.algo_globalization:
                    fprintf(options.fout,char('  . globalization by trust regions\n'))
        fprintf(options.fout,char('  various input/initial values:\n'))
        if (options.algo_method == values.quasi_newton) and (nb + mi + me == 0) and (options.df1 > 0) and (info.f > 0):
            fprintf(options.fout,char('  . expected initial decrease       %8.2e\n'),options.df1 * info.f)
        if nb + mi > 0:
            fprintf(options.fout,char('  . infinite bound threshold        %8.2e\n'),options.inf)
        fprintf(options.fout,char('  . |x|_2                           %8.2e\n'),norm(x))
    if (nb + mi + me > 0):
        if isempty(lm0):
            lm,info=sqplab_lsmult(x,[],[],info,options,values,nargout=2)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if options.verbose >= 4:
                fprintf(options.fout,char('  . |lm|_2                          %8.2e (default: least-squares value)\n'),norm(lm))
        else:
            lm=copy(lm0)
            if options.verbose >= 4:
                fprintf(options.fout,char('  . |lm|_2                          %8.2e\n'),norm(lm))
    feas,compl,info=ecdfo_optimality(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if options.verbose >= 4:
        fprintf(options.fout,char('  . |g|_inf                         %8.2e\n'),norm(info.g,inf))
        if nb + mi + me > 0:
            fprintf(options.fout,char('  . |glag|_inf                      %8.2e\n'),norm(info.glag,inf))
        if nb:
            fprintf(options.fout,char('  . |x^#|_inf                       %8.2e\n'),norm(feas[1:n],inf))
        if mi:
            fprintf(options.fout,char('  . |ci^#|_inf                      %8.2e\n'),norm(feas[n + 1:n + mi],inf))
        if me:
            fprintf(options.fout,char('  . |ce|_inf                        %8.2e\n'),norm(feas[n + mi + 1:n + mi + me],inf))
        if nb + mi > 0:
            fprintf(options.fout,char('  . |complementarity|_inf           %8.2e\n'),norm(compl,inf))
        fprintf(options.fout,char('  tunings:\n'))
        fprintf(options.fout,char('  . printing level                  %0i\n'),options.verbose)
    info,options=sqplab_checkoptions(nb,mi,me,0,info,options,values,nargout=2)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
def ecdfo_solve_TR_bc(simul=None,x=None,lb=None,ub=None,delta=None,mi=None,me=None,M=None,prec_r=None,prec_t=None,info=None,options=None,values=None,radius_has_been_rejected=None,lm=None,ceY=None,ciY=None,gx=None,*args,**kwargs):
    nargout = kwargs["nargout"] if kwargs else None
    varargin = cellarray(args)
    nargin = 18-[simul,x,lb,ub,delta,mi,me,M,prec_r,prec_t,info,options,values,radius_has_been_rejected,lm,ceY,ciY,gx].count(None)+len(args)

    global threshold
    lm_computed=0
    n=length(x)
    I=eye(n)
    xi=1.0
    xnew=copy(x)
    active_r=0
    active_t=0
    rpred=0
    norm_r=0
    x_fix=matlabarray([])
    glocal=copy(gx)
    delta_min=1e-08
    plevel_r=0
    if options.verbose >= 5:
        plevel_r=1
    plevel_t=0
    if options.verbose >= 5:
        plevel_t=1
    if me + mi == 0:
        lb_r=lb[1:n] - x
        ub_r=ub[1:n] - x
        stratLam=1
        s,lambda_,norms,value,gplus,nfact,neigd,msg=bcdfo_solve_TR_MS_bc(glocal,M,lb_r,ub_r,delta,1e-07,stratLam,nargout=8)
        xnew=x + s
        rpred=0
        active_r=0
        if norm(s) < delta:
            active_t=0
        else:
            active_t=1
        return xnew,delta,rpred,active_r,active_t,lm_computed,lm,info
    constraints=info.ce
    gconstraints=info.ae
    x_active=zeros(size(x))
    look_for_active_bounds=1
    if look_for_active_bounds == 1:
        gradlag=copy(glocal)
        bounds=(abs_(lb - x) < 1e-05) + (abs_(ub - x) < 1e-05)
        A=find(bounds[1:n])
        gradlag[A]=gradlag[A] + lm[A]
        if me > 0:
            gradlag=gradlag + info.ae.T * lm[n + mi + 1:n + mi + me]
        for i in arange(1,n).reshape(-1):
            if (x[i] - gradlag[i] <= lb[i]) and (abs_(x[i] - lb[i]) < 1e-05):
                x_active[i]=1
                if options.verbose >= 3:
                    disp(cat(char('lb '),num2str(i),char(' is initially active')))
                constraints=matlabarray(cat([constraints],[0]))
                gconstraints=matlabarray(cat([gconstraints],[I[i,:]]))
            if (x[i] - gradlag[i] >= ub[i]) and (abs_(x[i] - ub[i]) < 1e-05):
                x_active[i]=1
                if options.verbose >= 3:
                    disp(cat(char('ub '),num2str(i),char(' is initially active')))
                constraints=matlabarray(cat([constraints],[0]))
                gconstraints=matlabarray(cat([gconstraints],[I[i,:]]))
        if options.verbose >= 3 and sum_(x_active) > 0:
            xactive=x_active.T
    finished=0
    iter_active=0
    while finished == 0:

        iter_active=iter_active + 1
        if options.verbose >= 3:
            disp(cat(char('********* Loop over active set ********* iteration '),num2str(iter_active),char(' *********')))
        if options.verbose >= 3:
            fprintf(options.fout,char('  Restoration step:\n'))
        delta_r=xi * delta
        sol=gconstraints.T * constraints
        if iter_active == 1 and norm(sol) > 1e-14:
            g1=gconstraints.T * constraints
            H1=gconstraints.T * gconstraints
            check_condition=0
            if check_condition:
                cthreshold=1e+16
                H1,badcond=ecdfo_check_cond(H1,cthreshold,options,nargout=2)
            check_convex=1
            if check_convex:
                H1=ecdfo_check_convex(H1,options)
            lb_r=lb[1:n] - x
            ub_r=ub[1:n] - x
            stratLam=1
            r,lambda_,norms,value,gplus,nfact,neigd,msg=bcdfo_solve_TR_MS_bc(g1,H1,lb_r,ub_r,delta_r,prec_r,stratLam,nargout=8)
            info_r.prec = copy(sqrt(gplus.T * gplus))
            xr=x + r
            norm2_r=r.T * r
            norm_r=sqrt(norm2_r)
            if strcmp(msg[1:5],char('error')) or strcmp(msg[1:5],char('limit')):
                info_r.flag = copy(- 1)
            else:
                if strcmp(msg[1:8],char('boundary')) or (delta_r - norm_r < 1e-08):
                    info_r.flag = copy(1)
                else:
                    info_r.flag = copy(0)
            rpred_m=norm(constraints) - norm(constraints + gconstraints * r)
            rpred=rpred + rpred_m
            if rpred < 0:
                if options.verbose >= 3:
                    fprintf(options.fout,char('\n### ecdfo_solve_TR_bc: rpred = %9.2e should not be negative\n\n'),rpred)
            active_r=(info_r.flag == 1) or (info_r.flag == 2)
            if options.verbose >= 5:
                if - 1 == info_r.flag:
                    fprintf(options.fout,char('    max of %0i iterations reached\n'),20 * me)
                else:
                    if 0 == info_r.flag:
                        fprintf(options.fout,char('    precision is less than required tolerance %8.2e\n'),prec_r)
                    else:
                        if 1 == info_r.flag:
                            fprintf(options.fout,char('    TR boundary is reached\n'))
                        else:
                            if 2 == info_r.flag:
                                fprintf(options.fout,char('    negative curvature direction encountered\n'))
                fprintf(options.fout,char('    |r|   = %8.2e\n'),norm_r)
                fprintf(options.fout,char('    rpred = %8.2e\n'),rpred)
        else:
            if options.verbose >= 5:
                fprintf(options.fout,char('    unchanged\n'))
            r=zeros(size(x))
            active_r=copy(false)
            xr=copy(x)
            norm2_r=0.0
            norm_r=0.0
        if options.verbose == 3:
            disp(cat(char('r = ('),num2str(r.T),char(')')))
            disp(cat(char('delta_r = '),num2str(delta_r),char(', norm_r = '),num2str(norm_r)))
        if options.verbose >= 3:
            fprintf(options.fout,char('  Tangent step:\n'))
        delta_t=copy(delta)
        deg_freedom=n - length(constraints)
        if deg_freedom > 0:
            Z_=null(full(gconstraints))
            M_t=Z_.T * M * Z_
            g_t=Z_.T * (glocal + M * r)
            u,info_t=sqplab_tcg(M_t,- g_t,delta_t,20 * (n - me),prec_t,plevel_t,options.fout,nargout=2)
            t=Z_ * u
            active_t=(info_t.flag == 1) or (info_t.flag == 2)
            if options.verbose >= 5:
                if - 1 == info_t.flag:
                    fprintf(options.fout,char('    max of %0i iterations reached\n'),20 * (n - me))
                else:
                    if 0 == info_t.flag:
                        fprintf(options.fout,char('    precision is less than required tolerance %8.2e\n'),prec_t)
                    else:
                        if 1 == info_t.flag:
                            fprintf(options.fout,char('    TR boundary is reached\n'))
                        else:
                            if 2 == info_t.flag:
                                fprintf(options.fout,char('    negative curvature direction encountered\n'))
                fprintf(options.fout,char('    |t| = %8.2e\n'),norm(t))
        else:
            t=zeros(1,n).T
            active_t=0
        if options.verbose == 3:
            disp(cat(char('t = ('),num2str(t.T),char(')')))
            disp(cat(char('delta_t = '),num2str(delta_t),char(', norm_t = '),num2str(norm(t))))
            disp(cat(char('delta '),num2str(delta),char(', norm_s = '),num2str(norm(r + t))))
        xnew=x + r + t
        x_active=zeros(size(xnew))
        x_viol=zeros(size(xnew))
        for i in arange(1,n).reshape(-1):
            if (xnew[i] - lb[i] < - threshold):
                x_viol[i]=- i
                x_fix=matlabarray(cat(x_fix,i))
                if options.verbose >= 3:
                    disp(cat(char('lb '),int2str(i),char(' is violated')))
                constraints=matlabarray(cat([constraints],[0]))
                gconstraints=matlabarray(cat([gconstraints],[I[i,:]]))
                violated=1
                break
            else:
                if (abs_(xnew[i] - lb[i]) < 1e-07):
                    x_active[i]=- i
                    if options.verbose >= 3:
                        disp(cat(char('lb '),int2str(i),char(' is active')))
                else:
                    if (xnew[i] - ub[i] > threshold):
                        x_viol[i]=i
                        x_fix=matlabarray(cat(x_fix,i))
                        if options.verbose >= 3:
                            disp(cat(char('ub '),int2str(i),char(' is violated')))
                        constraints=matlabarray(cat([constraints],[0]))
                        gconstraints=matlabarray(cat([gconstraints],[I[i,:]]))
                        violated=1
                        break
                    else:
                        if (abs_(xnew[i] - ub[i]) < 1e-07):
                            x_active[i]=i
                            if options.verbose >= 3:
                                disp(cat(char('ub '),int2str(i),char(' is active')))
        if sum_(x_viol) == 0:
            violated=0
            if options.verbose >= 3:
                disp(char('no new bound violated'))
        else:
            if options.verbose >= 3:
                disp(x_fix)
        if norm(r + t) <= 1e-16:
            if options.verbose >= 3 and (iter_active >= 10 * n or delta < delta_min):
                disp(char('### ecdfo_solve_TR_bc: active-set iteration limit exceeded ###'))
                return xnew,delta,rpred,active_r,active_t,lm_computed,lm,info
            lbounds=- inf * ones(size(x))
            ubounds=inf * ones(size(x))
            ilb=abs_(lb - xnew) < 1e-05
            iub=abs_(ub - xnew) < 1e-05
            lbounds[ilb]=lb[ilb]
            ubounds[iub]=ub[iub]
            lm,info=sqplab_lsmult(xnew,lbounds,ubounds,info,options,values,nargout=2)
            min_lm,ind_min_lm=min(lm[x_fix],nargout=2)
            if options.verbose >= 3:
                disp(cat(char('smallest Lagrange multiplier (for the bounds) = '),num2str(min_lm)))
            if min_lm < 0:
                if options.verbose >= 3:
                    disp(char('Zero step but not converged - release one bound!!'))
                constraints=constraints[1:me]
                gconstraints=gconstraints[1:me,:]
                xa=find(x_active < 0).T
                if length(xa) == length(x_fix):
                    if sort(xa) == sort(x_fix):
                        for i in arange(1,length(x_fix)).reshape(-1):
                            if i != ind_min_lm:
                                constraints=matlabarray(cat([constraints],[0]))
                                gconstraints=matlabarray(cat([gconstraints],[I[x_fix[i],:]]))
                        x_fix[ind_min_lm]=[]
                        finished=1
                    else:
                        x_fix=matlabarray([])
                        for i in arange(1,length(find(x_active < 0))).reshape(-1):
                            constraints=matlabarray(cat([constraints],[0]))
                            gconstraints=matlabarray(cat([gconstraints],[I[xa[i],:]]))
                            x_fix=matlabarray(cat(x_fix,xa[i]))
                else:
                    x_fix=matlabarray([])
                    for i in arange(1,length(find(x_active < 0))).reshape(-1):
                        constraints=matlabarray(cat([constraints],[0]))
                        gconstraints=matlabarray(cat([gconstraints],[I[xa[i],:]]))
                        x_fix=matlabarray(cat(x_fix,xa[i]))
                if options.verbose >= 3:
                    x_fix
            else:
                if options.verbose >= 3:
                    disp(char('Zero step and converged - go back to TR-loop...'))
                finished=1
        else:
            if violated == 0:
                if options.verbose >= 3:
                    disp(char('non zero feasible step - go back to TR-loop...'))
                finished=1
            else:
                if options.verbose >= 3:
                    disp(char('non zero infeasible step - continue finding correct active set...'))
        if violated == 1:
            tstep=copy(t)
            if options.verbose >= 3:
                disp(char('shorten tangential step'))
            aT=matlabarray(cat([eye(n)],[- eye(n)]))
            aTx=aT * xr
            alpha=matlabarray(cat([ub[1:n]],[- lb[1:n]]))
            divisor=aT * tstep
            ratio=(alpha - aTx) / divisor
            minratio=min(ratio[divisor > 0])
            if (minratio < 0):
                minratio=0.0
            tstep=minratio.dot(tstep)
            x=xr + tstep
            step=r + tstep
            if options.verbose == 3:
                disp(cat(char('t = ('),num2str(tstep.T),char(')')))
                disp(cat(char('delta_t = '),num2str(delta_t),char(', norm_t = '),num2str(norm(tstep))))
                disp(cat(char('delta '),num2str(delta),char(', norm_s = '),num2str(norm(r + tstep))))
            glocal=glocal + M * step
            for i in arange(1,me).reshape(-1):
                gconstraints[i,:]=gconstraints[i,:] + (M * step).T
            delta=delta - norm(step)

    return xnew,delta,rpred,active_r,active_t,lm_computed,lm,info
