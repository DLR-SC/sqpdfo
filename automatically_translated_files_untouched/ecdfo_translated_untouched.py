# Autogenerated with SMOP version 
# main.py ecdfofiles/*

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def ecdfo_swap_in_Y_(i=None,j=None,QZ=None,RZ=None,Y=None,ind_Y=None,fY=None,ciY=None,ceY=None,xbase=None,whichmodel=None,scale=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 16-[i,j,QZ,RZ,Y,ind_Y,fY,ciY,ceY,xbase,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill].count(None)+len(args)

    if (i > j):
        ii=copy_(j)
        jj=copy_(i)
    else:
        if (i < j):
            ii=copy_(i)
            jj=copy_(j)
        else:
            return QZ,RZ,Y,ind_Y,fY,ciY,ceY,xbase,scale
    y=Y[:,ii]
    Y[:,ii]=Y[:,jj]
    Y[:,jj]=y
    ind=ind_Y[ii]
    ind_Y[ii]=ind_Y[jj]
    ind_Y[jj]=ind
    f=fY[ii]
    fY[ii]=fY[jj]
    fY[jj]=f
    if not isempty_(ciY):
        ci=ciY[:,ii]
        ciY[:,ii]=ciY[:,jj]
        ciY[:,jj]=ci
    if not isempty_(ceY):
        ce=ceY[:,ii]
        ceY[:,ii]=ceY[:,jj]
        ceY[:,jj]=ce
    QZ,RZ,xbase,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta,normgx,kappa_ill,nargout=4)
    return QZ,RZ,Y,ind_Y,fY,ciY,ceY,xbase,scale
clear(char('all'))
close(char('all'))
_format(char('long'))
global n,nb,mi,me,prob,threshold
prob=1
x,lx,ux,dxmin,li,ui,dcimin,infb,n,nb,mi,me,info=ecdfo_init_prob(prob,nargout=13)
lb[arange_(1,n)]=lx
ub[arange_(1,n)]=ux
if mi:
    lb[arange_(n + 1,n + mi)]=li
    ub[arange_(n + 1,n + mi)]=ui
threshold=1e-08
options.algo_method=char('quasi-Newton')
options.algo_globalization=char('trust regions')
options.hess_approx=char('model')
options.bfgs_restart=0
options.algo_descent=char('Powell')
if nb + mi + me == 0:
    options.algo_descent=char('Wolfe')
options.tol[1]=1e-05
options.tol[2]=1e-05
options.tol[3]=1e-05
options.dxmin=dxmin
options.miter=500
options.msimul=500
options.verbose=2
lm=[]
x,lm,info=ecdfo(evalfgh,x,lm,lb,ub,options,nargout=3)
x
def ecdfo_(func=None,x0=None,lm0=None,lb=None,ub=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[func,x0,lm0,lb,ub,options].count(None)+len(args)

    global prob,threshold
    c.free=0
    c.fixed=1
    c.alwaysfixed=2
    c.in=1
    c.out=0
    c.unused=0
    c.inY=1
    c.dummy=1
    c.nodummy=0
    x=copy_(NaN)
    fx=copy_(NaN)
    gx=copy_(NaN)
    nit=0
    nitold=0
    neval=0
    errg=copy_(Inf)
    X=matlabarray([])
    fX=matlabarray([])
    xstatus=matlabarray([])
    sstatus=matlabarray([])
    dstatus=matlabarray([])
    sspace_save=matlabarray([])
    xspace_save=matlabarray([])
    ndummyY=0
    info.flag=0
    rand_(char('seed'),pi / sqrt_(2))
    randn_(char('seed'),5)
    if (size_(x0,1) == 1 and size_(x0,2) > 1):
        x0=x0.T
    n=length_(x0)
    pquad=((n + 1) * (n + 2)) / 2
    pdiag=2 * n + 1
    plin=n + 1
    msg=char('Unexpected exit')
    poisedness_known=0
    eps_rho=1e-14
    stallfact=10 * eps
    factor_Dmax=100000.0
    factor_fmax=1e+20
    CNTsin=0
    Delta0=1
    cur_degree=copy_(plin)
    rep_degree=copy_(plin)
    epsilon=1e-05
    maxeval=200 * n
    maxit=copy_(maxeval)
    verbose=1
    show_errg=0
    initial_Y=char('simplx')
    eta1=0.0001
    eta2=0.9
    gamma1=0.01
    gamma2=0.5
    gamma3=2.0
    interpol_TR=1
    factor_CV=100
    Lambda_XN=1e-10
    Lambda_CP=1.2
    Lambda_FP=1e-10
    factor_FPU=1
    factor_FPR=10
    criterion_S=char('distance')
    criterion_FP=char('distance')
    criterion_CP=char('standard')
    mu0=0
    mu=0
    theta=1
    eps_TR=0.0001
    eps_L=0.001
    shift_Y=1
    lSolver=1
    stratLam=1
    kappa_ill=1e+15
    kappa_th=2000
    eps_bnd=epsilon / 10
    whichmodel=0
    hardcons=0
    noisy=0
    scaleX=0
    scalefacX=ones_(1,n)
    shrink_Delta=1
    Deltamax=factor_Dmax * Delta0
    if nargin < 2:
        fprintf_(char('\\n### EC-DFO: the first 2 arguments are required\\n\\n'))
        x=matlabarray([])
        lm=matlabarray([])
        info.flag=1
        return x,lm,info
    if nargin < 3:
        lm0=matlabarray([])
    else:
        lm0=lm0[:]
    if nargin < 4:
        lb=matlabarray([])
    else:
        lb=lb[:]
    if nargin < 5:
        ub=matlabarray([])
    else:
        ub=ub[:]
    if nargin < 6:
        options.fout=1
        options.verbose=1
    if prob == 100:
        Delta0=0.01
        epsilon=0.001
        if exist_(char('fvalues_ecdfo_karmanogive.dat'),char('file')) == 2:
            delete_(char('fvalues_ecdfo_karmanogive.dat'))
    x0
    n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values=ecdfo_prelim_(func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options,nargout=47)
    if info.flag:
        return x,lm,info
    x0=copy_(x)
    eps_current=max_(mu0 * normgx,epsilon)
    fxmax=min_(1e+25,factor_fmax * abs_(fx))
    M=eye_(n)
    if (verbose):
        fid=fopen_(char('convhist.m'),char('w'))
        fprintf_(fid,char('function A=history \\n A=[ \\n'))
        fprintf_(fid,char('%6d  %+.14e %.2e \\n'),neval,fx,normgx)
        fclose_(fid)
    nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,Delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info=ecdfo_main_(func,n,nb,mi,me,lm,nitold,nit,i_xbest,lb,ub,m,X,fX,ciX,ceX,ind_Y,QZ,RZ,Delta,cur_degree,neval,maxeval,maxit,fcmodel,gx,normgx,show_errg,pquad,pdiag,plin,stallfact,eps_rho,Deltamax,rep_degree,epsilon,verbose,eta1,eta2,gamma1,gamma2,gamma3,interpol_TR,factor_CV,Lambda_XN,Lambda_CP,factor_FPU,factor_FPR,Lambda_FP,criterion_S,criterion_FP,criterion_CP,mu,theta,eps_TR,eps_L,lSolver,stratLam,eps_current,vstatus,xstatus,sstatus.T,dstatus,ndummyY,sspace_save,xspace_save,xfix,fxmax,poised_model,M,kappa_ill,kappa_th,eps_bnd,poised,Y_radius,c,char('toplevel'),whichmodel,hardcons,noisy,scaleX,scalefacX,CNTsin,shrink_Delta,scale,shift_Y,info,options,values,nargout=29)
    if (verbose):
        fid=fopen_(char('convhist.m'),char('a'))
        fprintf_(fid,char('];'))
        fclose_(fid)
    if (nfix > 0):
        I=eye_(n + nfix)
        x=I[:,indfix] * xfix[indfix] + I[:,indfree] * x
        gx=I[:,indfix] * zeros_(nfix,1) + I[:,indfree] * gx
        Ilm=eye_(n + nfix + me + mi)
        indfree_lm=setdiff_(arange_(1,n + nfix + me + mi),indfix)
        lm=Ilm[:,indfix] * zeros_(nfix,1) + Ilm[:,indfree_lm] * lm
        n=n + nfix
    if (scaleX):
        x=x / scalefacX
    info_best=copy_(info)
    info_best.f=fx
    x=X[:,i_xbest]
    ecdfo_finish_(nb,mi,me,info_best,options,values)
    if options.verbose > 2:
        if nb:
            fprintf_(options.fout,char('VARIABLES:\\n'))
            fprintf_(options.fout,char('i     lower bound          x            upper bound       multiplier\\n'))
            for i in arange_(1,min_(n,40)).reshape(-1):
                fprintf_(options.fout,char('%0i %+16.6e %+16.6e %+16.6e %+16.6e\\n'),i,lb[i],x[i],ub[i],lm[i])
            if (n > 40):
                fprintf_(options.fout,char('.....\\n'))
            else:
                fprintf_(options.fout,char('\\n'))
        else:
            fprintf_(options.fout,char('VARIABLES:\\n'))
            fprintf_(options.fout,char('%16.6e\\n'),x[1:min_(n,40)])
            if (n > 40):
                fprintf_(options.fout,char('.....\\n'))
            else:
                fprintf_(options.fout,char('\\n'))
        if mi:
            fprintf_(options.fout,char('INEQUALITY CONSTRAINTS:\\n'))
            fprintf_(options.fout,char('i     lower bound          ci           upper bound       multiplier\\n'))
            for i in arange_(1,min_(mi,40)).reshape(-1):
                fprintf_(options.fout,char('%0i %+16.6e %+16.6e %+16.6e %+16.6e\\n'),i,lb[n + i],ciX[i,i_xbest],ub[n + i],lm[n + i])
            if (mi > 40):
                fprintf_(options.fout,char('\\n.....'))
            else:
                fprintf_(options.fout,char('\\n'))
        if me:
            fprintf_(options.fout,char('EQUALITY CONSTRAINTS:\\n'))
            fprintf_(options.fout,char('i         ce            multiplier\\n'))
            for i in arange_(1,min_(me,40)).reshape(-1):
                fprintf_(options.fout,char('%0i %+16.6e %+16.6e\\n'),i,ceX[i,i_xbest],lm[n + mi + i])
            if (me > 40):
                fprintf_(options.fout,char('.....\\n'))
            else:
                fprintf_(options.fout,char('\\n'))
    return x,lm,info
def ecdfo_augmX_evalf_(f=None,y=None,m=None,X=None,fX=None,ciX=None,ceX=None,nfix=None,xfix=None,indfix=None,indfree=None,fxmax=None,neval=None,xstatus=None,xstatus_val=None,sstatus=None,dstatus=None,scaleX=None,scalefacX=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 22-[f,y,m,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,fxmax,neval,xstatus,xstatus_val,sstatus,dstatus,scaleX,scalefacX,info,options,values].count(None)+len(args)

    full_n=length_(xfix)
    I=eye_(full_n)
    xstatus[m]=xstatus_val
    sstatus[m]=1
    dstatus[m]=0
    if (nfix > 0):
        yfull=I[:,indfix] * xfix[indfix] + I[:,indfree] * y
        X[:,m]=yfull
        if (scaleX):
            yfull=yfull / scalefacX
        info.nsimul[2]=info.nsimul(2) + 1
        outdic,fvalue,info.ci,info.ce=f[2,yfull]
        info.f=fvalue
    else:
        X[:,m]=y
        if (scaleX):
            y=y / scalefacX
        info.nsimul[2]=info.nsimul(2) + 1
        outdic,fvalue,info.ci,info.ce=f[2,y]
        info.f=fvalue
    if outdic == 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo_augmX_evalf: initial point x is out of domain\\n\\n'))
        info.flag=values.fail_on_simul
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if isnan_(fvalue):
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo_augmX_evalf: f is NaN at the point x\\n\\n'))
            x=copy_(y)
        info.flag=values.fail_on_simul
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if isinf_(fvalue):
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo_augmX_evalf: f is Inf at the point x\\n\\n'))
            x=copy_(y)
        info.flag=values.fail_on_simul
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if outdic:
        info=sqplab_badsimul_(outdic,info,options,values)
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if not isempty_(info.ci) and size_(info.ci,2) != 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo_augmX_evalf: the computed ci must be a row vector\\n\\n'))
        info.flag=values.fail_on_simul
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    if not isempty_(info.ce) and size_(info.ce,2) != 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo_augmX_evalf: the computed ce must be a row vector\\n\\n'))
        info.flag=values.fail_on_simul
        return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
    fX[m]=min_(fxmax,real_(fvalue))
    if not isempty_(info.ci):
        ciX[:,m]=real_(info.ci.T)
    if not isempty_(info.ce):
        ceX[:,m]=real_(info.ce.T)
    neval=neval + 1
    return X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic
def ecdfo_check_cond_(A=None,cthreshold=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,cthreshold,options].count(None)+len(args)

    badcond=0
    eps=1e-14
    if (isempty_(find_(isnan_(A))) and isempty_(find_(isinf_(A)))):
        condA=cond_(A)
        if (condA > cthreshold):
            badcond=1
    else:
        badcond=1
    if (badcond):
        U,S,V=svd_(A,0,nargout=3)
        Sdiag=diag_(S)
        Sdiag[Sdiag < 1e-07]=1e-07
        S=diag_(Sdiag)
        A=(V * S * U.T).T
        if norm_(A - A.T,inf) > eps:
            if options.verbose >= 3:
                disp_([char('### ecdfo_check_cond: '),char("matrix is non symmetric. Resetting A=(A+A')/2.")])
            A=(A + A.T) * 0.5
    return A,badcond
def ecdfo_check_convex_(A=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[A,options].count(None)+len(args)

    ev=eig_(A)
    evneg=ev[ev < 0]
    if not isempty_(evneg):
        ZERO=1e-10
        EPS=1e-09
        v,d=eig_(A,nargout=2)
        d=diag_(d)
        d[d < ZERO]=EPS
        d=diag_(d)
        A=v * d * v.T
        if not isempty_(find_(not isreal_(A),1)):
            if options.verbose >= 3:
                disp_(char('### ecdfo_check_convex: matrix is non symmetric. Resetting A.'))
            A=(A + A.T) * 0.5
    return A
def ecdfo_computeHessian_(simul=None,x=None,null_step=None,constrained_pbl=None,lm=None,M=None,n=None,me=None,mi=None,s=None,gx=None,gci=None,gce=None,info=None,options=None,values=None,fcmodel=None,Y=None,fY=None,ciY=None,ceY=None,sigma=None,scale=None,shift_Y=None,QZ=None,RZ=None,whichmodel=None,ind_Y=None,i_xbest=None,m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 30-[simul,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m].count(None)+len(args)

    pc=1.0
    if options.algo_method == values.newton:
        info.nsimul[3]=info.nsimul(3) + 1
        outdic,tmp,tmp,tmp,tmp,info.g,info.ai,info.ae=simul[3,x]
        if outdic:
            info=sqplab_badsimul_(outdic,info,options,values)
            return M,pc,info
        info.nsimul[5]=info.nsimul(5) + 1
        outdic,M=simul[5,x,lm]
        if outdic:
            info=sqplab_badsimul_(outdic,info,options,values)
            return M,pc,info
    else:
        if not null_step:
            if options.hess_approx == values.bfgs:
                if options.verbose >= 4:
                    if constrained_pbl:
                        fprintf_(options.fout,char('\\nBFGS update:\\n'))
                    else:
                        fprintf_(options.fout,char('\\nBFGS inverse update:\\n'))
                y=- info.g
                if me:
                    y=y - info.ae.T * lm[n + mi + 1:n + mi + me]
                info.g=gx
                info.ai=gci
                info.ae=gce
                y=y + info.g
                if me:
                    y=y + info.ae.T * lm[n + mi + 1:n + mi + me]
                if options.bfgs_restart > 0 and mod_(info.nsimul(2),options.bfgs_restart) == 0:
                    M=eye_(size_(M))
                    pc=2.0
                else:
                    first=0
                    if info.niter == 1:
                        first=1
                    M,pc,info,values=sqplab_bfgs_(M,y,s,first,info,options,values,nargout=4)
                    if info.flag == values.fail_strange:
                        M=eye_(size_(M))
                        M,pc,info,values=sqplab_bfgs_(M,y,s,first,info,options,values,nargout=4)
                        if info.flag == values.fail_strange:
                            return M,pc,info
            else:
                if options.hess_approx == values.model:
                    info.g=gx
                    info.ai=gci
                    info.ae=gce
                    cur_degree=size_(Y,2)
                    if me + mi > 0:
                        if length_(ceY) > 0:
                            for i in arange_(1,cur_degree).reshape(-1):
                                norm_ceY[i]=norm_(ceY[:,i])
                        else:
                            norm_ceY=zeros_(1,cur_degree)
                        meritfY=fY + sigma.dot(norm_ceY)
                        model=bcdfo_computeP_(QZ,RZ,Y,meritfY,whichmodel,fcmodel[1,:],ind_Y,i_xbest,m,gx,scale,shift_Y)
                        M=bcdfo_hessP_(model,x,x,scale,shift_Y)
                    else:
                        M=bcdfo_hessP_(fcmodel[1,:],x,x,scale,shift_Y)
                else:
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### ecdfo: options.hess_approx not recognized\\n\\n'))
                    info.flag=values.fail_on_argument
                    return M,pc,info
    return M,pc,info
def ecdfo_find_smallf_(c=None,QZ=None,RZ=None,Y=None,fY=None,ciY=None,ceY=None,ind_Y=None,i_xbest=None,cur_degree=None,indfree=None,x=None,xl=None,xu=None,fx=None,dstatus=None,whichmodel=None,scale=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,sigma=None,info=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 24-[c,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,cur_degree,indfree,x,xl,xu,fx,dstatus,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,sigma,info].count(None)+len(args)

    dummy_set=find_(dstatus == c.dummy)
    ind_insideBounds=matlabarray([])
    for i in arange_(1,cur_degree).reshape(-1):
        if ((isempty_(find_(Y[:,i] < xl[indfree] or Y[:,i] > xu[indfree],1))) and (isempty_(find_(dummy_set == ind_Y[i],1)))):
            ind_insideBounds[i]=i
        else:
            ind_insideBounds[i]=1
    if length_(ceY) > 0:
        for i in arange_(1,cur_degree).reshape(-1):
            norm_ceY[i]=norm_(ceY[:,i])
    else:
        norm_ceY=zeros_(1,cur_degree)
    meritY=fY + sigma.dot(norm_ceY)
    fmin,imin=min_(meritY[ind_insideBounds],nargout=2)
    if (imin != 1 and fmin < meritY[1]):
        QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=ecdfo_swap_in_Y_(1,imin,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,nargout=9)
        fx=fY[1]
        i_xbest=ind_Y[1]
        if (not shift_Y):
            x=Y[:,1]
    info.f=fY[1]
    if length_(ceY) > 0:
        info.ce=ceY[:,1]
    if length_(ciY) > 0:
        info.ci=ciY[:,1]
    return x,fx,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,scale,info
def ecdfo_finish_(nb=None,mi=None,me=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[nb,mi,me,info,options,values].count(None)+len(args)

    if options.verbose >= 2:
        fprintf_(options.fout,char('%s\\n'),values.dline)
        fprintf_(options.fout,char('  Exit code %i: '),info.flag)
        if values.success == info.flag:
            fprintf_(options.fout,char('converged'))
        else:
            if values.fail_on_argument == info.flag:
                fprintf_(options.fout,char('wrong argument'))
            else:
                if values.fail_on_problem == info.flag:
                    fprintf_(options.fout,char('unaccepted problem structure'))
                else:
                    if values.fail_on_simul == info.flag:
                        fprintf_(options.fout,char('error when calling the simulator'))
                    else:
                        if values.stop_on_simul == info.flag:
                            fprintf_(options.fout,char('the simulator wants to stop'))
                        else:
                            if values.stop_on_max_iter == info.flag:
                                fprintf_(options.fout,char('max iteration reached'))
                            else:
                                if values.stop_on_max_simul == info.flag:
                                    fprintf_(options.fout,char('max simulation reached'))
                                else:
                                    if values.stop_on_dxmin == info.flag:
                                        fprintf_(options.fout,char('too small variation in x (dxmin active)'))
                                    else:
                                        if values.fail_on_non_decrease == info.flag:
                                            fprintf_(options.fout,char('the merit function cannot be decreased'))
                                        else:
                                            if values.fail_on_ascent_dir == info.flag:
                                                fprintf_(options.fout,char('ascent direction encountered in linesearch'))
                                            else:
                                                if values.fail_on_max_ls_iter == info.flag:
                                                    fprintf_(options.fout,char('too many stepsize trials in linesearch'))
                                                else:
                                                    if values.fail_on_ill_cond == info.flag:
                                                        fprintf_(options.fout,char('ill conditioning'))
                                                    else:
                                                        if values.fail_on_null_step == info.flag:
                                                            fprintf_(options.fout,char('null step d is solution of %0i QPs'),values.max_null_steps + 1)
                                                        else:
                                                            if values.fail_on_infeasible_QP == info.flag:
                                                                fprintf_(options.fout,char('infeasible QP'))
                                                            else:
                                                                if values.fail_on_unbounded_QP == info.flag:
                                                                    fprintf_(options.fout,char('unbounded QP'))
                                                                else:
                                                                    if values.fail_strange == info.flag:
                                                                        fprintf_(options.fout,char('strange failure, call a guru'))
                                                                    else:
                                                                        if values.stop_on_small_trust_region == info.flag:
                                                                            fprintf_(options.fout,char('trust region radius small'))
        fprintf_(options.fout,char('\\n'))
        fprintf_(options.fout,char('%s\\n'),values.dline)
        fprintf_(options.fout,char('  Final function value                     %12.5e\\n'),info.f)
        fprintf_(options.fout,char('  Optimality conditions:\\n'))
        if nb + mi + me > 0:
            fprintf_(options.fout,char('  . gradient of the Lagrangian (inf norm)  %11.5e\\n'),info.glagn)
            fprintf_(options.fout,char('  . feasibility                            %11.5e\\n'),info.feasn)
            if nb + mi:
                fprintf_(options.fout,char('  . complementarity                        %11.5e\\n'),info.compl)
        else:
            fprintf_(options.fout,char('  Gradient of the cost function (inf norm)  %11.5e\\n'),info.glagn)
        fprintf_(options.fout,char('  Counters:\\n'))
        fprintf_(options.fout,char('  . nbr of iterations                   %4i\\n'),info.niter)
        fprintf_(options.fout,char('  . nbr of function evaluations         %4i\\n'),info.nsimul(2) + info.nsimul(4))
        fprintf_(options.fout,char('  . nbr of gradient evaluations         %4i\\n'),info.nsimul(3) + info.nsimul(4))
    fprintf_(options.fout,char('%s\\n'),values.sline)
    return
def ecdfo_func_(x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[x].count(None)+len(args)

    global prob
    msg=matlabarray([])
    f=matlabarray([])
    ci=matlabarray([])
    ce=matlabarray([])
    if prob == 1:
        f=- (5 - (x[1] - 2) ** 2 - 2 * (x[2] - 1) ** 2)
        ce=x[1] + 4 * x[2] - 3
    else:
        if prob == 2:
            f=2 * x[1] ** 2 + x[2] ** 2
            ce=x[1] + x[2] - 1
        else:
            if prob == 3:
                f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2
                ce[1]=x[1] + x[2] + x[3]
                ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                ce=ce.T
            else:
                if prob == 4:
                    f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4]
                    ce[1]=x[1] + x[2] + x[3]
                    ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                    ce[3]=x[4] ** 3 - 1
                    ce=ce.T
                else:
                    if prob == 5:
                        f=exp_(x[1] * x[2] * x[3] * x[4] * x[5])
                        ce[1]=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4] ** 2 + x[5] ** 2 - 10
                        ce[2]=x[2] * x[3] - 5 * x[4] * x[5]
                        ce[3]=x[1] ** 3 + x[2] ** 3 + 1
                        ce=ce.T
    msg=0
    return msg,f,ci,ce
def ecdfo_func_grad_(indic=None,x=None,n=None,me=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[indic,x,n,me].count(None)+len(args)

    global prob
    outdic=matlabarray([])
    f=matlabarray([])
    ci=matlabarray([])
    ce=matlabarray([])
    g=matlabarray([])
    ai=matlabarray([])
    ae=matlabarray([])
    if prob == 0:
        if (indic == 2) or (indic == 4):
            f,ce=cuter_objcons_(x,nargout=2)
    else:
        if prob == 1:
            if (indic == 2) or (indic == 4):
                f=- (5 - (x[1] - 2) ** 2 - 2 * (x[2] - 1) ** 2)
                ce=x[1] + 4 * x[2] - 3
            if (indic == 3) or (indic == 4):
                pass
        else:
            if prob == 2:
                if (indic == 2) or (indic == 4):
                    f=2 * x[1] ** 2 + x[2] ** 2
                    ce=x[1] + x[2] - 1
                if (indic == 3) or (indic == 4):
                    pass
            else:
                if prob == 3:
                    if (indic == 2) or (indic == 4):
                        f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2
                        ce[1]=x[1] + x[2] + x[3]
                        ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                        ce=ce.T
                    if (indic == 3) or (indic == 4):
                        pass
                else:
                    if prob == 4:
                        if (indic == 2) or (indic == 4):
                            f=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4] + x[5] ** 2
                            ce[1]=x[1] + x[2] + x[3]
                            ce[2]=x[1] + 2 * x[2] + 3 * x[3] - 1
                            ce[3]=x[4] ** 3 + x[5] - 1
                            ce=ce.T
                        if (indic == 3) or (indic == 4):
                            pass
                    else:
                        if prob == 5:
                            if indic == 2 or indic == 4:
                                f=exp_(x[1] * x[2] * x[3] * x[4] * x[5])
                                ce[1]=x[1] ** 2 + x[2] ** 2 + x[3] ** 2 + x[4] ** 2 + x[5] ** 2 - 10
                                ce[2]=x[2] * x[3] - 5 * x[4] * x[5]
                                ce[3]=x[1] ** 3 + x[2] ** 3 + 1
                                ce=ce.T
                        else:
                            if prob == 100:
                                oldFolder=cd_(char('../../code_lokal/VonKarmanOgive'))
                                fid=fopen_(char('IN_IOSO.DAT'),char('w'))
                                for i in arange_(1,length_(x)).reshape(-1):
                                    fprintf_(fid,char('%f\\n'),x[i])
                                fclose_(fid)
                                not test.exe
                                fid=fopen_(char('OUT_IOSO.dat'),char('r'))
                                f_orig=str2double_(fgetl_(fid))
                                ce=str2double_(fgetl_(fid)) - 0.0655
                                fclose_(fid)
                                cd_(oldFolder)
                                if (f_orig > 1e+16):
                                    f_orig
                                    oldFolder=cd_(char('../../code_lokal/VonKarmanOgive'))
                                    not test.exe
                                    fid=fopen_(char('OUT_IOSO.dat'),char('r'))
                                    f_orig=str2double_(fgetl_(fid))
                                    ce=str2double_(fgetl_(fid)) - 0.0655
                                    fclose_(fid)
                                    cd_(oldFolder)
                                    if (f_orig > 1e+16):
                                        f_orig
                                        load_(char('fvalues_ecdfo_karmanogive.dat'))
                                        sz_fval=size_(fvalues_ecdfo_karmanogive,1)
                                        if sz_fval > 10:
                                            val_new=sum_(fvalues_ecdfo_karmanogive_(arange_(sz_fval - 9,sz_fval),arange_()),1) / 10
                                        else:
                                            val_new=sum_(fvalues_ecdfo_karmanogive,1) / sz_fval
                                        f=val_new[2]
                                        ce=val_new[3]
                                    else:
                                        f=copy_(f_orig)
                                else:
                                    f=copy_(f_orig)
                                fid=fopen_(char('fvalues_ecdfo_karmanogive.dat'),char('a'))
                                fprintf_(fid,char('%f %f %f\\n'),f_orig,f,ce)
                                fclose_(fid)
                                disp_([char('fval = '),num2str_(f),char(', cval = '),num2str_(ce)])
    outdic=0
    return outdic,f,ci,ce,g,ai,ae
def hessian_lagr_(xy=None,lm=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[xy,lm].count(None)+len(args)

    outdic=matlabarray([])
    hl=matlabarray([])
    x=xy[1:HC_nj]
    y=xy[HC_nj + 1:n]
    i=[arange_(1,HC_nj - 1)].T
    j=[arange_(2,HC_nj)].T
    v=- 2 * lm[n + 2:n + HC_nj]
    hl=sparse_(i,j,v,HC_nj,HC_nj)
    hl=hl.T + 2 * sparse_(diag_(lm[n + 1:n + HC_nj] + lm[n + 2:n + nbars])) + hl
    hl=matlabarray([[hl,zeros_(HC_nj)],[zeros_(HC_nj),hl]])
    outdic=0
    return outdic,hl
def ecdfo_init_prob_(prob=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[prob].count(None)+len(args)

    global fileoutput,simul_not_initialized
    x0=matlabarray([])
    lx=matlabarray([])
    ux=matlabarray([])
    li=matlabarray([])
    ui=matlabarray([])
    fileoutput=1
    simul_not_initialized=1
    dxmin=1e-06
    dcimin=sqrt_(eps)
    infb=1e+20
    if prob == 1:
        n=2
        nb=2
        mi=0
        me=1
        x0=matlabarray([[4.6],[0.0]])
        lx=matlabarray([1.95,- 1e+20])
        ux=matlabarray([1e+20,0.3])
    else:
        if prob == 2:
            n=2
            nb=0
            mi=0
            me=1
            x0=matlabarray([[- 1],[2.54378]])
            lx=- inf * ones_(n,1)
            ux=inf * ones_(n,1)
        else:
            if prob == 3:
                nb=0
                mi=0
                me=2
                x0=matlabarray([[0.0],[0.0],[0.5]])
                n=length_(x0)
                lx=matlabarray([- 0.5,0.0,- inf])
                ux=matlabarray([inf,inf,inf])
            else:
                if prob == 4:
                    nb=0
                    mi=0
                    me=3
                    x0=matlabarray([[1.0],[1.0],[1.0],[0.0]])
                    n=length_(x0)
                    lx=- inf * ones_(n,1)
                    ux=inf * ones_(n,1)
                else:
                    if prob == 5:
                        nb=0
                        mi=0
                        me=3
                        x0=matlabarray([[- 2.0],[2.0],[2.0],[1.0],[1.0]])
                        n=5
                        lx=- inf * ones_(n,1)
                        ux=inf * ones_(n,1)
    info=0
    return x0,lx,ux,dxmin,li,ui,dcimin,infb,n,nb,mi,me,info
def ecdfo_iter_printout_(info=None,old_delta=None,norms=None,pc=None,itype=None,values=None,nb=None,mi=None,options=None,constrained_pbl=None,merit=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 11-[info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit].count(None)+len(args)

    if options.verbose < 4:
        fprintf_(options.fout,char('%4i  %4i'),info.niter,info.nsimul(2) + info.nsimul(4))
        fprintf_(options.fout,char('  %+14.8e  %+14.8e  '),info.f,merit)
        if constrained_pbl:
            fprintf_(options.fout,char('%10.4e  %14.8e'),info.glagn,info.feasn)
        else:
            fprintf_(options.fout,char('%10.4e'),info.glagn)
        if info.niter > 1:
            fprintf_(options.fout,char('  %8.2e'),old_delta)
            fprintf_(options.fout,char('  %8.2e'),norms)
            fprintf_(options.fout,char('  %4.2f'),pc)
            fprintf_(options.fout,char('  %5s\\n'),itype)
        else:
            fprintf_(options.fout,char('  \\n'))
    if options.verbose >= 4:
        fprintf_(options.fout,char('%s\\n'),values.dline)
        fprintf_(options.fout,char('iter %i,'),info.niter)
        fprintf_(options.fout,char('  cost %12.5e'),info.f)
        if constrained_pbl:
            fprintf_(options.fout,char(',  glagn %11.5e,  feas %11.5e'),info.glagn,info.feasn)
            if (nb + mi > 0):
                fprintf_(options.fout,char(',  compl %11.5e'),info.compl)
        else:
            fprintf_(options.fout,char(',  grad %11.5e'),info.glagn)
        if info.niter > 1:
            fprintf_(options.fout,char('  %4.2f\\n'),pc)
        else:
            fprintf_(options.fout,char('  \\n'))
    return
def ecdfo_main_(func=None,n=None,nb=None,mi=None,me=None,lm=None,nitold=None,nit=None,i_xbest=None,lb=None,ub=None,m=None,X=None,fX=None,ciX=None,ceX=None,ind_Y=None,QZ=None,RZ=None,delta=None,cur_degree=None,neval=None,maxeval=None,maxit=None,fcmodel=None,gx=None,normgx=None,show_errg=None,pquad=None,pdiag=None,plin=None,stallfact=None,eps_rho=None,Deltamax=None,rep_degree=None,epsilon=None,verbose=None,eta1=None,eta2=None,gamma1=None,gamma2=None,gamma3=None,interpol_TR=None,factor_CV=None,Lambda_XN=None,Lambda_CP=None,factor_FPU=None,factor_FPR=None,Lambda_FP=None,criterion_S=None,criterion_FP=None,criterion_CP=None,mu=None,theta=None,eps_TR=None,eps_L=None,lSolver=None,stratLam=None,eps_current=None,vstatus=None,xstatus=None,sstatus=None,dstatus=None,ndummyY=None,sspace_save=None,xspace_save=None,xfix=None,fxmax=None,poised_model=None,M=None,kappa_ill=None,kappa_th=None,eps_bnd=None,poised=None,Y_radius=None,c=None,level=None,whichmodel=None,hardcons=None,noisy=None,scaleX=None,scalefacX=None,CNTsin=None,shrink_Delta=None,scale=None,shift_Y=None,info=None,options=None,values=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 89-[func,n,nb,mi,me,lm,nitold,nit,i_xbest,lb,ub,m,X,fX,ciX,ceX,ind_Y,QZ,RZ,delta,cur_degree,neval,maxeval,maxit,fcmodel,gx,normgx,show_errg,pquad,pdiag,plin,stallfact,eps_rho,Deltamax,rep_degree,epsilon,verbose,eta1,eta2,gamma1,gamma2,gamma3,interpol_TR,factor_CV,Lambda_XN,Lambda_CP,factor_FPU,factor_FPR,Lambda_FP,criterion_S,criterion_FP,criterion_CP,mu,theta,eps_TR,eps_L,lSolver,stratLam,eps_current,vstatus,xstatus,sstatus,dstatus,ndummyY,sspace_save,xspace_save,xfix,fxmax,poised_model,M,kappa_ill,kappa_th,eps_bnd,poised,Y_radius,c,level,whichmodel,hardcons,noisy,scaleX,scalefacX,CNTsin,shrink_Delta,scale,shift_Y,info,options,values].count(None)+len(args)

    old_delta=copy_(delta)
    sigma=1
    rho_factor=0.3
    tau1=copy_(gamma2)
    tau2=copy_(gamma3)
    tau3=5
    constrained_pbl=copy_(me)
    null_step=0
    merit=info.f + sigma * norm_(info.ce)
    msg=char('Unexpected message from ecdfo_main')
    m=size_(X,2)
    indfree=find_(vstatus == c.free)
    indfix=find_(vstatus >= c.fixed)
    nfix=length_(indfix)
    Y=X[indfree,ind_Y]
    x=X[indfree,i_xbest]
    n=size_(Y,1)
    fY=fX[ind_Y]
    fx=fX[i_xbest]
    itype=char(' ')
    pc=0
    norms=0
    pred=0
    if mi > 0:
        ciY=ciX[:,ind_Y]
    else:
        ciY=matlabarray([])
        gci=matlabarray([])
    if me > 0:
        ceY=ceX[:,ind_Y]
    else:
        ceY=matlabarray([])
        gce=matlabarray([])
    radius_has_been_rejected=copy_(false)
    while 1:

        if info.niter >= options.miter:
            info.flag=values.stop_on_max_iter
            ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        if info.nsimul(2) >= options.msimul:
            info.flag=values.stop_on_max_simul
            ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        xk=copy_(x)
        lbounds=- inf * ones_(size_(x))
        ubounds=inf * ones_(size_(x))
        ilb=abs_(lb[indfree] - x) < 1e-05
        iub=abs_(ub[indfree] - x) < 1e-05
        lbounds[ilb]=lb[indfree[ilb]]
        ubounds[iub]=ub[indfree[iub]]
        lm,info=sqplab_lsmult_(x,lbounds,ubounds,info,options,values,nargout=2)
        feas,comp,info=ecdfo_optimality_(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
        if info.flag:
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        info.glagn=norm_(info.glag,inf)
        info.feasn=norm_(feas,inf)
        info.compl=norm_(comp,inf)
        if (info.niter > 0) and (options.verbose >= 3):
            fprintf_(options.fout,char('\\nOptimality:\\n'))
            if constrained_pbl:
                fprintf_(options.fout,char('  |grad Lag|      = %12.5e\\n'),info.glagn)
                fprintf_(options.fout,char('  feasibility     = %12.5e\\n'),info.feasn)
            else:
                fprintf_(options.fout,char(' |grad f| = %12.5e\\n'),info.glagn)
        if ((info.glagn <= options.tol(1)) and (info.feasn <= options.tol(2)) and (info.compl <= options.tol(3))) or delta <= epsilon * 1e-05 or (pred == - 1.0):
            augment=rep_degree - cur_degree
            if (augment <= 0):
                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                poisedness_known=1
                errg=poised * Y_radius / factor_CV
                if options.verbose >= 3:
                    disp_([char('error on gradient before set improvement = '),num2str_(errg)])
                if ((((info.glagn <= options.tol(1)) and (info.feasn <= options.tol(2)) and (info.compl <= options.tol(3)) and errg <= epsilon) or delta <= epsilon * 1e-05) and strcmp_(level,char('toplevel'))):
                    info.niter=info.niter + 1
                    itype=char('conv')
                    ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
                    info.flag=values.success
                    msg=matlabarray([char(' Convergence in '),int2str_(neval),char(' evaluations of the objective function.')])
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                else:
                    info.niter=info.niter + 1
                    ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
            if options.verbose >= 3:
                disp_(char('not immediately converged - improve set!'))
            itype=char('impr')
            if (augment <= 0):
                eps_current=max_(mu * eps_current,epsilon)
            if (normgx <= epsilon):
                effective_FPR=1
            else:
                effective_FPR=copy_(factor_FPR)
            if (augment > 0):
                itype=char('augm')
                if (info.glagn <= epsilon):
                    if (lSolver == 2):
                        delta=epsilon / sqrt_(n)
                        eps_current=epsilon / sqrt_(n)
                    else:
                        delta=copy_(epsilon)
                        eps_current=copy_(epsilon)
                ynew=- delta * ones_(n,1) + 2 * delta * rand_(n,1)
                cur_degree,QZ,RZ,Y,xbase,scale=bcdfo_augment_Y_(ynew,Y[:,1:cur_degree],whichmodel,shift_Y,delta,normgx,kappa_ill,nargout=6)
                ind_Y[cur_degree]=cur_degree
                if (hardcons):
                    ynew,improvement=bcdfo_find_new_yj_bc_(QZ,RZ,Y,cur_degree,delta,eps_L,xbase,lSolver,whichmodel,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
                else:
                    ynew,improvement=bcdfo_find_new_yj_(QZ,RZ,Y,cur_degree,delta,eps_L,xbase,lSolver,whichmodel,scale,shift_Y,nargout=2)
                QZ,RZ,Y,xbase,scale=bcdfo_replace_in_Y_(QZ,RZ,ynew,Y,cur_degree,xbase,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=5)
                replaced=matlabarray([cur_degree])
            else:
                if (info.glagn <= factor_CV * epsilon):
                    if (lSolver == 2):
                        radius=min_(delta / sqrt_(n),epsilon / sqrt_(n))
                    else:
                        radius=min_(delta,epsilon)
                else:
                    radius=max_(delta,eps_current)
                QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y_(QZ,RZ,Y,radius,effective_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,normgx,kappa_ill,nargout=8)
                if options.verbose >= 3:
                    disp_([char('improve interpolation set (in radius = '),num2str_(radius),char(') : replaced = '),num2str_(replaced),char(', poised = '),num2str_(poised),char(', Y_radius = '),num2str_(Y_radius)])
            if (options.verbose >= 4):
                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                disp_([char(' poisedness(Y) = '),num2str_(poised)])
            poised_model=1
            for i in arange_(1,length_(replaced)).reshape(-1):
                j=replaced[i]
                m=m + 1
                xstatus[ind_Y[j]]=c.unused
                ind_Y[j]=m
                xstatus[m]=c.inY
                X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf_(func,Y[:,j],m,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,fxmax,neval,xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=10)
                fY[j]=fX[m]
                if mi > 0:
                    ciY[:,j]=info.ci.T
                if me > 0:
                    ceY[:,j]=info.ce.T
                poised_model=0
                if (strcmp_(msg[1:5],char('Error'))):
                    if (strcmp_(level,char('toplevel'))):
                        disp_(msg)
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            i_xold=copy_(i_xbest)
            x,fx,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,scale,info=ecdfo_find_smallf_(c,QZ,RZ,Y,fY,ciY,ceY,ind_Y,i_xbest,cur_degree,indfree,x,lb,ub,fx,dstatus,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,sigma,info,nargout=12)
            fcmodel=bcdfo_computeP_(QZ,RZ,Y,[[fY],[ciY],[ceY]],whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
            gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
            normgx=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
            if mi > 0:
                gci=zeros_(mi,n)
                for i in arange_(1,mi).reshape(-1):
                    gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
            if me > 0:
                gce=zeros_(me,n)
                for i in arange_(1,me).reshape(-1):
                    gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
            M,pc,info=ecdfo_computeHessian_(func,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m,nargout=3)
            lbounds=- inf * ones_(size_(x))
            ubounds=inf * ones_(size_(x))
            ilb=abs_(lb[indfree] - x) < 1e-05
            iub=abs_(ub[indfree] - x) < 1e-05
            lbounds[ilb]=lb[indfree[ilb]]
            ubounds[iub]=ub[indfree[iub]]
            lm,info=sqplab_lsmult_(x,lbounds,ubounds,info,options,values,nargout=2)
            feas,comp,info=ecdfo_optimality_(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
            if info.flag:
                return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            info.glagn=norm_(info.glag,inf)
            info.feasn=norm_(feas,inf)
            info.compl=norm_(comp,inf)
            if (info.niter > 0) and (options.verbose >= 3):
                fprintf_(options.fout,char('\\nOptimality:\\n'))
                if constrained_pbl:
                    fprintf_(options.fout,char('  |grad Lag|      = %12.5e\\n'),info.glagn)
                    fprintf_(options.fout,char('  feasibility     = %12.5e\\n'),info.feasn)
                else:
                    fprintf_(options.fout,char(' |grad f| = %12.5e\\n'),info.glagn)
            errg=poised * Y_radius / factor_CV
            if options.verbose >= 3:
                disp_([char('error on gradient after set improvement = '),num2str_(errg)])
            if ((info.glagn / factor_CV <= options.tol(1)) and (info.feasn / factor_CV <= options.tol(2)) and (info.compl / factor_CV <= options.tol(3)) and errg <= epsilon and cur_degree >= rep_degree and strcmp_(level,char('toplevel'))):
                info.niter=info.niter + 1
                itype=char('conv')
                ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
                msg=matlabarray([char(' Convergence in '),int2str_(neval),char(' evaluations of the objective function.')])
                return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            if options.verbose >= 3:
                disp_(char('not converged after improvement of interpolation set'))
            delta=copy_(radius)
        if radius_has_been_rejected == false:
            f0=info.f
            ce0=info.ce
            ce0n=norm_(ce0)
            merit0=f0 + sigma * ce0n
            prec_r=options.tol(2) / 10
            prec_t=options.tol(1) / 10
            if options.verbose >= 5:
                fprintf_(options.fout,char('\\nStep computation: merit = %12.5e\\n'),merit0)
            if options.verbose == 4:
                fprintf_(options.fout,char('   radius     |r|      |t|      |s|     sigma     rho\\n'))
        info.niter=info.niter + 1
        ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
        if options.verbose >= 5:
            fprintf_(options.fout,char('  Trust radius = %8.2e\\n'),delta)
        old_delta=copy_(delta)
        xnew,deltaTR,rpred,active_r,active_t,lm_computed,lm,info=ecdfo_solve_TR_bc_(func,x,lb[indfree],ub[indfree],delta,mi,me,M,prec_r,prec_t,info,options,values,radius_has_been_rejected,lm,ceY,ciY,gx,nargout=8)
        if info.flag == values.fail_strange:
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        s=xnew - xk
        x=copy_(xk)
        norms=norm_(s)
        if options.verbose >= 3:
            fprintf_(options.fout,char('  Full step:\\n    |s| = %8.2e\\n'),norms)
        qcost=info.g.T * s + 0.5 * (s.T * M * s)
        if rpred == 0:
            sigmab=0
        else:
            sigmab=qcost / ((1 - rho_factor) * rpred)
        if sigma < sigmab:
            sigma=max_(sigmab,1.5 * sigma)
            merit0=f0 + sigma * ce0n
        if options.verbose >= 4:
            fprintf_(options.fout,char('  Penalty parameter = %8.2e (threshold %8.2e)\\n'),sigma,sigmab)
        if (interpol_TR == 1):
            gTs=gx.T * s
        xplus=x + s
        m=m + 1
        X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info,outdic=ecdfo_augmX_evalf_(func,xplus,m,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,fxmax,neval,xstatus,0,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=10)
        if (info.flag):
            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
        else:
            fxplus=fX[m]
        if outdic:
            if outdic == 1:
                if options.verbose >= 5:
                    fprintf_(options.fout,char('  Step rejected (out of an implicit domain)\\n'))
            else:
                if outdic == 2:
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### ecdfo_main: the simulator wants to stop\\n\\n'))
                    info.flag=values.stop_on_simul
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                else:
                    if options.verbose:
                        fprintf_(options.fout,char('\\n### ecdfo_main: error in the simulator (outdic = %0i)\\n\\n'),outdic)
                    info.flag=values.fail_on_simul
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            itype=char('xfail')
            radius_has_been_rejected=copy_(true)
            if options.verbose >= 5:
                fprintf_(options.fout,char('  rho = %8.2e \\n'),rho)
            info.ce=ce0
            delta=tau1 * delta
            if options.verbose == 3 or options.verbose >= 5:
                fprintf_(options.fout,char('  Step rejected due to failure in function evaluation\\n'))
        else:
            merit=info.f + sigma * norm_(info.ce)
            if options.verbose >= 3:
                fprintf_(options.fout,char('  Merit function: %15.8e -> %15.8e\\n'),merit0,merit)
            ared=merit0 - merit
            pred=- qcost + sigma * rpred
            if pred < 0:
                if options.verbose:
                    fprintf_(options.fout,char('\\n### ecdfo_main: pred = %9.2e should be positive\\n\\n'),pred)
                info.flag=values.fail_strange
                return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
            else:
                if pred == 0:
                    pred=- 1.0
                    disp_(char('### ecdfo_main : Warning : predicted reduction is 0 ###'))
            rho=ared / pred
            if pred == - 1.0:
                rho=- 1.0
            if (rho >= eta1):
                succ=1
            else:
                succ=0
            if options.verbose == 4:
                fprintf_(options.fout,char('  %8.2e  %7.1e  %7.1e  %7.1e  %7.1e  %9.2e\\n'),delta,norm_r,norm_(t),norms,sigma,rho)
            i_xold=copy_(i_xbest)
            pos=0
            if (rho >= eta1):
                if options.verbose >= 5:
                    fprintf_(options.fout,char('  Step accepted (rho = %9.2e; ared = %9.2e, pred = %9.2e)\\n'),rho,ared,pred)
                if (merit >= merit0):
                    info.flag=values.fail_on_non_decrease
                    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                if (cur_degree < pquad or (whichmodel == 3 and cur_degree < pquad + pquad)):
                    cur_degree,QZ,RZ,Y,xbase,scale=bcdfo_augment_Y_(xplus,Y[:,1:cur_degree],whichmodel,shift_Y,delta,normgx,kappa_ill,nargout=6)
                    pos=copy_(cur_degree)
                else:
                    QZ,RZ,Y,pos,x,scale=bcdfo_include_in_Y_(xplus,QZ,RZ,Y,arange_(1,cur_degree),Lambda_XN,criterion_S,x,whichmodel,succ,scale,shift_Y,delta,normgx,kappa_ill,nargout=6)
                    if (pos > 0):
                        xstatus[ind_Y[pos]]=c.unused
                if (pos > 0):
                    itype=char('succ')
                    if (options.verbose >= 3):
                        disp_([char(' replacing/including interpolation point '),int2str_(pos),char(' (successful)')])
                    xstatus[m]=c.inY
                    ind_Y[pos]=m
                    fY[pos]=fxplus
                    if mi > 0:
                        ciY[:,pos]=info.ci.T
                    if me > 0:
                        ceY[:,pos]=info.ce.T
                    QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=ecdfo_swap_in_Y_(1,pos,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=9)
                    fx=copy_(fxplus)
                    i_xbest=copy_(m)
                    if (not shift_Y):
                        x=Y[:,1]
                    poised_model=0
                    fcmodel=bcdfo_computeP_(QZ,RZ,Y,[[fY],[ciY],[ceY]],whichmodel,fcmodel[1,:],ind_Y,i_xold,m,gx,scale,shift_Y)
                    gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
                    normgx=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
                    if mi > 0:
                        gci=zeros_(mi,n)
                        for i in arange_(1,mi).reshape(-1):
                            gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                    if me > 0:
                        gce=zeros_(me,n)
                        for i in arange_(1,me).reshape(-1):
                            gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                    if rho >= eta2:
                        if (active_r or active_t):
                            delta=delta * tau3
                        else:
                            delta=min_(max_(tau3 * norms,delta),Deltamax)
                    else:
                        if rho >= eta1:
                            if (active_r or active_t):
                                delta=delta * tau2
                            else:
                                delta=min_(max_(tau2 * norms,delta),Deltamax)
                    radius_has_been_rejected=copy_(false)
                    if lm_computed == 0:
                        lbounds=- inf * ones_(size_(x))
                        ubounds=inf * ones_(size_(x))
                        ilb=abs_(lb[indfree] - x) < 1e-05
                        iub=abs_(ub[indfree] - x) < 1e-05
                        lbounds[ilb]=lb[indfree[ilb]]
                        ubounds[iub]=ub[indfree[iub]]
                        lm,info=sqplab_lsmult_(x,lbounds,ubounds,info,options,values,nargout=2)
                    M,pc,info=ecdfo_computeHessian_(func,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m,nargout=3)
            if pred == - 1.0:
                pos=1
                rho=1
            if (rho < eta1) or (pos == 0):
                itype=char('repD,repF,repC,redD')
                itype=char('unsuc')
                radius_has_been_rejected=copy_(true)
                if options.verbose == 3 or options.verbose >= 5:
                    fprintf_(options.fout,char('  Step rejected (rho = %9.2e; ared = %9.2e, pred = %9.2e)\\n'),rho,ared,pred)
                if (((cur_degree < pquad) or (whichmodel == 3 and cur_degree < pquad + pquad)) and (rho < eta1)):
                    cur_degree,QZ,RZ,Y,xbase,scale=bcdfo_augment_Y_(xplus,Y[:,1:cur_degree],whichmodel,shift_Y,delta,normgx,kappa_ill,nargout=6)
                    if (options.verbose >= 3):
                        disp_([char(' including interpolation point '),int2str_(cur_degree),char(' (augm)')])
                    xstatus[m]=c.inY
                    ind_Y[cur_degree]=m
                    fY[cur_degree]=fxplus
                    if mi > 0:
                        ciY[:,cur_degree]=info.ci.T
                    if me > 0:
                        ceY[:,cur_degree]=info.ce.T
                    poised_model=0
                    fcmodel=bcdfo_computeP_(QZ,RZ,Y,[[fY],[ciY],[ceY]],whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
                    gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
                    normgx=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
                    if mi > 0:
                        gci=zeros_(mi,n)
                        for i in arange_(1,mi).reshape(-1):
                            gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                    if me > 0:
                        gce=zeros_(me,n)
                        for i in arange_(1,me).reshape(-1):
                            gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                    itype=char('augm')
                    pos=copy_(m)
                    if (shrink_Delta == 1 and delta > epsilon):
                        delta=gamma2 * delta
                if (cur_degree >= pquad or pos == 0):
                    if ((pos == 0) and (poised_model == 0 or delta <= eps_current)):
                        d=zeros_(1,cur_degree)
                        if (rho >= eta1):
                            for j in arange_(1,cur_degree).reshape(-1):
                                if (lSolver == 1):
                                    d[j]=norm_(Y[:,j] - xplus)
                                else:
                                    d[j]=norm_(Y[:,j] - xplus,inf)
                        else:
                            for j in arange_(2,cur_degree).reshape(-1):
                                if (lSolver == 1):
                                    d[j]=norm_(Y[:,j] - x)
                                else:
                                    d[j]=norm_(Y[:,j] - x,inf)
                        FPlength=factor_FPU * (1 + eps_TR) * delta
                        if (rho >= eta1):
                            criterion_FPn=char('weighted')
                        else:
                            criterion_FPn=copy_(criterion_FP)
                        QZ,RZ,Y,pos,x,scale=bcdfo_include_in_Y_(xplus,QZ,RZ,Y,find_(d > FPlength),Lambda_FP,criterion_FPn,x,whichmodel,succ,scale,shift_Y,delta,normgx,kappa_ill,nargout=6)
                        if (pos > 0):
                            itype=char('repF')
                            if (options.verbose >= 3):
                                disp_([char(' replacing interpolation point '),int2str_(pos),char(' (far)')])
                            xstatus[ind_Y[pos]]=c.unused
                            xstatus[m]=c.inY
                            ind_Y[pos]=m
                            fY[pos]=fxplus
                            if mi > 0:
                                ciY[:,pos]=info.ci.T
                            if me > 0:
                                ceY[:,pos]=info.ce.T
                            if (rho >= eta1):
                                QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=bcdfo_swap_in_Y_(1,pos,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=9)
                                fx=copy_(fxplus)
                                info.f=fx
                                if mi > 0:
                                    info.ci=ciY[:,1]
                                if me > 0:
                                    info.ce=ceY[:,1]
                                i_xbest=copy_(m)
                                if (not shift_Y):
                                    x=Y[:,1]
                                poised_model=0
                                if (options.verbose >= 3):
                                    disp_([char(' swapped point to position 1')])
                                itype=char('repFs')
                                delta=min_(max_(gamma3 * norms,delta),Deltamax)
                            else:
                                if (shrink_Delta == 1 and delta > epsilon):
                                    delta=gamma2 * delta
                            fcmodel=bcdfo_computeP_(QZ,RZ,Y,[[fY],[ciY],[ceY]],whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
                            gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
                            normgx=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
                            if mi > 0:
                                gci=zeros_(mi,n)
                                for i in arange_(1,mi).reshape(-1):
                                    gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                            if me > 0:
                                gce=zeros_(me,n)
                                for i in arange_(1,me).reshape(-1):
                                    gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                        if (pos == 0):
                            if (rho >= eta1):
                                criterion_CPn=char('standard')
                            else:
                                criterion_CPn=copy_(criterion_CP)
                            if (rho >= eta1):
                                Lambda_CPn=1e-15
                            else:
                                Lambda_CPn=copy_(Lambda_CP)
                                d[1]=2 * FPlength
                            QZ,RZ,Y,pos,x,scale=bcdfo_include_in_Y_(xplus,QZ,RZ,Y,find_(d <= FPlength),Lambda_CPn,criterion_CPn,x,whichmodel,succ,scale,shift_Y,delta,normgx,kappa_ill,nargout=6)
                            if (pos > 0):
                                itype=char('repC')
                                if (pos == 1):
                                    i_xold=ind_Y[2]
                                if (options.verbose >= 3):
                                    disp_([char(' replacing interpolation point '),int2str_(pos),char(' (close)')])
                                xstatus[ind_Y[pos]]=c.unused
                                xstatus[m]=c.inY
                                ind_Y[pos]=m
                                fY[pos]=fxplus
                                if mi > 0:
                                    ciY[:,pos]=info.ci.T
                                if me > 0:
                                    ceY[:,pos]=info.ce.T
                                if (rho >= eta1):
                                    QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,scale=bcdfo_swap_in_Y_(1,pos,QZ,RZ,Y,ind_Y,fY,ciY,ceY,x,whichmodel,scale,shift_Y,delta,normgx,kappa_ill,nargout=9)
                                    fx=copy_(fxplus)
                                    info.f=fx
                                    if mi > 0:
                                        info.ci=ciY[:,1]
                                    if me > 0:
                                        info.ce=ceY[:,1]
                                    i_xbest=copy_(m)
                                    if (not shift_Y):
                                        x=Y[:,1]
                                    poised_model=0
                                    if (options.verbose >= 3):
                                        disp_([char(' swapped point to position 1')])
                                    itype=char('repCs')
                                    delta=min_(max_(gamma3 * norms,delta),Deltamax)
                                else:
                                    if (shrink_Delta == 1 and delta > epsilon):
                                        delta=gamma2 * delta
                                fcmodel=bcdfo_computeP_(QZ,RZ,Y,[[fY],[ciY],[ceY]],whichmodel,fcmodel,ind_Y,i_xold,m,gx,scale,shift_Y)
                                gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
                                normgx=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
                                if mi > 0:
                                    gci=zeros_(mi,n)
                                    for i in arange_(1,mi).reshape(-1):
                                        gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
                                if me > 0:
                                    gce=zeros_(me,n)
                                    for i in arange_(1,me).reshape(-1):
                                        gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
                    if (pos == 0):
                        if (options.verbose >= 3):
                            disp_(char(' decreasing the TR radius'))
                        xstatus[m]=c.unused
                        if (interpol_TR == 1):
                            curvature=- pred - gTs
                            gam_inter=(eta2 - 1) * gTs / (fxplus - fx - gTs - eta2 * curvature)
                            delta=max_(gamma1,min_(gam_inter,gamma2)) * min_(delta,norms)
                        else:
                            delta=gamma2 * norms
                        itype=char('redD')
                        if (delta < stallfact * norm_(x) or delta < epsilon * 1e-05):
                            if (options.verbose >= 2 and strcmp_(level,char('toplevel'))):
                                ecdfo_iter_printout_(info,old_delta,norms,pc,itype,values,nb,mi,options,constrained_pbl,merit)
                                if (show_errg):
                                    disp_([char('************************************* Trust-region'),char(' radius small *********************************')])
                                else:
                                    disp_([char('******************************** Trust-region'),char(' radius small ****************************')])
                            msg=matlabarray([char('Algorithm stopped after '),int2str_(neval),char(' evaluations of the objective function because Delta small.')])
                            info.flag=values.stop_on_small_trust_region
                            return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
                info.ce=ce0
                info.f=f0
                lbounds=- inf * ones_(size_(x))
                ubounds=inf * ones_(size_(x))
                ilb=abs_(lb[indfree] - x) < 1e-05
                iub=abs_(ub[indfree] - x) < 1e-05
                lbounds[ilb]=lb[indfree[ilb]]
                ubounds[iub]=ub[indfree[iub]]
                lm,info=sqplab_lsmult_(x,lbounds,ubounds,info,options,values,nargout=2)
                M,pc,info=ecdfo_computeHessian_(func,x,null_step,constrained_pbl,lm,M,n,me,mi,s,gx,gci,gce,info,options,values,fcmodel,Y,fY,ciY,ceY,sigma,scale,shift_Y,QZ,RZ,whichmodel,ind_Y,i_xbest,m,nargout=3)

    return nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info
def ecdfo_optimality_(x=None,lm=None,lb=None,ub=None,info=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[x,lm,lb,ub,info,options].count(None)+len(args)

    global threshold
    n=length_(info.g)
    mi=length_(info.ci)
    me=length_(info.ce)
    info.glag=info.g
    gradlag=info.g
    bounds=(abs_(lb - x) < 1e-05) + (abs_(ub - x) < 1e-05)
    if options.verbose >= 4:
        fprintf_(char('\\n     lb             x            ub             g            lm\\n'))
        for i in arange_(1,n).reshape(-1):
            fprintf_(char('%12.5e  %12.5e  %12.5e  %12.5e  %12.5e\\n'),lb[i],x[i],ub[i],info.glag(i),lm[i])
    I=find_(bounds[1:n])
    info.glag[I]=info.glag(I) + lm[I]
    boundsmult=lm[I]
    gradlag=info.glag
    if mi > 0:
        I=find_(bounds[n + 1:n + mi])
        info.glag=info.glag + info.ai(I,arange_()).T * lm[n + I]
    if me > 0:
        derivequcons=info.ae
        equmult=lm[n + mi + 1:n + mi + me]
        info.glag=info.glag + info.ae.T * lm[n + mi + 1:n + mi + me]
        gradlag=info.glag
    feas=matlabarray([[max_(0,max_([[x],[info.ci]] - ub,lb - [[x],[info.ci]]))],[info.ce]])
    v=matlabarray([[x],[info.ci]])
    compl=zeros_(n + mi,1)
    I=find_((lb > - options.inf) and (abs_(lb - v) > options.dxmin))
    if not isempty_(I):
        compl[I]=max_(compl[I],max_(0,- lm[I]))
    I=find_((ub < options.inf) and (abs_(ub - v) > options.dxmin))
    if not isempty_(I):
        compl[I]=max_(compl[I],max_(0,lm[I]))
    return feas,compl,info
def ecdfo_prelim_(func=None,x0=None,lm0=None,Delta0=None,lb=None,ub=None,scaleX=None,scalefacX=None,cur_degree=None,rep_degree=None,plin=None,pdiag=None,pquad=None,c=None,initial_Y=None,kappa_ill=None,whichmodel=None,factor_FPR=None,Lambda_FP=None,Lambda_CP=None,eps_L=None,lSolver=None,hardcons=None,stratLam=None,xstatus=None,sstatus=None,dstatus=None,options=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 28-[func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options].count(None)+len(args)

    n=0
    nb=0
    mi=0
    me=0
    lm=matlabarray([])
    info.g=[]
    info.ai=[]
    info.ae=[]
    info.hl=[]
    info.niter=0
    shift_Y=1
    x=copy_(NaN)
    fx=copy_(NaN)
    gx=copy_(NaN)
    checkoptions=1
    if isempty_(options):
        checkoptions=0
    info,options,values=sqplab_options_(info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.nsimul[1:values.nsimultype]=0
    n=size_(x0,1)
    if size_(x0,2) != 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo: the initial x must be an n-vector\\n\\n'))
        info.flag=values.fail_on_argument
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if n < 1:
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo: the initial x must be an n-vector with n > 0\\n\\n'))
        info.flag=values.fail_on_argument
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if isempty_(lb):
        lb=- options.inf * ones_(n + mi,1)
    if isempty_(ub):
        ub=options.inf * ones_(n + mi,1)
    nb_lo=sum_(lb[1:n] > - options.inf)
    nb_up=sum_(ub[1:n] < options.inf)
    nb=sum_(min_((lb[1:n] > - options.inf) + (ub[1:n] < options.inf),1))
    zero=0.0
    nfix=0
    indfix=matlabarray([])
    xfix=zeros_(n,1)
    vstatus=zeros_(n,1)
    temp=zeros_(n,1)
    for j in arange_(1,n).reshape(-1):
        if (lb[j] > ub[j]):
            disp_([char('Error: Lower bound of component '),int2str_(j),char(' exceeds upper bound !!')])
            info.flag=2
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        temp[j]=ub[j] - lb[j]
        if (temp[j] < Delta0 + Delta0):
            if (temp[j] == zero):
                nfix=nfix + 1
                indfix=matlabarray([indfix,j])
                vstatus[j]=c.alwaysfixed
                xfix[j]=lb[j]
                continue
            else:
                Delta0=0.5 * temp[j]
                disp_([char(' Diff. between lower and upper bound of component '),int2str_(j),char(' is less than 2*Delta0 !! New Delta0='),num2str_(Delta0)])
        templ=lb[j] - x0[j]
        tempu=ub[j] - x0[j]
        if (templ >= - Delta0):
            x0[j]=lb[j] + Delta0
        else:
            if (tempu <= Delta0):
                x0[j]=ub[j] - Delta0
    if (scaleX):
        for i in arange_(1,n).reshape(-1):
            if (scalefacX[i] > 0):
                x0[i]=x0[i] * scalefacX[i]
                lb[i]=lb[i] * scalefacX[i]
                ub[i]=ub[i] * scalefacX[i]
            else:
                scalefacX[i]=1
    if (nfix > 0):
        nfree=n - nfix
        if (nfree <= 0):
            disp_(char('No free variables. Please, enlarge search space!'))
            info.flag=2
            return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
        indfree=setdiff_(arange_(1,n),indfix)
        x0=x0[indfree]
        if (cur_degree == plin):
            cur_degree=nfree + 1
        else:
            if (cur_degree == pdiag):
                cur_degree=2 * nfree + 1
            else:
                if (cur_degree == pquad):
                    cur_degree=((nfree + 1) * (nfree + 2)) / 2
        if (rep_degree == plin):
            rep_degree=nfree + 1
        else:
            if (rep_degree == pdiag):
                rep_degree=2 * nfree + 1
            else:
                if (rep_degree == pquad):
                    rep_degree=((nfree + 1) * (nfree + 2)) / 2
        plin=nfree + 1
        pdiag=2 * nfree + 1
        pquad=((nfree + 1) * (nfree + 2)) / 2
        n=copy_(nfree)
    else:
        indfree=arange_(1,n)
    x=copy_(x0)
    getfY=1
    while (getfY):

        if (options.verbose > 2):
            disp_([char(' Degree of the initial  model = '),int2str_(cur_degree)])
        if (strcmp_(initial_Y,char('random'))):
            Y[:,1]=x0
            ill_init=1
            while (ill_init):

                Y[:,2:cur_degree]=- ones_(n,cur_degree - 1) + 2 * rand_(n,cur_degree - 1)
                for j in arange_(2,cur_degree).reshape(-1):
                    Y[:,j]=Y[:,1] + Y[:,j] * (Delta0 / norm_(Y[:,j]))
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                if (cond_(RZ) < kappa_ill):
                    ill_init=0

            QZ,RZ,Y,replaced,poised,Y_radius,x,scale=bcdfo_repair_Y_(QZ,RZ,Y,Delta0,factor_FPR,Lambda_FP,Lambda_CP,eps_L,x,lSolver,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,1,kappa_ill,nargout=8)
            poisedness_known=1
        else:
            if (strcmp_(initial_Y,char('simplx'))):
                I=eye_(n)
                Y[:,1]=x0
                for j in arange_(1,n).reshape(-1):
                    step1=- Delta0
                    Y[:,j + 1]=x0 + step1 * I[:,j]
                    if (cur_degree >= pdiag):
                        step2=copy_(Delta0)
                        Y[:,j + 1 + n]=x0 + step2 * I[:,j]
                if (cur_degree == pquad):
                    k=2 * n + 2
                    for j in arange_(1,n).reshape(-1):
                        for jj in arange_(j + 1,n).reshape(-1):
                            Y[:,k]=0.5 * (Y[:,j + 1] + Y[:,jj + 1])
                            k=k + 1
                QZ,RZ,x,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta0,1,kappa_ill,nargout=4)
                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,x,1,whichmodel,hardcons,lb,ub,indfree,stratLam,scale,shift_Y,nargout=2)
                poisedness_known=1
        poised_model=1
        X=matlabarray([])
        fX=matlabarray([])
        ciX=matlabarray([])
        ceX=matlabarray([])
        ind_Y=matlabarray([])
        for i in arange_(1,cur_degree).reshape(-1):
            X,fX,ciX,ceX,neval,xstatus,sstatus,dstatus,info=ecdfo_augmX_evalf_(func,Y[:,i],i,X,fX,ciX,ceX,nfix,xfix,indfix,indfree,1e+25,info.nsimul(2),xstatus,c.inY,sstatus,dstatus,scaleX,scalefacX,info,options,values,nargout=9)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if (abs_(fX[i]) > 1e+25):
                break
            if (i == cur_degree):
                getfY=0
            ind_Y=matlabarray([ind_Y,i])
        fY=copy_(fX)
        ciY=copy_(ciX)
        ceY=copy_(ceX)
        xstatus=xstatus.T
        dstatus=dstatus.T
        if (getfY):
            Delta0=gamma1 * Delta0
            if (Delta0 < stallfact * norm_(x0)):
                disp_(char('Error: cannot find enough finite objective function values'),char('in the neighbourhood of the starting point! Terminating.'))
                if (nfix > 0):
                    I=eye_(n + nfix)
                    x=I[:,indfix] * xl_(indfix) + I[:,indfree] * x
                    gx=I[:,indfix] * zeros_(nfix,1) + I[:,indfree] * gx
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values

    fx0=fY[1]
    info.f=fx0
    m=copy_(cur_degree)
    i_xbest=1
    initmodel=zeros_(1,pquad)
    rhsY=matlabarray([[fY],[ciY],[ceY]])
    fcmodel=bcdfo_computeP_(QZ,RZ,Y,rhsY,whichmodel,initmodel,ind_Y,0,0,gx,scale,shift_Y,Delta0)
    gx=bcdfo_gradP_(fcmodel[1,:],x,x,scale,shift_Y)
    normgx=bcdfo_projgrad_(n,x,gx,lb[indfree],ub[indfree])
    if any_(size_(gx) != [n,1]):
        if options.verbose:
            fprintf_(options.fout,char('### ecdfo: the computed gradient g has a wrong size, (%0i,%0i) instead of (%0i,1)\\n\\n'),size_(gx),n)
        info.flag=values.fail_on_simul
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    info.g=gx
    mi=size_(ciY,1)
    if mi > 0:
        info.ci=ciY[:,1]
        gci=zeros_(mi,n)
        for i in arange_(1,mi).reshape(-1):
            gci[i,:]=bcdfo_gradP_(fcmodel[1 + i,:],x,x,scale,shift_Y).T
        info.ai=gci
    else:
        info.ci=[]
        info.ai=[]
    me=size_(ceY,1)
    if me > 0:
        info.ce=ceY[:,1]
        gce=zeros_(me,n)
        for i in arange_(1,me).reshape(-1):
            gce[i,:]=bcdfo_gradP_(fcmodel[1 + mi + i,:],x,x,scale,shift_Y).T
        info.ae=gce
    else:
        info.ce=[]
        info.ae=[]
    fprintf_(char('\\n'))
    fprintf_(char('**************************************************************************************\\n'))
    fprintf_(char('*                                                                                    *\\n'))
    fprintf_(char('*            EC-DFO: equality-constrained minimization without derivatives           *\\n'))
    fprintf_(char('*                                                                                    *\\n'))
    fprintf_(char('*                            (c)  A. Troeltzsch, 2013                                *\\n'))
    fprintf_(char('*                                                                                    *\\n'))
    fprintf_(char('**************************************************************************************\\n'))
    fprintf_(char('\\n'))
    values.dline=char('-------------------------------------------')
    values.dline=strcat_(values.dline,values.dline)
    values.eline=char('===========================================')
    values.eline=strcat_(values.eline,values.eline)
    values.sline=char('*******************************************')
    values.sline=strcat_(values.sline,values.sline)
    if options.verbose < 4:
        fprintf_(options.fout,char('iter neval        fval            merit      '))
        if (nb + mi + me > 0):
            fprintf_(options.fout,char(' |grad Lag|   feasibility'))
        else:
            fprintf_(options.fout,char('gradient'))
        fprintf_(options.fout,char('     delta    stepsize'))
        if options.algo_method == values.quasi_newton:
            fprintf_(options.fout,char('  BFGS\\n'))
        else:
            fprintf_(options.fout,char('  \\n'))
        fprintf_(options.fout,char('  \\n'))
    if options.verbose >= 4:
        fprintf_(options.fout,char('%s'),values.sline)
        fprintf_(options.fout,char('ecdfo optimization solver (Version 0.4.4, February 2009, entry point)\\n\\n'))
        if isa_(func,char('function_handle')):
            func_name=func2str_(func)
        else:
            func_name=copy_(func)
        fprintf_(options.fout,char('  name: "%s"\\n'),func_name)
        fprintf_(options.fout,char('  dimensions:\\n'))
        fprintf_(options.fout,char('  . variables (n):               %4i\\n'),n)
        if nb > 0:
            fprintf_(options.fout,char('  . bounds on variables (nb):    %4i (%0i lower, %0i double, %0i upper)\\n'),nb,nb_lo,nb_up)
        if mi > 0:
            fprintf_(options.fout,char('  . inequality constraints (mi): %4i\\n'),mi)
        if me > 0:
            fprintf_(options.fout,char('  . equality constraints (me):   %4i\\n'),me)
        fprintf_(options.fout,char('  required tolerances for optimality:\\n'))
        if nb + mi + me > 0:
            fprintf_(options.fout,char('  . gradient of the Lagrangian      %8.2e\\n'),options.tol(1))
            fprintf_(options.fout,char('  . feasibility                     %8.2e\\n'),options.tol(2))
            if nb + mi > 0:
                fprintf_(options.fout,char('  . complementarity                 %8.2e\\n'),options.tol(3))
        else:
            fprintf_(options.fout,char('  . gradient of the cost function   %8.2e\\n'),options.tol(1))
        fprintf_(options.fout,char('  counters:\\n'))
        fprintf_(options.fout,char('  . max iterations                  %4i\\n'),options.miter)
        fprintf_(options.fout,char('  . max function evaluations        %4i\\n'),options.msimul)
        fprintf_(options.fout,char('  algorithm:\\n'))
        if values.newton == options.algo_method:
            fprintf_(options.fout,char('  . Newton method\\n'))
        else:
            if values.quasi_newton == options.algo_method:
                fprintf_(options.fout,char('  . quasi-Newton method\\n'))
            else:
                if values.cheap_quasi_newton == options.algo_method:
                    fprintf_(options.fout,char('  . cheap quasi-Newton method\\n'))
        if values.unit_stepsize == options.algo_globalization:
            fprintf_(options.fout,char('  . unit step-size\\n'))
        else:
            if values.linesearch == options.algo_globalization:
                if options.algo_method == values.newton:
                    fprintf_(options.fout,char("  . globalization by Armijo's linesearch\\n"))
                else:
                    if options.algo_method == values.quasi_newton:
                        if isfield_(options,char('algo_descent')):
                            if options.algo_descent == values.powell:
                                fprintf_(options.fout,char("  . globalization by Armijo's linesearch (descent ensured by Powell corrections)\\n"))
                            else:
                                if options.algo_descent == values.wolfe:
                                    if nb + mi + me == 0:
                                        fprintf_(options.fout,char("  . globalization by Wolfe's linesearch\\n"))
                        else:
                            fprintf_(options.fout,char("  . globalization by Armijo's linesearch\\n"))
            else:
                if values.trust_regions == options.algo_globalization:
                    fprintf_(options.fout,char('  . globalization by trust regions\\n'))
        fprintf_(options.fout,char('  various input/initial values:\\n'))
        if (options.algo_method == values.quasi_newton) and (nb + mi + me == 0) and (options.df1 > 0) and (info.f > 0):
            fprintf_(options.fout,char('  . expected initial decrease       %8.2e\\n'),options.df1 * info.f)
        if nb + mi > 0:
            fprintf_(options.fout,char('  . infinite bound threshold        %8.2e\\n'),options.inf)
        fprintf_(options.fout,char('  . |x|_2                           %8.2e\\n'),norm_(x))
    if (nb + mi + me > 0):
        if isempty_(lm0):
            lm,info=sqplab_lsmult_(x,[],[],info,options,values,nargout=2)
            if info.flag:
                return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
            if options.verbose >= 4:
                fprintf_(options.fout,char('  . |lm|_2                          %8.2e (default: least-squares value)\\n'),norm_(lm))
        else:
            lm=copy_(lm0)
            if options.verbose >= 4:
                fprintf_(options.fout,char('  . |lm|_2                          %8.2e\\n'),norm_(lm))
    feas,compl,info=ecdfo_optimality_(x,lm,lb[indfree],ub[indfree],info,options,nargout=3)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    if options.verbose >= 4:
        fprintf_(options.fout,char('  . |g|_inf                         %8.2e\\n'),norm_(info.g,inf))
        if nb + mi + me > 0:
            fprintf_(options.fout,char('  . |glag|_inf                      %8.2e\\n'),norm_(info.glag,inf))
        if nb:
            fprintf_(options.fout,char('  . |x^#|_inf                       %8.2e\\n'),norm_(feas[1:n],inf))
        if mi:
            fprintf_(options.fout,char('  . |ci^#|_inf                      %8.2e\\n'),norm_(feas[n + 1:n + mi],inf))
        if me:
            fprintf_(options.fout,char('  . |ce|_inf                        %8.2e\\n'),norm_(feas[n + mi + 1:n + mi + me],inf))
        if nb + mi > 0:
            fprintf_(options.fout,char('  . |complementarity|_inf           %8.2e\\n'),norm_(compl,inf))
        fprintf_(options.fout,char('  tunings:\\n'))
        fprintf_(options.fout,char('  . printing level                  %0i\\n'),options.verbose)
    info,options=sqplab_checkoptions_(nb,mi,me,0,info,options,values,nargout=2)
    if info.flag:
        return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
    return n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta0,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values
def ecdfo_solve_TR_bc_(simul=None,x=None,lb=None,ub=None,delta=None,mi=None,me=None,M=None,prec_r=None,prec_t=None,info=None,options=None,values=None,radius_has_been_rejected=None,lm=None,ceY=None,ciY=None,gx=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 18-[simul,x,lb,ub,delta,mi,me,M,prec_r,prec_t,info,options,values,radius_has_been_rejected,lm,ceY,ciY,gx].count(None)+len(args)

    global threshold
    lm_computed=0
    n=length_(x)
    I=eye_(n)
    xi=1.0
    xnew=copy_(x)
    active_r=0
    active_t=0
    rpred=0
    norm_r=0
    x_fix=matlabarray([])
    glocal=copy_(gx)
    delta_min=1e-08
    plevel_r=0
    if options.verbose >= 5:
        plevel_r=1
    plevel_t=0
    if options.verbose >= 5:
        plevel_t=1
    if me + mi == 0:
        lb_r=lb[1:n] - x
        ub_r=ub[1:n] - x
        stratLam=1
        s,_lambda,norms,value,gplus,nfact,neigd,msg=bcdfo_solve_TR_MS_bc_(glocal,M,lb_r,ub_r,delta,1e-07,stratLam,nargout=8)
        xnew=x + s
        rpred=0
        active_r=0
        if norm_(s) < delta:
            active_t=0
        else:
            active_t=1
        return xnew,delta,rpred,active_r,active_t,lm_computed,lm,info
    constraints=info.ce
    gconstraints=info.ae
    x_active=zeros_(size_(x))
    look_for_active_bounds=1
    if look_for_active_bounds == 1:
        gradlag=copy_(glocal)
        bounds=(abs_(lb - x) < 1e-05) + (abs_(ub - x) < 1e-05)
        A=find_(bounds[1:n])
        gradlag[A]=gradlag[A] + lm[A]
        if me > 0:
            gradlag=gradlag + info.ae.T * lm[n + mi + 1:n + mi + me]
        for i in arange_(1,n).reshape(-1):
            if (x[i] - gradlag[i] <= lb[i]) and (abs_(x[i] - lb[i]) < 1e-05):
                x_active[i]=1
                if options.verbose >= 3:
                    disp_([char('lb '),num2str_(i),char(' is initially active')])
                constraints=matlabarray([[constraints],[0]])
                gconstraints=matlabarray([[gconstraints],[I[i,:]]])
            if (x[i] - gradlag[i] >= ub[i]) and (abs_(x[i] - ub[i]) < 1e-05):
                x_active[i]=1
                if options.verbose >= 3:
                    disp_([char('ub '),num2str_(i),char(' is initially active')])
                constraints=matlabarray([[constraints],[0]])
                gconstraints=matlabarray([[gconstraints],[I[i,:]]])
        if options.verbose >= 3 and sum_(x_active) > 0:
            xactive=x_active.T
    finished=0
    iter_active=0
    while finished == 0:

        iter_active=iter_active + 1
        if options.verbose >= 3:
            disp_([char('********* Loop over active set ********* iteration '),num2str_(iter_active),char(' *********')])
        if options.verbose >= 3:
            fprintf_(options.fout,char('  Restoration step:\\n'))
        delta_r=xi * delta
        sol=gconstraints.T * constraints
        if iter_active == 1 and norm_(sol) > 1e-14:
            g1=gconstraints.T * constraints
            H1=gconstraints.T * gconstraints
            check_condition=0
            if check_condition:
                cthreshold=1e+16
                H1,badcond=ecdfo_check_cond_(H1,cthreshold,options,nargout=2)
            check_convex=1
            if check_convex:
                H1=ecdfo_check_convex_(H1,options)
            lb_r=lb[1:n] - x
            ub_r=ub[1:n] - x
            stratLam=1
            r,_lambda,norms,value,gplus,nfact,neigd,msg=bcdfo_solve_TR_MS_bc_(g1,H1,lb_r,ub_r,delta_r,prec_r,stratLam,nargout=8)
            info_r.prec=sqrt_(gplus.T * gplus)
            xr=x + r
            norm2_r=r.T * r
            norm_r=sqrt_(norm2_r)
            if strcmp_(msg[1:5],char('error')) or strcmp_(msg[1:5],char('limit')):
                info_r.flag=- 1
            else:
                if strcmp_(msg[1:8],char('boundary')) or (delta_r - norm_r < 1e-08):
                    info_r.flag=1
                else:
                    info_r.flag=0
            rpred_m=norm_(constraints) - norm_(constraints + gconstraints * r)
            rpred=rpred + rpred_m
            if rpred < 0:
                if options.verbose >= 3:
                    fprintf_(options.fout,char('\\n### ecdfo_solve_TR_bc: rpred = %9.2e should not be negative\\n\\n'),rpred)
            active_r=(info_r.flag == 1) or (info_r.flag == 2)
            if options.verbose >= 5:
                if - 1 == info_r.flag:
                    fprintf_(options.fout,char('    max of %0i iterations reached\\n'),20 * me)
                else:
                    if 0 == info_r.flag:
                        fprintf_(options.fout,char('    precision is less than required tolerance %8.2e\\n'),prec_r)
                    else:
                        if 1 == info_r.flag:
                            fprintf_(options.fout,char('    TR boundary is reached\\n'))
                        else:
                            if 2 == info_r.flag:
                                fprintf_(options.fout,char('    negative curvature direction encountered\\n'))
                fprintf_(options.fout,char('    |r|   = %8.2e\\n'),norm_r)
                fprintf_(options.fout,char('    rpred = %8.2e\\n'),rpred)
        else:
            if options.verbose >= 5:
                fprintf_(options.fout,char('    unchanged\\n'))
            r=zeros_(size_(x))
            active_r=copy_(false)
            xr=copy_(x)
            norm2_r=0.0
            norm_r=0.0
        if options.verbose == 3:
            disp_([char('r = ('),num2str_(r.T),char(')')])
            disp_([char('delta_r = '),num2str_(delta_r),char(', norm_r = '),num2str_(norm_r)])
        if options.verbose >= 3:
            fprintf_(options.fout,char('  Tangent step:\\n'))
        delta_t=copy_(delta)
        deg_freedom=n - length_(constraints)
        if deg_freedom > 0:
            Z_=null_(full_(gconstraints))
            M_t=Z_.T * M * Z_
            g_t=Z_.T * (glocal + M * r)
            u,info_t=sqplab_tcg_(M_t,- g_t,delta_t,20 * (n - me),prec_t,plevel_t,options.fout,nargout=2)
            t=Z_ * u
            active_t=(info_t.flag == 1) or (info_t.flag == 2)
            if options.verbose >= 5:
                if - 1 == info_t.flag:
                    fprintf_(options.fout,char('    max of %0i iterations reached\\n'),20 * (n - me))
                else:
                    if 0 == info_t.flag:
                        fprintf_(options.fout,char('    precision is less than required tolerance %8.2e\\n'),prec_t)
                    else:
                        if 1 == info_t.flag:
                            fprintf_(options.fout,char('    TR boundary is reached\\n'))
                        else:
                            if 2 == info_t.flag:
                                fprintf_(options.fout,char('    negative curvature direction encountered\\n'))
                fprintf_(options.fout,char('    |t| = %8.2e\\n'),norm_(t))
        else:
            t=zeros_(1,n).T
            active_t=0
        if options.verbose == 3:
            disp_([char('t = ('),num2str_(t.T),char(')')])
            disp_([char('delta_t = '),num2str_(delta_t),char(', norm_t = '),num2str_(norm_(t))])
            disp_([char('delta '),num2str_(delta),char(', norm_s = '),num2str_(norm_(r + t))])
        xnew=x + r + t
        x_active=zeros_(size_(xnew))
        x_viol=zeros_(size_(xnew))
        for i in arange_(1,n).reshape(-1):
            if (xnew[i] - lb[i] < - threshold):
                x_viol[i]=- i
                x_fix=matlabarray([x_fix,i])
                if options.verbose >= 3:
                    disp_([char('lb '),int2str_(i),char(' is violated')])
                constraints=matlabarray([[constraints],[0]])
                gconstraints=matlabarray([[gconstraints],[I[i,:]]])
                violated=1
                break
            else:
                if (abs_(xnew[i] - lb[i]) < 1e-07):
                    x_active[i]=- i
                    if options.verbose >= 3:
                        disp_([char('lb '),int2str_(i),char(' is active')])
                else:
                    if (xnew[i] - ub[i] > threshold):
                        x_viol[i]=i
                        x_fix=matlabarray([x_fix,i])
                        if options.verbose >= 3:
                            disp_([char('ub '),int2str_(i),char(' is violated')])
                        constraints=matlabarray([[constraints],[0]])
                        gconstraints=matlabarray([[gconstraints],[I[i,:]]])
                        violated=1
                        break
                    else:
                        if (abs_(xnew[i] - ub[i]) < 1e-07):
                            x_active[i]=i
                            if options.verbose >= 3:
                                disp_([char('ub '),int2str_(i),char(' is active')])
        if sum_(x_viol) == 0:
            violated=0
            if options.verbose >= 3:
                disp_(char('no new bound violated'))
        else:
            if options.verbose >= 3:
                disp_(x_fix)
        if norm_(r + t) <= 1e-16:
            if options.verbose >= 3 and (iter_active >= 10 * n or delta < delta_min):
                disp_(char('### ecdfo_solve_TR_bc: active-set iteration limit exceeded ###'))
                return xnew,delta,rpred,active_r,active_t,lm_computed,lm,info
            lbounds=- inf * ones_(size_(x))
            ubounds=inf * ones_(size_(x))
            ilb=abs_(lb - xnew) < 1e-05
            iub=abs_(ub - xnew) < 1e-05
            lbounds[ilb]=lb[ilb]
            ubounds[iub]=ub[iub]
            lm,info=sqplab_lsmult_(xnew,lbounds,ubounds,info,options,values,nargout=2)
            min_lm,ind_min_lm=min_(lm[x_fix],nargout=2)
            if options.verbose >= 3:
                disp_([char('smallest Lagrange multiplier (for the bounds) = '),num2str_(min_lm)])
            if min_lm < 0:
                if options.verbose >= 3:
                    disp_(char('Zero step but not converged - release one bound!!'))
                constraints=constraints[1:me]
                gconstraints=gconstraints[1:me,:]
                xa=find_(x_active < 0).T
                if length_(xa) == length_(x_fix):
                    if sort_(xa) == sort_(x_fix):
                        for i in arange_(1,length_(x_fix)).reshape(-1):
                            if i != ind_min_lm:
                                constraints=matlabarray([[constraints],[0]])
                                gconstraints=matlabarray([[gconstraints],[I[x_fix[i],:]]])
                        x_fix[ind_min_lm]=[]
                        finished=1
                    else:
                        x_fix=matlabarray([])
                        for i in arange_(1,length_(find_(x_active < 0))).reshape(-1):
                            constraints=matlabarray([[constraints],[0]])
                            gconstraints=matlabarray([[gconstraints],[I[xa[i],:]]])
                            x_fix=matlabarray([x_fix,xa[i]])
                else:
                    x_fix=matlabarray([])
                    for i in arange_(1,length_(find_(x_active < 0))).reshape(-1):
                        constraints=matlabarray([[constraints],[0]])
                        gconstraints=matlabarray([[gconstraints],[I[xa[i],:]]])
                        x_fix=matlabarray([x_fix,xa[i]])
                if options.verbose >= 3:
                    x_fix
            else:
                if options.verbose >= 3:
                    disp_(char('Zero step and converged - go back to TR-loop...'))
                finished=1
        else:
            if violated == 0:
                if options.verbose >= 3:
                    disp_(char('non zero feasible step - go back to TR-loop...'))
                finished=1
            else:
                if options.verbose >= 3:
                    disp_(char('non zero infeasible step - continue finding correct active set...'))
        if violated == 1:
            tstep=copy_(t)
            if options.verbose >= 3:
                disp_(char('shorten tangential step'))
            aT=matlabarray([[eye_(n)],[- eye_(n)]])
            aTx=aT * xr
            alpha=matlabarray([[ub[1:n]],[- lb[1:n]]])
            divisor=aT * tstep
            ratio=(alpha - aTx) / divisor
            minratio=min_(ratio[divisor > 0])
            if (minratio < 0):
                minratio=0.0
            tstep=minratio.dot(tstep)
            x=xr + tstep
            step=r + tstep
            if options.verbose == 3:
                disp_([char('t = ('),num2str_(tstep.T),char(')')])
                disp_([char('delta_t = '),num2str_(delta_t),char(', norm_t = '),num2str_(norm_(tstep))])
                disp_([char('delta '),num2str_(delta),char(', norm_s = '),num2str_(norm_(r + tstep))])
            glocal=glocal + M * step
            for i in arange_(1,me).reshape(-1):
                gconstraints[i,:]=gconstraints[i,:] + (M * step).T
            delta=delta - norm_(step)

    return xnew,delta,rpred,active_r,active_t,lm_computed,lm,info
