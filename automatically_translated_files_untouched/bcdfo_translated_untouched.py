# Autogenerated with SMOP version 
# main.py bcdfofiles/*.m

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def bcdfo_augment_Y_(Ynew=None,Y=None,whichmodel=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[Ynew,Y,whichmodel,shift_Y,Delta,normgx,kappa_ill].count(None)+len(args)

    n,p1=size_(Y,nargout=2)
    if ((p1 >= ((n + 1) * (n + 2)) / 2) and (whichmodel != 3)):
        disp_(char(' === augment_Y: warning!!! The interpolation is already fully quadratic!'))
        disp_(char('     Ignoring augmentation...'))
        QZ,RZ,xbase,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta,normgx,kappa_ill,nargout=4)
    else:
        Y=matlabarray([Y,Ynew])
        p1=p1 + size_(Ynew,2)
        QZ,RZ,xbase,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta,normgx,kappa_ill,nargout=4)
    return p1,QZ,RZ,Y,xbase,scale
def bcdfo_build_QR_of_Y_(Y=None,whichmodel=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 6-[Y,whichmodel,shift_Y,Delta,normgx,kappa_ill].count(None)+len(args)

    n,p1=size_(Y,nargout=2)
    badcond=0
    if (normgx == 0.0):
        _del=Delta ** 2 / 1e-12
    else:
        _del=Delta ** 2 / normgx
    if (_del > 0.1):
        _del=0.1
    if (_del < 1e-10):
        _del=1e-10
    if (whichmodel == 0):
        q=copy_(p1)
    else:
        q=((n + 1) * (n + 2)) / 2
    if (whichmodel == 3 and p1 < q):
        whichmodel=2
    if (shift_Y):
        xbase=Y[:,1]
        scaleY=0
        for i in arange_(1,p1).reshape(-1):
            Y[:,i]=Y[:,i] - xbase
            scaleY=max_(scaleY,norm_(Y[:,i]))
        scale=[1,scaleY ** - 1 * ones_(1,min_(n,q - 1)),scaleY ** - 2 * ones_(1,q - n - 1)].T
        Y=Y / scaleY
    else:
        scale=ones_(q,1)
        xbase=zeros_(size_(Y,1),1)
    if (whichmodel == 0):
        Z=bcdfo_evalZ_(Y,q)
        if (length_(find_(isnan_(Z))) == 0 and length_(find_(isinf_(Z))) == 0):
            condZ=cond_(Z)
            if (condZ > kappa_ill):
                badcond=1
        else:
            badcond=1
        if (badcond):
            U,S,V=svd_(Z,0,nargout=3)
            Sdiag=diag_(S)
            indices=find_(Sdiag < _del)
            Sdiag[indices]=_del
            S=diag_(Sdiag)
            M=(V * S * U.T).T
            QZ,RZ=qr_(M,nargout=2)
        else:
            QZ,RZ=qr_(Z,nargout=2)
    else:
        if (whichmodel == 1):
            if (p1 == n + 1 or p1 == q):
                F=bcdfo_evalZ_(Y,p1).T
            else:
                M=bcdfo_evalZ_(Y,q).T
                ML=M[:,1:n + 1]
                MQ=M[:,n + 2:q]
                F=matlabarray([[MQ * MQ.T,ML],[ML.T,zeros_(n + 1,n + 1)]])
            if (length_(find_(isnan_(F))) == 0 and length_(find_(isinf_(F))) == 0):
                condZ=cond_(F)
                if (condZ > kappa_ill):
                    badcond=1
            else:
                badcond=1
            if (badcond):
                U,S,V=svd_(F,0,nargout=3)
                Sdiag=diag_(S)
                indices=find_(Sdiag < _del)
                Sdiag[indices]=_del
                S=diag_(Sdiag)
                M=(V * S.T * U.T).T
                QZ,RZ=qr_(M,nargout=2)
            else:
                QZ,RZ=qr_(F,nargout=2)
        else:
            if (whichmodel == 2):
                Z=bcdfo_evalZ_(Y,q)
                if (length_(find_(isnan_(Z))) == 0 and length_(find_(isinf_(Z))) == 0):
                    condZ=cond_(Z)
                    if (condZ > kappa_ill):
                        badcond=1
                else:
                    badcond=1
                if (badcond):
                    U,S,V=svd_(Z,char('econ'),nargout=3)
                    Sdiag=diag_(S)
                    indices=find_(Sdiag < _del)
                    Sdiag[indices]=_del
                    S=diag_(Sdiag)
                    M=(V * S.T * U.T).T
                    QZ,RZ=qr_(M,nargout=2)
                else:
                    QZ,RZ=qr_(Z,nargout=2)
            else:
                if (whichmodel == 3):
                    Z=bcdfo_evalZ_(Y,q).T
                    if (length_(find_(isnan_(Z))) == 0 and length_(find_(isinf_(Z))) == 0):
                        condZ=cond_(Z)
                        if (condZ > kappa_ill):
                            badcond=1
                    else:
                        badcond=1
                    if (badcond):
                        U,S,V=svd_(Z,0,nargout=3)
                        Sdiag=diag_(S)
                        indices=find_(Sdiag < _del)
                        Sdiag[indices]=_del
                        S=diag_(Sdiag)
                        M=(V * S * U.T).T
                        QZ,RZ=qr_(M,nargout=2)
                    else:
                        QZ,RZ=qr_(Z,nargout=2)
    return QZ,RZ,xbase,scale
def bcdfo_computeLj_(QZ=None,RZ=None,j=None,Y=None,whichmodel=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[QZ,RZ,j,Y,whichmodel,scale,shift_Y].count(None)+len(args)

    n,p1=size_(Y,nargout=2)
    q=((n + 1) * (n + 2)) / 2
    if (whichmodel == 3 and p1 < q):
        whichmodel=2
    if (whichmodel == 0):
        warning_(char('off'))
        Lj=(QZ * (numpy.linalg.solve(RZ.T,[[zeros_(j - 1,1)],[1],[zeros_(p1 - j,1)]]))).T
    else:
        if (whichmodel == 1):
            if (p1 == n + 1 or p1 == q):
                warning_(char('off'))
                Lj=(numpy.linalg.solve(RZ,QZ.T) * [[zeros_(j - 1,1)],[1],[zeros_(p1 - j,1)]]).T
                if (p1 == n + 1):
                    Lj[n + 2:q]=0
            else:
                if (shift_Y):
                    xbase=Y[:,1]
                    scaleY=0
                    for i in arange_(1,p1).reshape(-1):
                        Y[:,i]=Y[:,i] - xbase
                        scaleY=max_(scaleY,norm_(Y[:,i]))
                    Y=Y / scaleY
                rhs=matlabarray([[zeros_(j - 1,1)],[1],[zeros_(p1 + n + 1 - j,1)]])
                warning_(char('off'))
                mualpha=(numpy.linalg.solve(RZ,(QZ.T * rhs))).T
                Lj[1:n + 1]=mualpha[p1 + 1:p1 + n + 1].T
                M=bcdfo_evalZ_(Y,q).T
                Lj[n + 2:q]=M[:,n + 2:q].T * mualpha[1:p1].T
        else:
            if (whichmodel == 2):
                if (p1 < q):
                    warning_(char('off'))
                    Lj=(QZ * (pinv_(RZ.T) * [[zeros_(j - 1,1)],[1],[zeros_(p1 - j,1)]])).T
                else:
                    warning_(char('off'))
                    Lj=(QZ * (numpy.linalg.solve(RZ.T,[[zeros_(j - 1,1)],[1],[zeros_(p1 - j,1)]]))).T
            else:
                if (whichmodel == 3):
                    warning_(char('off'))
                    Lj=(pinv_(RZ) * QZ.T * [[zeros_(j - 1,1)],[1],[zeros_(p1 - j,1)]]).T
    return Lj
def bcdfo_computeP_(QZ=None,RZ=None,Y=None,fY=None,whichmodel=None,P_old=None,ind_Y=None,i_xold=None,i_xplus=None,g=None,scale=None,shift_Y=None,Delta0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 13-[QZ,RZ,Y,fY,whichmodel,P_old,ind_Y,i_xold,i_xplus,g,scale,shift_Y,Delta0].count(None)+len(args)

    n,p1=size_(Y,nargout=2)
    badcond=0
    q=((n + 1) * (n + 2)) / 2
    if (whichmodel == 3 and p1 < q):
        whichmodel=2
    if (whichmodel == 0):
        warning_(char('off'))
        P=(QZ * (numpy.linalg.solve(RZ.T,fY.T))).T
    else:
        if (whichmodel == 1):
            n_rhs=size_(fY,1)
            if (p1 == n + 1 or p1 == q):
                P[1:n_rhs,1:p1]=(numpy.linalg.solve(RZ,(QZ.T * fY.T))).T
                if (p1 == n + 1):
                    P[1:n_rhs,n + 2:q]=0.0
            else:
                if (shift_Y):
                    xbase=Y[:,1]
                    scaleY=0
                    for i in arange_(1,p1).reshape(-1):
                        Y[:,i]=Y[:,i] - xbase
                        scaleY=max_(scaleY,norm_(Y[:,i]))
                    Y=Y / scaleY
                P=matlabarray([])
                for i in arange_(1,n_rhs).reshape(-1):
                    rhs=matlabarray([fY[i,:],zeros_(1,n + 1)])
                    mualpha=(numpy.linalg.solve(RZ,(QZ.T * rhs.T))).T
                    P_i[1:n + 1]=mualpha[p1 + 1:p1 + n + 1].T
                    M=bcdfo_evalZ_(Y,q).T
                    P_i[n + 2:q]=M[:,n + 2:q].T * mualpha[1:p1].T
                    P=matlabarray([[P],[P_i]])
        else:
            if (whichmodel == 2):
                warning_(char('off'))
                P=(QZ * (numpy.linalg.solve(RZ.T,fY.T))).T
            else:
                if (whichmodel == 3):
                    warning_(char('off'))
                    P=(pinv_(RZ) * QZ.T * fY.T).T
    return P
def bcdfo_evalL_(QZ=None,RZ=None,Y=None,choice_set=None,x=None,xbase=None,whichmodel=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 9-[QZ,RZ,Y,choice_set,x,xbase,whichmodel,scale,shift_Y].count(None)+len(args)

    n,p1=size_(Y,nargout=2)
    I=eye_(p1)
    lc=length_(choice_set)
    q=((n + 1) * (n + 2)) / 2
    if (whichmodel == 3 and p1 < q):
        whichmodel=2
    if (whichmodel == 0):
        warning_(char('off'))
        values[choice_set]=bcdfo_evalP_(I[choice_set,:] * (numpy.linalg.solve(RZ,QZ.T)),x,xbase,scale,shift_Y)
    else:
        if (whichmodel == 1):
            if (p1 == n + 1 or p1 == q):
                warning_(char('off'))
                values[choice_set]=bcdfo_evalP_(I[choice_set,:] * (QZ / RZ.T),x,xbase,scale,shift_Y)
            else:
                if (shift_Y):
                    xbase=Y[:,1]
                    scaleY=0
                    for i in arange_(1,p1).reshape(-1):
                        Y[:,i]=Y[:,i] - xbase
                        scaleY=max_(scaleY,norm_(Y[:,i]))
                    Y=Y / scaleY
                M=bcdfo_evalZ_(Y,q).T
                MQ=M[:,n + 2:q]
                if (shift_Y):
                    phi=bcdfo_evalZ_((x - xbase) * scale[2],q)
                else:
                    phi=bcdfo_evalZ_(x,q)
                warning_(char('off'))
                values[choice_set]=[I[choice_set,:],zeros_(lc,n + 1)] * (QZ * (numpy.linalg.solve(RZ.T,[[MQ * phi[n + 2:q]],[phi[1:n + 1]]])))
        else:
            if (whichmodel == 2):
                if (p1 < q):
                    warning_(char('off'))
                    values[choice_set]=bcdfo_evalP_(I[choice_set,:] * (pinv_(RZ) * QZ.T),x,xbase,scale,shift_Y)
                else:
                    warning_(char('off'))
                    values[choice_set]=bcdfo_evalP_(I[choice_set,:] * (numpy.linalg.solve(RZ,QZ.T)),x,xbase,scale,shift_Y)
            else:
                if (whichmodel == 3):
                    warning_(char('off'))
                    values[choice_set]=bcdfo_evalP_(I[choice_set,:] * (QZ * pinv_(RZ.T)),x,xbase,scale,shift_Y)
    return values
def bcdfo_evalP_(P=None,x=None,xbase=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[P,x,xbase,scale,shift_Y].count(None)+len(args)

    if (shift_Y):
        value=P * bcdfo_evalZ_((x - xbase) * scale[2],size_(P,2))
    else:
        value=P * bcdfo_evalZ_(x,size_(P,2))
    return value
def bcdfo_evalZ_(X=None,q=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[X,q].count(None)+len(args)

    n,m=size_(X,nargout=2)
    nlin=min_(n + 1,q)
    nquad=max_(0,q - nlin)
    nlin=nlin - 1
    Z=zeros_(q,m)
    if (q == 1):
        Z=ones_(1,m)
    else:
        if (q <= n + 1):
            Z=matlabarray([[ones_(1,m)],[X[1:nlin,1:m]]])
        else:
            ndiag=min_(n,nquad)
            Z=matlabarray([[ones_(1,m)],[X[1:n,1:m]],[0.5 * X[1:ndiag,1:m] ** 2]])
            nquad=nquad - ndiag
            if (nquad > 0):
                for k in arange_(1,n - 1).reshape(-1):
                    nsd=min_(n - k,nquad)
                    if (nsd > 0):
                        Z=matlabarray([[Z],[X[k + 1:k + nsd,1:m].dot(X[1:nsd,1:m])]])
                        nquad=nquad - nsd
                    if (nquad == 0):
                        break
    return Z
def bcdfo_find_new_yj_(QZ=None,RZ=None,Y=None,j=None,Delta=None,eps_L=None,xbase=None,lSolver=None,whichmodel=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 11-[QZ,RZ,Y,j,Delta,eps_L,xbase,lSolver,whichmodel,scale,shift_Y].count(None)+len(args)

    verbose=0
    n=size_(Y,1)
    ynew=zeros_(1,n)
    improvement=0
    if (verbose):
        disp_(char('--------- enter find_new_yj '))
    if (j < 2):
        return ynew,improvement,msgTR
    Lj=bcdfo_computeLj_(QZ,RZ,j,Y,whichmodel,scale,shift_Y)
    if (length_(find_(isnan_(Lj))) != 0 or length_(find_(not isreal_(Lj))) != 0 or length_(find_(isinf_(Lj))) != 0):
        msgTR=char('Error0: Lagrange polynomial contains NaN or Inf or nonreal components!!')
        if (verbose):
            disp_(msgTR)
        return ynew,improvement,msgTR
    if (lSolver == 2):
        Delta=sqrt_(n) * Delta
    if (shift_Y):
        g=bcdfo_gradP_(Lj,zeros_(n,1),xbase,scale,0)
        H=bcdfo_hessP_(Lj,zeros_(n,1),xbase,scale,0)
        pstep,_lambda,norms,pvalue,gplus,nfact,neigd,msgTR=bcdfo_solve_TR_MS_(g,H,Delta * scale[2],eps_L,nargout=8)
        pstep=pstep / scale[2]
        mstep,_lambda,norms,mvalue,gplus,nfact,neigd,msgTR=bcdfo_solve_TR_MS_(- g,- H,Delta * scale[2],eps_L,nargout=8)
        mstep=mstep / scale[2]
    else:
        g=bcdfo_gradP_(Lj,Y[:,1],xbase,scale,0)
        H=bcdfo_hessP_(Lj,Y[:,1],xbase,scale,0)
        pstep,_lambda,norms,pvalue,gplus,nfact,neigd,msgTR=bcdfo_solve_TR_MS_(g,H,Delta,eps_L,nargout=8)
        mstep,_lambda,norms,mvalue,gplus,nfact,neigd,msgTR=bcdfo_solve_TR_MS_(- g,- H,Delta,eps_L,nargout=8)
    if (verbose):
        disp_([char(' === find_new_yj: j = '),int2str_(j),char(' positive value = '),num2str_(pvalue),char(' step:')])
        pstep.T
        disp_([char(' === find_new_yj: j = '),int2str_(j),char(' negative value = '),num2str_(mvalue),char(' step:')])
        mstep.T
    if (mvalue < pvalue):
        improvement=abs_(mvalue)
        ynew=Y[:,1] + mstep
    else:
        improvement=abs_(pvalue)
        ynew=Y[:,1] + pstep
    if (verbose):
        disp_(char('--------- exit find_new_yj '))
    return ynew,improvement,msgTR
def bcdfo_gradP_(P=None,x=None,xbase=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[P,x,xbase,scale,shift_Y].count(None)+len(args)

    n=length_(x)
    p1=length_(P)
    if (shift_Y):
        P=P.dot(scale.T)
        x=x - xbase
    ng=min_(n,p1 - 1)
    g=zeros_(n,1)
    g[1:ng]=P[2:ng + 1]
    nquad=p1 - n - 1
    if (nquad > 0):
        ndiag=min_(nquad,n)
        g[1:ndiag]=g[1:ndiag] + P[n + 2:n + 1 + ndiag].T.dot(x[1:ndiag])
        nquad=nquad - ndiag
        if (nquad > 0):
            k=2 * n + 1
            for i in arange_(1,n - 1).reshape(-1):
                nsd=min_(n - i,nquad)
                if (nsd > 0):
                    g[i + 1:i + nsd]=g[i + 1:i + nsd] + P[k + 1:k + nsd].T.dot(x[1:nsd])
                    g[1:nsd]=g[1:nsd] + P[k + 1:k + nsd].T.dot(x[i + 1:i + nsd])
                    k=k + nsd
                    nquad=nquad - nsd
                if (nquad == 0):
                    break
    return g
def bcdfo_hessP_(P=None,x=None,xbase=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[P,x,xbase,scale,shift_Y].count(None)+len(args)

    n=length_(x)
    p1=length_(P)
    nquad=p1 - n - 1
    if (shift_Y):
        P=P.dot(scale.T)
        x=x - xbase
    if (nquad > 0):
        ndiag=min_(nquad,n)
        H=diag_([P[n + 2:n + 1 + ndiag],zeros_(1,n - ndiag)])
        nquad=nquad - ndiag
        if (nquad > 0):
            k=2 * n + 1
            for i in arange_(1,n - 1).reshape(-1):
                nsd=min_(n - i,nquad)
                if (nsd > 0):
                    for j in arange_(1,nsd).reshape(-1):
                        H[i + j,j]=P[k + j]
                        H[j,i + j]=P[k + j]
                    k=k + nsd
                    nquad=nquad - nsd
                if (nquad == 0):
                    break
    else:
        H=zeros_(n,n)
    return H
def bcdfo_include_in_Y_(x=None,QZ=None,RZ=None,Y=None,choice_set=None,poisedness_threshold=None,criterion=None,xbase=None,whichmodel=None,succ=None,scale=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 15-[x,QZ,RZ,Y,choice_set,poisedness_threshold,criterion,xbase,whichmodel,succ,scale,shift_Y,Delta,normgx,kappa_ill].count(None)+len(args)

    if (length_(choice_set) == 0):
        pos=0
        return QZ,RZ,Y,pos,xbase,scale
    Lvals=bcdfo_evalL_(QZ,RZ,Y,choice_set,x,xbase,whichmodel,scale,shift_Y)
    choice=find_(abs_(Lvals) > poisedness_threshold)
    lc=length_(choice)
    if (lc == 0):
        pos=0
        return QZ,RZ,Y,pos,xbase,scale
    crit_val=0
    pos=0
    for i in arange_(1,lc).reshape(-1):
        j=choice[i]
        if (criterion == char('weighted')):
            if (succ == 1):
                cv=norm_(Y[:,j] - x) ** 2 * abs_(Lvals[j])
            else:
                cv=norm_(Y[:,j] - Y[:,1]) ** 2 * abs_(Lvals[j])
        else:
            if (criterion == char('standard')):
                cv=abs_(Lvals[j])
            else:
                if (criterion == char('distance')):
                    if (succ == 1):
                        cv=norm_(Y[:,j] - x)
                    else:
                        cv=norm_(Y[:,j] - Y[:,1])
        if (cv > crit_val):
            pos=copy_(j)
            crit_val=copy_(cv)
    if (pos == 0):
        return QZ,RZ,Y,pos,xbase,scale
    QZ,RZ,Y,xbase,scale=bcdfo_replace_in_Y_(QZ,RZ,x,Y,pos,xbase,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,nargout=5)
    return QZ,RZ,Y,pos,xbase,scale
def bcdfo_poisedness_Y_(QZ=None,RZ=None,Y=None,eps_L=None,xbase=None,lSolver=None,whichmodel=None,hardcons=None,xl=None,xu=None,indfree=None,stratLam=None,scale=None,shift_Y=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 14-[QZ,RZ,Y,eps_L,xbase,lSolver,whichmodel,hardcons,xl,xu,indfree,stratLam,scale,shift_Y].count(None)+len(args)

    _lambda=0
    n,p1=size_(Y,nargout=2)
    Y_radius=0
    for j in arange_(2,p1).reshape(-1):
        Y_radius=max_(Y_radius,norm_(Y[:,j] - Y[:,1]))
    for j in arange_(2,p1).reshape(-1):
        if (hardcons == 1):
            y,improvement=bcdfo_find_new_yj_bc_(QZ,RZ,Y,j,Y_radius,eps_L,xbase,lSolver,whichmodel,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
        else:
            y,improvement=bcdfo_find_new_yj_(QZ,RZ,Y,j,Y_radius,eps_L,xbase,lSolver,whichmodel,scale,shift_Y,nargout=2)
        _lambda=max_(improvement,_lambda)
    return _lambda,Y_radius
def bcdfo_projgrad_(n=None,x=None,g=None,bl=None,bu=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[n,x,g,bl,bu].count(None)+len(args)

    gnorm=0.0
    for i in arange_(1,n).reshape(-1):
        gi=g[i]
        if gi < 0.0:
            gn[i]=- min_(abs_(bu[i] - x[i]),- gi)
        else:
            gn[i]=min_(abs_(bl[i] - x[i]),gi)
        gnorm=max_(gnorm,abs_(gn[i]))
    return gnorm,gn
def bcdfo_repair_Y_(QZ=None,RZ=None,Y=None,Delta=None,farfact=None,farthr=None,closethr=None,eps_L=None,xbase=None,lSolver=None,whichmodel=None,hardcons=None,xl=None,xu=None,indfree=None,stratLam=None,scale=None,shift_Y=None,normgx=None,kappa_ill=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 20-[QZ,RZ,Y,Delta,farfact,farthr,closethr,eps_L,xbase,lSolver,whichmodel,hardcons,xl,xu,indfree,stratLam,scale,shift_Y,normgx,kappa_ill].count(None)+len(args)

    verbose=0
    max_improve_loops=20
    if (verbose):
        disp_([char('--- enter bcdfo_repair_Y  for Delta = '),num2str_(Delta),char(' ---')])
    n,p1=size_(Y,nargout=2)
    replaced=matlabarray([])
    d=zeros_(1,p1)
    for j in arange_(2,p1).reshape(-1):
        d[j]=norm_(Y[:,j] - Y[:,1])
    dsorted,jsorted=sort_(d,char('descend'),nargout=2)
    if (verbose):
        d
        dsorted
        jsorted
    for j in arange_(1,p1).reshape(-1):
        if (dsorted[j] > farfact * (1 + eps_L) * Delta):
            jmax=jsorted[j]
            if (hardcons == 1):
                y,improvement=bcdfo_find_new_yj_bc_(QZ,RZ,Y,jmax,Delta,eps_L,xbase,lSolver,whichmodel,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
            else:
                y,improvement=bcdfo_find_new_yj_(QZ,RZ,Y,jmax,Delta,eps_L,xbase,lSolver,whichmodel,scale,shift_Y,nargout=2)
            if (verbose):
                disp_([char('lambda = '),num2str_(improvement),char(' at j='),num2str_(jmax)])
            QZ,RZ,Y,xbase,scale=bcdfo_replace_in_Y_(QZ,RZ,y,Y,jmax,xbase,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,nargout=5)
            replaced=matlabarray([replaced,jmax])
            d[jmax]=norm_(y - Y[:,1])
        else:
            Y_radius=dsorted[j]
            break
    if (verbose):
        replaced
        poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,xbase,lSolver,whichmodel,hardcons,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
        disp_([char('after distant replace: poisedness(Y) = '),num2str_(poised),char(' Y_radius  = '),num2str_(Y_radius)])
    for k in arange_(1,max_improve_loops).reshape(-1):
        maximprove=0
        for j in arange_(2,p1).reshape(-1):
            if (hardcons == 1):
                y,improvement=bcdfo_find_new_yj_bc_(QZ,RZ,Y,j,Delta,eps_L,xbase,lSolver,whichmodel,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
            else:
                y,improvement=bcdfo_find_new_yj_(QZ,RZ,Y,j,Delta,eps_L,xbase,lSolver,whichmodel,scale,shift_Y,nargout=2)
            if (verbose > 1):
                disp_([char(' ==> j = '),int2str_(j),char(' improve = '),num2str_(improvement)])
                y
            if (improvement > maximprove):
                maximprove=copy_(improvement)
                jmax=copy_(j)
                ymax=copy_(y)
        if (maximprove < closethr or jmax == 0):
            Y_radius=max_(d)
            if (verbose):
                replaced
                disp_([char('maximprove(small)= '),num2str_(maximprove),char(', jmax= '),int2str_(jmax)])
                poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,xbase,lSolver,whichmodel,hardcons,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
                disp_([char('after everything: poisedness(Y) = '),num2str_(poised),char(' Y_radius  = '),num2str_(Y_radius)])
                disp_([char('--- exit 1 bcdfo_repair_Y in round k='),num2str_(k),char(' ---')])
            if (isempty_(replaced)):
                maximprove=0
            return QZ,RZ,Y,replaced,maximprove,Y_radius,xbase,scale
        if (verbose):
            disp_([char('maximprove= '),num2str_(maximprove),char(', jmax= '),int2str_(jmax)])
        QZ,RZ,Y,xbase,scale=bcdfo_replace_in_Y_(QZ,RZ,ymax,Y,jmax,xbase,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill,nargout=5)
        d[jmax]=norm_(ymax - Y[:,1])
        if (length_(find_(replaced == jmax)) == 0):
            replaced=matlabarray([replaced,jmax])
    Y_radius=max_(d)
    if (verbose):
        replaced
        poised,Y_radius=bcdfo_poisedness_Y_(QZ,RZ,Y,eps_L,xbase,lSolver,whichmodel,hardcons,xl,xu,indfree,stratLam,scale,shift_Y,nargout=2)
        disp_([char('after everything: poisedness(Y) = '),num2str_(poised),char(' Y_radius  = '),num2str_(Y_radius)])
        disp_([char('--- exit 2 bcdfo_repair_Y after round k='),num2str_(k),char('  ---')])
    return QZ,RZ,Y,replaced,maximprove,Y_radius,xbase,scale
def bcdfo_replace_in_Y_(QZ=None,RZ=None,ynew=None,Y=None,j=None,xbase=None,whichmodel=None,scale=None,shift_Y=None,Delta=None,normgx=None,kappa_ill=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 12-[QZ,RZ,ynew,Y,j,xbase,whichmodel,scale,shift_Y,Delta,normgx,kappa_ill].count(None)+len(args)

    Y[:,j]=ynew
    QZ,RZ,xbase,scale=bcdfo_build_QR_of_Y_(Y,whichmodel,shift_Y,Delta,normgx,kappa_ill,nargout=4)
    return QZ,RZ,Y,xbase,scale
def bcdfo_solve_TR_MS_(g=None,H=None,Delta=None,eps_D=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[g,H,Delta,eps_D].count(None)+len(args)

    verbose=0
    theta=1e-13
    epsilon=1e-12
    nitmax=300
    n=length_(g)
    s=zeros_(n,1)
    norms=0
    _lambda=0
    value=0
    gplus=copy_(g)
    nfact=0
    neigd=0
    hardcase=0
    if (verbose):
        disp_(char(' bcdfo_solve_TR_MS : ============ enter'))
    if (length_(find_(isnan_(H))) != 0):
        disp_(char(' bcdfo_solve_TR_MS : H contains NaNs!'))
        msg=char('error1')
        if (verbose):
            disp_(char(' bcdfo_solve_TR_MS : ============ error exit'))
        return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
    if (length_(find_(not isreal_(H))) != 0):
        disp_(char(' bcdfo_solve_TR_MS : H contains imaginary parts!'))
        msg=char('error2')
        if (verbose):
            disp_(char(' bcdfo_solve_TR_MS : ============ error exit'))
        return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
    if (length_(find_(isinf_(H))) != 0):
        disp_(char(' bcdfo_solve_TR_MS : H contains infinite elements!'))
        msg=char('error3')
        if (verbose):
            disp_(char(' bcdfo_solve_TR_MS : ============ error exit'))
        return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
    gnorm=norm_(g)
    goverD=gnorm / Delta
    Hnorminf=norm_(H,inf)
    if (Hnorminf > 0):
        HnormF=norm_(H,char('fro'))
    else:
        HnormF=0
    lower=max_(0,goverD - min_(Hnorminf,HnormF))
    upper=max_(0,goverD + min_(Hnorminf,HnormF))
    Dlower=(1 - eps_D) * Delta
    Dupper=(1 + eps_D) * Delta
    if Delta == 0:
        msg=char('bcdfo_solve_TR_MS : trust region is zero - exit !')
        if verbose:
            disp_(msg)
        sfound=1
        norms=norm_(s)
        _lambda=0
        return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
    if (gnorm ** 2 < epsilon):
        msg=char('zero gradient')
        if (verbose):
            disp_(char(' bcdfo_solve_TR_MS : ============ zero gradient:'))
        sfound=1
        norms=norm_(s)
        _lambda=0
        return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
    else:
        if (verbose):
            disp_(char(' bcdfo_solve_TR_MS : ============ nonzero gradient:'))
        if (lower == 0):
            _lambda=0
        else:
            _lambda=max_(sqrt_(lower * upper),lower + theta * (upper - lower))
        for i in arange_(1,nitmax).reshape(-1):
            new_lambda=- 1
            sfound=0
            if (verbose):
                disp_([char(' bcdfo_solve_TR_MS ('),int2str_(i),char('): lower = '),num2str_(lower),char(' lambda = '),num2str_(_lambda),char(' upper = '),num2str_(upper)])
            R,p=chol_(H + _lambda * eye_(n),nargout=2)
            if (length_(find_(isnan_(R))) != 0):
                H
                _lambda
                norm_(g)
                R
                p
                disp_(char(' bcdfo_solve_TR_MS : NaNs in Cholesky factorization'))
                msg=char('error4')
                if (verbose):
                    disp_(char(' bcdfo_solve_TR_MS : ============ error exit'))
                return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
            nfact=nfact + 1
            if (p == 0):
                warning_(char('off'))
                s=numpy.linalg.solve(- R,(numpy.linalg.solve(R.T,g)))
                sfound=1
                norms=norm_(s)
                if (verbose):
                    disp_([char(' bcdfo_solve_TR_MS ('),int2str_(i),char('): ||s|| = '),num2str_(norms),char(' Delta  = '),num2str_(Delta)])
                if ((_lambda <= epsilon and norms <= Dupper) or (norms >= Dlower and norms <= Dupper)):
                    w=H * s
                    value=g.T * s + 0.5 * s.T * w
                    gplus=g + w
                    norms=norm_(s)
                    if (norms < (1 - eps_D) * Delta):
                        msg=char('interior solution')
                    else:
                        msg=char('boundary solution')
                    if (verbose):
                        disp_(char(' bcdfo_solve_TR_MS : ============ successful exit'))
                    return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
                warning_(char('off'))
                w=numpy.linalg.solve(R.T,s)
                normw2=w.T * w
                new_lambda=_lambda + ((norms - Delta) / Delta) * (norms ** 2 / normw2)
                if (norms > Dupper):
                    lower=copy_(_lambda)
                else:
                    upper=copy_(_lambda)
                theta_range=theta * (upper - lower)
                if (new_lambda > lower + theta_range and new_lambda < upper - theta_range):
                    _lambda=copy_(new_lambda)
                else:
                    _lambda=max_(sqrt_(lower * upper),lower + theta_range)
            else:
                lower=copy_(_lambda)
                t=0.5
                _lambda=(1 - t) * lower + t * upper
            if (upper - lower < theta * max_(1,upper)):
                break
    V,D=eig_(H,nargout=2)
    neigd=neigd + 1
    mu,imu=min_(diag_(D),nargout=2)
    if (verbose):
        gamma=abs_(V[:,imu].T * g)
        disp_([char(' bcdfo_solve_TR_MS : ============ pseudo hard case: gamma = '),num2str_(gamma),char(' ||g|| = '),num2str_(norm_(g))])
    D=D - mu * eye_(n)
    maxdiag=max_(diag_(D))
    ii=find_(abs_(diag_(D)) < 1e-10 * maxdiag)
    if (length_(ii) < n and isempty_(ii) != 1):
        D[ii,ii]=0.5 * maxdiag * eye_(length_(ii))
        Dinv=inv_(D)
        Dinv[ii,ii]=0
        scri=- V * Dinv * V.T * g
        nscri=norm_(scri)
    else:
        scri=zeros_(n,1)
        nscri=0
    if (nscri <= Delta):
        root=roots_([norm_(V[:,imu]) ** 2,2 * V[:,imu].T * scri,nscri ** 2 - Delta ** 2])
        s=scri + root[1] * V[:,imu]
    else:
        s=Delta * scri / nscri
    _lambda=- mu
    if (verbose):
        disp_([char(' bcdfo_solve_TR_MS : ============ ||scri|| = '),num2str_(norm_(scri)),char(' lambda = '),num2str_(_lambda)])
    hardcase=1
    w=H * s
    value=g.T * s + 0.5 * s.T * w
    gplus=g + w
    norms=norm_(s)
    if abs_(value) <= 1e-15:
        s=zeros_(size_(s))
    if (norms < (1 - eps_D) * Delta):
        msg=matlabarray([char('interior solution ( '),int2str_(nfact),char(' factorizations,  lambda = '),num2str_(_lambda),char(')')])
    else:
        msg=matlabarray([char('boundary solution ( '),int2str_(nfact),char(' factorizations, '),int2str_(neigd),char(' eigen decomposition, lambda = '),num2str_(_lambda),char(' )')])
    if (verbose):
        disp_(char(' bcdfo_solve_TR_MS : ============ hard case exit'))
    return s,_lambda,norms,value,gplus,nfact,neigd,msg,hardcase
def bcdfo_solve_TR_MS_bc_(g=None,H=None,lb=None,ub=None,Delta=None,eps_D=None,stratLam=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 7-[g,H,lb,ub,Delta,eps_D,stratLam].count(None)+len(args)

    verbose=0
    theta=1e-13
    eps_bound=1e-05
    msg=char('no free variables')
    _lambda=0
    value=0
    nfact=0
    neigd=0
    Delta0=copy_(Delta)
    g0=copy_(g)
    gplus=copy_(g)
    s=zeros_(size_(g))
    norms=0
    n=length_(g)
    I=eye_(n)
    ind_active=matlabarray([])
    ind_free=arange_(1,n)
    nfree=copy_(n)
    if (verbose):
        disp_(char('bcdfo_solve_TR_MS_bc: enter'))
    if (not isempty_(find_(isnan_(H)))):
        if (verbose):
            disp_(char('Error in bcdfo_solve_TR_MS_bc: H contains NaNs!'))
        msg=char('error1')
        if (verbose):
            disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
        return s,_lambda,norms,value,gplus,nfact,neigd,msg
    if (not isempty_(find_(not isreal_(H)))):
        if (verbose):
            disp_(char('Error in bcdfo_solve_TR_MS_bc: H contains imaginary parts!'))
        msg=char('error2')
        if (verbose):
            disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
        return s,_lambda,norms,value,gplus,nfact,neigd,msg
    if (not isempty_(find_(isinf_(H)))):
        if (verbose):
            disp_(char('Error in bcdfo_solve_TR_MS_bc: H contains infinite elements!'))
        msg=char('error3')
        if (verbose):
            disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
        return s,_lambda,norms,value,gplus,nfact,neigd,msg
    ind_g_crit=find_((abs_(lb) <= 1e-10 and g > 0) or (ub <= 1e-10 and g < 0))
    if (not isempty_(ind_g_crit)):
        ind_active=ind_free[ind_g_crit]
        ind_free=setdiff_(ind_free,ind_active)
        nfree=length_(ind_free)
    j=0
    while nfree > 0:

        new_call_to_MS=1
        while (new_call_to_MS == 1):

            j=j + 1
            if (verbose >= 1):
                disp_([char('('),num2str_(j),char(') ---- minimizing in the (sub)space of '),num2str_(length_(ind_free)),char(' variable(s)')])
            g_reduced=g[ind_free]
            H_reduced=H[ind_free,ind_free]
            s_deltaMS,_lambda,norms_deltaMS,value_red,gplus_red,nfact_r,neigd_r,msg,hardcase=bcdfo_solve_TR_MS_(g_reduced,H_reduced,Delta,eps_D,nargout=9)
            nfact=nfact + nfact_r
            neigd=neigd + neigd_r
            gplus[ind_free]=gplus[ind_free] + gplus_red
            s_after_reduced_ms=s + I[:,ind_free] * s_deltaMS
            ind_u_crit=find_((ub[ind_free] - s_after_reduced_ms[ind_free]) <= eps_bound and ub[ind_free] <= 1e-10)
            ind_l_crit=find_((s_after_reduced_ms[ind_free] - lb[ind_free]) <= eps_bound and lb[ind_free] >= - 1e-10)
            if (length_(ind_u_crit) + length_(ind_l_crit) != 0):
                ind_active=matlabarray([ind_active,ind_free[ind_u_crit],ind_free[ind_l_crit]])
                ind_free=setdiff_(arange_(1,n),ind_active)
                nfree=length_(ind_free)
                if (verbose):
                    disp_(char('fixed one or more variables'))
                if (nfree == 0):
                    norms=norm_(s)
                    value=0.5 * s.T * H * s + s.T * g0
                    if (verbose):
                        disp_(char('no inactive variables anymore - return'))
                        disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
                    return s,_lambda,norms,value,gplus,nfact,neigd,msg
            else:
                new_call_to_MS=0

        if (verbose == 2):
            disp_(char('check if step inside bounds'))
        out_of_ubound=find_((ub[ind_free] - s_after_reduced_ms[ind_free]) < 0.0)
        out_of_lbound=find_((s_after_reduced_ms[ind_free] - lb[ind_free]) < 0.0)
        out_of_ubound_init=copy_(out_of_ubound)
        out_of_lbound_init=copy_(out_of_lbound)
        if (length_(out_of_ubound) + length_(out_of_lbound) != 0):
            back_inside=0
            lambda0=copy_(_lambda)
            if (verbose == 2):
                disp_(char('step outside bounds!'))
                out_of_ubound
                out_of_lbound
                disp_([char('lambda_0='),num2str_(lambda0)])
            lower=copy_(_lambda)
            if (stratLam == 0):
                _lambda=max_(2.0,2 * _lambda)
            gnorm=norm_(g)
            if (length_(out_of_ubound) > 0):
                delta_b=min_(abs_(ub[ind_free[out_of_ubound]] - s[ind_free[out_of_ubound]]))
            if (length_(out_of_lbound) > 0):
                delta_b=min_(abs_(lb[ind_free[out_of_lbound]] - s[ind_free[out_of_lbound]]))
                if (length_(out_of_ubound) > 0):
                    delta_b=min_(min_(abs_(ub[ind_free[out_of_ubound]] - s[ind_free[out_of_ubound]])),delta_b)
            goverD=gnorm / delta_b
            Hnorminf=norm_(H,inf)
            if (Hnorminf > 0):
                HnormF=norm_(H,char('fro'))
            else:
                HnormF=0
            upper=max_(0,goverD + min_(Hnorminf,HnormF))
            ind_u_active=find_(abs_(ub[ind_free] - s_after_reduced_ms[ind_free]) <= eps_bound)
            ind_l_active=find_(abs_(s_after_reduced_ms[ind_free] - lb[ind_free]) <= eps_bound)
            i=0
            while (((length_(ind_u_active) + length_(ind_l_active)) == 0) or (length_(out_of_lbound) + length_(out_of_ubound) != 0)):

                i=i + 1
                old_lambda=copy_(_lambda)
                new_lambda=- 1
                if (verbose):
                    disp_([char(' bcdfo_solve_TR_MS_bc ('),int2str_(i),char('): lower = '),num2str_(lower),char(' lambda = '),num2str_(_lambda),char(' upper = '),num2str_(upper)])
                R,p=chol_(H[ind_free,ind_free] + _lambda * eye_(nfree),nargout=2)
                if (not isempty_(find_(isnan_(R)))):
                    H
                    _lambda
                    norm_(g)
                    R
                    p
                    disp_(char('Error in bcdfo_solve_TR_MS_bc: NaNs in Cholesky factorization'))
                    msg=char('error4')
                    if (verbose):
                        disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
                    return s,_lambda,norms,value,gplus,nfact,neigd,msg
                nfact=nfact + 1
                if (p == 0 and hardcase == 0):
                    warning_(char('off'))
                    s_deltaH=numpy.linalg.solve(- R,(numpy.linalg.solve(R.T,g[ind_free])))
                    s_duringH=s + I[:,ind_free] * s_deltaH
                    ind_u_crit=find_((ub[ind_free] - s_duringH[ind_free]) <= eps_bound and ub[ind_free] <= 1e-10)
                    ind_l_crit=find_((s_duringH[ind_free] - lb[ind_free]) <= eps_bound and lb[ind_free] >= - 1e-10)
                    if (length_(ind_u_crit) != 0):
                        s_deltaH[ind_u_crit]=0.0
                        s_duringH[ind_free[ind_u_crit]]=0.0
                    if (length_(ind_l_crit) != 0):
                        s_deltaH[ind_l_crit]=0.0
                        s_duringH[ind_free[ind_l_crit]]=0.0
                    out_of_ubound=find_((ub[ind_free] - s_duringH[ind_free]) < 0.0)
                    out_of_lbound=find_((s_duringH[ind_free] - lb[ind_free]) < 0.0)
                    if (stratLam == 1 or verbose > 0):
                        if ((length_(out_of_ubound) != 0) or (length_(out_of_lbound) != 0)):
                            outside=1
                            if (length_(out_of_ubound) != 0):
                                diff_b_u,ind_b_u=max_(abs_(ub[ind_free[out_of_ubound]] - s_duringH[ind_free[out_of_ubound]]),nargout=2)
                                norms_b=abs_(s_deltaH[out_of_ubound[ind_b_u]])
                                delta_b=abs_(ub[ind_free[out_of_ubound[ind_b_u]]] - s[ind_free[out_of_ubound[ind_b_u]]])
                                ind_b=out_of_ubound[ind_b_u]
                                sign_b=sign_(ub[ind_free[out_of_ubound[ind_b_u]]] - s[ind_free[out_of_ubound[ind_b_u]]])
                                out_of_ubound_init=matlabarray([[out_of_ubound_init],[out_of_ubound]])
                            if (length_(out_of_lbound) != 0):
                                diff_b_l,ind_b_l=max_(abs_(s_duringH[ind_free[out_of_lbound]] - lb[ind_free[out_of_lbound]]),nargout=2)
                                norms_b=abs_(s_deltaH[out_of_lbound[ind_b_l]])
                                delta_b=abs_(lb[ind_free[out_of_lbound[ind_b_l]]] - s[ind_free[out_of_lbound[ind_b_l]]])
                                ind_b=out_of_lbound[ind_b_l]
                                sign_b=sign_(lb[ind_free[out_of_lbound[ind_b_l]]] - s[ind_free[out_of_lbound[ind_b_l]]])
                                out_of_lbound_init=matlabarray([[out_of_lbound_init],[out_of_lbound]])
                            if ((length_(out_of_ubound) != 0) and (length_(out_of_lbound) != 0)):
                                if (diff_b_u > diff_b_l):
                                    norms_b=abs_(s_deltaH[out_of_ubound[ind_b_u]])
                                    delta_b=abs_(ub[ind_free[out_of_ubound[ind_b_u]]] - s[ind_free[out_of_ubound[ind_b_u]]])
                                    ind_b=out_of_ubound[ind_b_u]
                                    sign_b=sign_(ub[ind_free[out_of_ubound[ind_b_u]]] - s[ind_free[out_of_ubound[ind_b_u]]])
                                else:
                                    norms_b=abs_(s_deltaH[out_of_lbound[ind_b_l]])
                                    delta_b=abs_(lb[ind_free[out_of_lbound[ind_b_l]]] - s[ind_free[out_of_lbound[ind_b_l]]])
                                    ind_b=out_of_lbound[ind_b_l]
                                    sign_b=sign_(lb[ind_free[out_of_lbound[ind_b_l]]] - s[ind_free[out_of_lbound[ind_b_l]]])
                        else:
                            outside=0
                            if (length_(out_of_ubound_init) != 0):
                                diff_b_u,ind_b_u=min_(abs_(ub[ind_free[out_of_ubound_init]] - s_duringH[ind_free[out_of_ubound_init]]),nargout=2)
                                norms_b=abs_(s_deltaH[out_of_ubound_init[ind_b_u]])
                                delta_b=abs_(ub[ind_free[out_of_ubound_init[ind_b_u]]] - s[ind_free[out_of_ubound_init[ind_b_u]]])
                                ind_b=out_of_ubound_init[ind_b_u]
                                sign_b=sign_(ub[ind_free[out_of_ubound_init[ind_b_u]]] - s[ind_free[out_of_ubound_init[ind_b_u]]])
                            if (length_(out_of_lbound_init) != 0):
                                diff_b_l,ind_b_l=min_(abs_(s_duringH[ind_free[out_of_lbound_init]] - lb[ind_free[out_of_lbound_init]]),nargout=2)
                                norms_b=abs_(s_deltaH[out_of_lbound_init[ind_b_l]])
                                delta_b=abs_(lb[ind_free[out_of_lbound_init[ind_b_l]]] - s[ind_free[out_of_lbound_init[ind_b_l]]])
                                ind_b=out_of_lbound_init[ind_b_l]
                                sign_b=sign_(lb[ind_free[out_of_lbound_init[ind_b_l]]] - s[ind_free[out_of_lbound_init[ind_b_l]]])
                            if ((length_(out_of_ubound_init) != 0) and (length_(out_of_lbound_init) != 0)):
                                if (diff_b_u < diff_b_l):
                                    norms_b=abs_(s_deltaH[out_of_ubound_init[ind_b_u]])
                                    delta_b=abs_(ub[ind_free[out_of_ubound_init[ind_b_u]]] - s[ind_free[out_of_ubound_init[ind_b_u]]])
                                    ind_b=out_of_ubound_init[ind_b_u]
                                    sign_b=sign_(ub[ind_free[out_of_ubound_init[ind_b_u]]] - s[ind_free[out_of_ubound_init[ind_b_u]]])
                                else:
                                    norms_b=abs_(s_deltaH[out_of_lbound_init[ind_b_l]])
                                    delta_b=abs_(lb[ind_free[out_of_lbound_init[ind_b_l]]] - s[ind_free[out_of_lbound_init[ind_b_l]]])
                                    ind_b=out_of_lbound_init[ind_b_l]
                                    sign_b=sign_(lb[ind_free[out_of_lbound_init[ind_b_l]]] - s[ind_free[out_of_lbound_init[ind_b_l]]])
                    if (verbose):
                        lambda_save[i]=_lambda
                        norms_b_save[i]=norms_b
                        if (outside == 0):
                            fprintf_(1,char('%s%d%s %12.8e %s %12.8e %s\\n'),char(' bcdfo_solve_TR_MS_bc ('),i,char('): |s_i| = '),norms_b,char('  |bound_i| = '),delta_b,char('   s < bounds'))
                        else:
                            fprintf_(1,char('%s%d%s %12.8e %s %12.8e\\n'),char(' bcdfo_solve_TR_MS_bc ('),i,char('): |s_i| = '),norms_b,char('  |bound_i| = '),delta_b)
                    out_of_uEpsbound=find_((ub[ind_free] - s_duringH[ind_free]) < - eps_bound)
                    out_of_lEpsbound=find_((s_duringH[ind_free] - lb[ind_free]) < - eps_bound)
                    if (isempty_(out_of_uEpsbound) and isempty_(out_of_lEpsbound)):
                        if (verbose >= 2):
                            disp_(char('all components inside the bounds + eps_bound'))
                        back_inside=1
                        ind_u_active=find_(abs_(ub[ind_free] - s_duringH[ind_free]) <= eps_bound)
                        ind_l_active=find_(abs_(s_duringH[ind_free] - lb[ind_free]) <= eps_bound)
                        if ((length_(ind_u_active) + length_(ind_l_active)) != 0):
                            if (verbose >= 2):
                                disp_([char('all components inside the bounds + eps_bound, '),num2str_(length_(ind_u_active) + length_(ind_l_active)),char(' component/s close to one of its bounds')])
                            s_afterH=s + I[:,ind_free] * s_deltaH
                            if (length_(ind_u_active) > 0):
                                s_afterH[ind_free[ind_u_active]]=ub[ind_free[ind_u_active]]
                            if (length_(ind_l_active) > 0):
                                s_afterH[ind_free[ind_l_active]]=lb[ind_free[ind_l_active]]
                            msg=char('boundary solution')
                            break
                    if (stratLam == 0):
                        if (back_inside == 0):
                            _lambda=2 * _lambda
                            if (upper < _lambda):
                                upper=2 * _lambda
                        else:
                            if (isempty_(out_of_ubound) and isempty_(out_of_lbound)):
                                upper=copy_(_lambda)
                            else:
                                lower=copy_(_lambda)
                            new_lambda=(_lambda + old_lambda) / 2
                            theta_range=theta * (upper - lower)
                            if (new_lambda > lower + theta_range and new_lambda < upper - theta_range):
                                _lambda=copy_(new_lambda)
                            else:
                                _lambda=max_(sqrt_(lower * upper),lower + theta_range)
                    else:
                        if (isempty_(out_of_ubound) and isempty_(out_of_lbound)):
                            upper=copy_(_lambda)
                        else:
                            lower=copy_(_lambda)
                        unitvec=zeros_(nfree,1)
                        unitvec[ind_b]=1
                        es=unitvec.T * s_deltaH
                        if (sign_(es) != sign_b):
                            new_lambda=(lower + upper) / 2
                        else:
                            w1=numpy.linalg.solve(R.T,unitvec)
                            w2=numpy.linalg.solve(R.T,s_deltaH)
                            new_lambda=_lambda + ((norms_b - delta_b) / delta_b) * (norms_b ** 2 / (es * (w1.T * w2)))
                            if (back_inside == 0 and upper <= new_lambda):
                                upper=2 * new_lambda
                        theta_range=theta * (upper - lower)
                        if (new_lambda > lower + theta_range and new_lambda <= upper - theta_range):
                            _lambda=copy_(new_lambda)
                        else:
                            _lambda=real_(max_(sqrt_(lower * upper),lower + theta_range))
                else:
                    if (verbose):
                        disp_(char('unsuccessful factorization'))
                    hardcase=0
                    lower=copy_(_lambda)
                    t=0.5
                    _lambda=(1 - t) * lower + t * upper
                if (i >= 100):
                    s[1:n]=0.0
                    norms=0
                    msg=char('limit in bc-MS exceeded')
                    if (verbose):
                        disp_(char('Error in bcdfo_solve_TR_MS_bc: iteration limit in bc-MS exceeded!'))
                        disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
                    return s,_lambda,norms,value,gplus,nfact,neigd,msg

        else:
            if (verbose >= 2):
                disp_(char('step inside bounds!'))
            msg=char('(partly) interior solution')
            s=copy_(s_after_reduced_ms)
            norms=norm_(s)
            value=0.5 * s.T * H * s + s.T * g0
            if (verbose):
                disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
            return s,_lambda,norms,value,gplus,nfact,neigd,msg
        s=copy_(s_afterH)
        norms=norm_(s)
        value=0.5 * s.T * H * s + s.T * g0
        Delta=Delta0 - norms
        if (Delta < - eps_bound):
            disp_(char('Error in bcdfo_solve_TR_MS_bc: delta smaller than zero !!!!!!'))
            msg=char('error7')
            if (verbose):
                disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
            return s,_lambda,norms,value,gplus,nfact,neigd,msg
        else:
            if (Delta < 0):
                if (verbose):
                    disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
                return s,_lambda,norms,value,gplus,nfact,neigd,msg
        g=g0 + H * s
        ind_active=find_((ub - s) <= eps_bound or (s - lb) <= eps_bound)
        ind_active=ind_active.T
        ind_free=setdiff_(arange_(1,n),ind_active)
        nfree=length_(ind_free)
        if (nfree > 0):
            ng_reduced=norm_(g[ind_free],inf)
            if (ng_reduced <= 1e-05):
                if (verbose >= 2):
                    disp_(char('point first order critical - return'))
                    ng_reduced
                if (verbose):
                    disp_(char('bcdfo_solve_TR_MS_bc: exit!'))
                return s,_lambda,norms,value,gplus,nfact,neigd,msg
            ind_g_crit=find_((abs_(lb[ind_free]) <= 1e-10 and g[ind_free] > 0) or (ub[ind_free] <= 1e-10 and g[ind_free] < 0))
            if (length_(ind_g_crit) != 0):
                ind_active=matlabarray([ind_active,ind_free[ind_g_crit]])
                ind_free=setdiff_(ind_free,ind_active)
                nfree=length_(ind_free)

    return s,_lambda,norms,value,gplus,nfact,neigd,msg
