# -*- coding: utf-8 -*-
"""
Created on Wed Nov 12 14:50:00 2014
%
% [feas,compl,info] = ecdfo_optimality (simul,x,lm,lb,ub,info,options,values)

%-----------------------------------------------------------------------
%
% Author: Jean Charles Gilbert, INRIA
%     and Anke Troeltzsch, DLR.
%
% Copyright 2008, 2009, INRIA. 2013, DLR.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Q Public
% License version 1.0 for more details.
%
% You should have received a copy of the Q Public License version 1.0
% along with this program.  If not, see
% <http://doc.trolltech.com/3.0/license.html>.
%
%-----------------------------------------------------------------------

global threshold
%threshold = 1e-16;   % must be the same threshold for violated bounds as in ecdfo_solve_TR_bc

% Dimensions
@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py ecdfo_optimality.m

from __future__ import division
#try:
from runtime import *
from copy import copy
#except ImportError:
    #from smop.runtime import *
def ecdfo_optimality_(x=None,lm=None,lb=None,ub=None,info_=None,options=None,*args,**kwargs):
#    varargin = cellarray(args)
#    nargin = 6-[x,lm,lb,ub,info,options].count(None)+len(args)

    info=copy(info_)
    n=length_(info.g)
    mi=length_(info.ci)
    me=length_(info.ce)
    info.glag=info.g
    gradlag=info.g
    bounds=(abs_(lb - x) < 1e-05) + (abs_(ub - x) < 1e-05)
    if options.verbose >= 4:
        fprintf_('\n     lb             x            ub             g            lm\n')
        for i in arange_(1,n).reshape(-1):
            fprintf_('%12.5e  %12.5e  %12.5e  %12.5e  %12.5e\n'%(lb[i],x[i],ub[i],info.glag[i],lm[i]))
    I=find_(bounds[1:n])
    info.glag[I]=info.glag[I] + lm[I]
    boundsmult=lm[I]
    gradlag=info.glag
    if mi > 0:
        I=find_(bounds[n + 1:n + mi])
        info.glag=info.glag + info.ai(I,arange_()).T * lm[n + I]
    if me > 0:
        derivequcons=info.ae
        equmult=lm[n + mi + 1:n + mi + me]
        info.glag=info.glag + info.ae.T * lm[n + mi + 1:n + mi + me]
        gradlag=info.glag
#    feas=matlabarray([[max_(0,max_([[x],[info.ci]] - ub,lb - [[x],[info.ci]]))],[info.ce]])
#    v=matlabarray([[x],[info.ci]])
    feas=concatenate_([max_(0,max_(concatenate_([x, info.ci]) - ub, lb - concatenate_([x,info.ci]))) ,
										info.ce])
    v=concatenate_([x,info.ci])
    compl=zeros_(n + mi,1)
    I=find_(logical_and(lb > - options.inf,abs_(lb - v) > options.dxmin))
    if not isempty_(I):
        compl[I]=max_(compl[I],max_(0,- lm[I]))
    I=find_(logical_and(ub < options.inf,abs_(ub - v) > options.dxmin))
    if not isempty_(I):
        compl[I]=max_(compl[I],max_(0,lm[I]))
    return feas,compl,info
#def ecdfo_optimality_(x=None,lm=None,lb=None,ub=None,info=None,options=None,*args,**kwargs):
#    #varargin = cellarray(args)
#    #nargin = 6-[x,lm,lb,ub,info,options].count(None)+len(args)
#
#    global threshold
#    n=length_(info.g)
#    mi=length_(info.ci)
#    me=length_(info.ce)
#    info.glag=info.g
#    gradlag=info.g
#    bounds=(abs_(lb - x) < 1e-05) + (abs_(ub - x) < 1e-05)
#    if options.verbose >= 4:
#        fprintf_(char('\\n     lb             x            ub             g            lm\\n'))
#        for i in arange_(1,n).reshape(-1):
#            fprintf_(char('%12.5e  %12.5e  %12.5e  %12.5e  %12.5e\\n'),lb[i],x[i],ub[i],info.glag[i],lm[i])
#    I=find_(bounds[1:n])
#    info.glag[I]=info.glag[I]+ lm[I]
#    boundsmult=lm[I]
#    gradlag=info.glag
#    if mi > 0:
#        I=find_(bounds[n + 1:n + mi])
#        info.glag=info.glag + info.ai(I,arange_()).T * lm[n + I]
#    if me > 0:
#        derivequcons=info.ae
#        equmult=lm[n + mi + 1:n + mi + me]
#        #print "info.ae.T", info.ae.T								
#        #print "lm[n + mi + 1:n + mi + me]", lm[n + mi + 1:n + mi + me]
#        #print "lm", lm
#        #print "type(lm)", type(lm)								
#        info.glag=info.glag + info.ae.T * lm[n + mi + 1:n + mi + me].T
#        gradlag=info.glag
#    #print "x", x
#    #print "x shape", x.shape				
#    #print "info.ci", info.ci								
#    #print "info.ci shape", info.ci.shape				
#    #print "info.ce", info.ce												
#    #print "ub", ub
#    ##print "info.ci", info.ci								    				
#    #print "[...]", [[x],[info.ci]]
#    #print "lb", lb								
#    #print "second", lb - concatenate_([x,info.ci])
#    #print "first", concatenate_([x, info.ci]) - ub								
#    #feas=matlabarray([[ max_(0,  max_(  [[x], [info.ci]] - ub,  lb - [[x],[info.ci]]   )   ) ],
##										[info.ce]])
#   # print "concatenate_([x, info.ci]) - ub", concatenate_([x, info.ci]) -ub				
#   # print "ub", ub				
#    				
#    feas=concatenate_([ max_(0,  max_(  concatenate_([x, info.ci]) - ub, lb - concatenate_([x,info.ci])   )   ) ,
#										info.ce])
#    #print "feas:\n", feas, "\n\n\n"										
#    #v=matlabarray([[x],[info.ci]])
#    v=concatenate_([x,info.ci])
#    #print "v:\n", v, "\n\n\n"				
#    compl=zeros_(n + mi,1)
#    #print "n + mi,1", n + mi,",1"				
#    #print "compl", compl				
#    #print "----"				
#    #print "bitwise &", (lb > - options.inf) & (abs_(lb - v) > options.dxmin)				
#    #print "----"				
#    I=find_((lb > - options.inf) & (abs_(lb - v) > options.dxmin))
#    if not isempty_(I):
#        compl[I]=max_(compl[I],max_(0,- lm[I]))
#    I=find_((ub < options.inf) & (abs_(ub - v) > options.dxmin))
#    if not isempty_(I):
#        compl[I]=max_(compl[I],max_(0,lm[I]))
#    return feas,compl,info
