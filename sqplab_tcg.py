# -*- coding: utf-8 -*-
"""
Created on Wed Nov 12 13:52:22 2014
% [x,info] = sqplab_tcg (A,b,delta,max_iter,tol,plevel,fout);
%
% Solves A x = b for x, by Steihaug's conjugate gradient (CG) method,
% where A is a symmetric (possibly indefinite) matrix. CG iterations
% starts from x = 0, up to one of the situations described below by info
% occurs.
%
% On entry
%   A: symmetric matrix of the linear system
%   b: RHS of the linear system
%   delta: trust region radius
%   max_iter: maximum iterations allowed
%   tol: x is considered a solution if the Euclidean norm of the
%     gradient A*x-b is less than tol.
%   plevel: printing level
%     =0: don't print anything
%     >0; print on fout
%   fout: printing channel
%
% On return
%   info is a structure providing information on the run
%     info.curv is the last encountered curvature d'*Ad/(d'*d) (not a
%       field if no iteration has been performed)
%     info.flag is the return code
%       = 0: convergence is obtained, up to the given tolerance tol: the
%            final x is the solution of the LS,
%       =-1: stop on max_iter,
%       = 1: the boundary of the ball of radius delta is encountered:
%            the final x is on the boundary of the ball
%       = 2: a negative curvature direction has been encountered: the
%            final x is on the boundary of the ball.
%     info.iter is the number of CG iterations
%     info.prec is the final precision, the l2-norm of the residual A*x-b
%   x is the computed approximate solution

%-----------------------------------------------------------------------
%
% Author: Jean Charles Gilbert, INRIA.
%
% Copyright 2008, 2009, INRIA.
%
% SQPlab is distributed under the terms of the Q Public License version
% 1.0.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Q Public
% License version 1.0 for more details.
%
% You should have received a copy of the Q Public License version 1.0
% along with this program.  If not, see
% <http://doc.trolltech.com/3.0/license.html>.
%
%-----------------------------------------------------------------------

% Initialization

@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py sqplab_tcg.m

from __future__ import division
#try:
from runtime import *
#except ImportError:
#from smop.runtime import *


def sqplab_tcg_(A=None,b=None,delta=None,max_iter=None,tol=None,plevel=None,fout=None,*args,**kwargs):
#    varargin = cellarray(args)
#    nargin = 7-[A,b,delta,max_iter,tol,plevel,fout].count(None)+len(args)

    x=zeros_(size_(b))
    cost=0
    g=- b
    g2=g.T * g
    tol2=tol * tol
    delta2=delta * delta
    dAd=matlabarray([])
    if plevel:
        fprintf_(fout,char('    TCG solver; required tolerance %8.2e\\n'),tol)
        fprintf_(fout,char('    iter       cost        |res|   curvature  stepsize   |step|\\n'))
    _iter=0
    while 1:

        _iter=_iter + 1
        if plevel:
            fprintf_(fout,char('    %4i  %14.7e  %7.1e'),_iter,cost,sqrt_(g2))
        if g2 <= tol2:
            info.flag=0
            break
        if _iter > max_iter:
            _iter=copy_(max_iter)
            info.flag=- 1
            break
        if _iter == 1:
            d=- g
        else:
            d=- g + (g2 / g2_) * d
        Ad=A * d
        dAd=d.T * Ad
        if plevel:
            fprintf_(fout,char('  %9.2e'),dAd / (d.T * d))
        if dAd <= 0:
            x,alpha=dogleg_(x,x + d,delta,nargout=2)
            info.flag=2
            if plevel:
                fprintf_(fout,char('  %8.2e  %8.2e\\n'),alpha,norm_(x))
                cost=0.5 * (x.T * A * x) - b.T * x
                fprintf_(fout,char('    %4i  %14.7e  %7.1e\\n'),_iter + 1,cost)
            break
        alpha=- (g.T * d) / dAd
        xx=x + alpha * d
        if plevel:
            fprintf_(fout,char('  %8.2e'),alpha)
        if xx.T * xx > delta2:
            x,alpha=dogleg_(x,xx,delta,nargout=2)
            info.flag=1
            if plevel:
                fprintf_(fout,char('  %8.2e  %8.2e\\n'),alpha,norm_(x))
                cost=0.5 * (x.T * A * x) - b.T * x
                fprintf_(fout,char('    %4i  %14.7e  %7.1e\\n'),_iter + 1,cost)
            break
        else:
            x=copy_(xx)
        if plevel:
            fprintf_(fout,char('  %8.2e\\n'),norm_(x))
        g=g + alpha * Ad
        g2_=copy_(g2)
        g2=g.T * g
        if plevel:
            cost=0.5 * (x.T * (g - b))

    info.iter=_iter
    info.prec=sqrt_(g2)
    if not isempty_(dAd):
        info.curv=dAd / (d.T * d)
    return x,info

def dogleg_(dc=None,dn=None,delta=None,*args,**kwargs):
#    varargin = cellarray(args)
#    nargin = 3-[dc,dn,delta].count(None)+len(args)

    dd=dn - dc
    aa=dd.T * dd
    if aa == 0:
        dd=copy_(dc)
        t=0
        return dd,t
    bb=dc.T * dd
    cc=dc.T * dc - delta ** 2
    if cc >= 0:
        dd=copy_(dc)
        t=0
        return dd,t
    t=(sqrt_(bb ** 2 - aa * cc) - bb) / aa
    dd=dc + t * dd
    return dd,t

#class tcgInfo():
#	def __init__(self):
#		self.flag = None# 0
#		self.iter = None# 2
#		self.prec = None# 0
#		self.curv = None# 1

#def sqplab_tcg_(A=None,b=None,delta=None,max_iter=None,tol=None,plevel=None,fout=None,*args,**kwargs):
#    #varargin = cellarray(args)
#    #nargin = 7-[A,b,delta,max_iter,tol,plevel,fout].count(None)+len(args)
#    #print "b",b
#    #print "size_(b)",size_(b)
#
#    info = tcgInfo()
#				
#    x=zeros_(size_(b)[0])
#    cost=0
#    g=- b
#    g2=g.T * g
#    tol2=tol * tol
#    delta2=delta * delta
#    dAd=matlabarray([])
#    if plevel:
#        fprintf_(fout,char('    TCG solver; required tolerance %8.2e\\n'),tol)
#        fprintf_(fout,char('    iter       cost        |res|   curvature  stepsize   |step|\\n'))
#    _iter=0
#    while 1:
#
#        _iter=_iter + 1
#        if plevel:
#            fprintf_(fout,char('    %4i  %14.7e  %7.1e'),_iter,cost,sqrt_(g2))
#        if g2 <= tol2:
#            info.flag=0
#            break
#        if _iter > max_iter:
#            _iter=copy_(max_iter)
#            info.flag=- 1
#            break
#        if _iter == 1:
#            d=- g
#            #print "d = -g", d												
#        else:
#            d=- g + (g2 / g2_) * d
#           # print "d = -g + (...) * d", d												
#        Ad=A * d
#        #print "A\n", A								
#        #print "d\n", d
#        #print "Ad\n", Ad								
#        #dAd=d.T * Ad
#        dAd=np.dot(d, Ad)								
#        if plevel:
#            fprintf_(fout,char('  %9.2e'),dAd / (d.T * d))
#        if dAd <= 0:
#            x,alpha=dogleg_(x,x + d,delta,nargout=2)
#            info.flag=2
#            if plevel:
#                fprintf_(fout,char('  %8.2e  %8.2e\\n'),alpha,norm_(x))
#                cost=0.5 * (x.T * A * x) - b.T * x
#                fprintf_(fout,char('    %4i  %14.7e  %7.1e\\n'),_iter + 1,cost)
#            break
#        alpha=- (g.T * d) / dAd
#        xx=x + alpha * d
#        if plevel:
#            fprintf_(fout,char('  %8.2e'),alpha)
#        if xx.T * xx > delta2:
#            x,alpha=dogleg_(x,xx,delta,nargout=2)
#            info.flag=1
#            if plevel:
#                fprintf_(fout,char('  %8.2e  %8.2e\\n'),alpha,norm_(x))
#                cost=0.5 * (x.T * A * x) - b.T * x
#                fprintf_(fout,char('    %4i  %14.7e  %7.1e\\n'),_iter + 1,cost)
#            break
#        else:
#            x=copy_(xx)
#        if plevel:
#            fprintf_(fout,char('  %8.2e\\n'),norm_(x))
#        g=g + alpha * Ad
#        g2_=copy_(g2)
#        g2=g.T * g
#        if plevel:
#            cost=0.5 * (x.T * (g - b))
#
#    info.iter=_iter
#    info.prec=sqrt_(g2)
#    if not isempty_(dAd):
#        info.curv=dAd / (d.T * d)
#    return x,info


#				
#def dogleg_(dc=None,dn=None,delta=None,*args,**kwargs):
#    """%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#% Nested function %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#
#function [dd,t] = dogleg (dc, dn, delta)
#
#% [dd,t] = dogleg (dc, dn, delta)
#%
#% Find the step dd at the intersection of the sphere of radius delta
#% (>0) and the half-line dc -> dn. It is assumed that norm(dc) < min
#% (delta,norm(dn)).
#
#% Some variable (including the coefficients of the polynomial) are
#% named by two letters (aa, bb, cc, and dd) to avoid conflict with the
#% variables in the outer function (in particular b and d)
#
#dd = dn-dc;	% direction of move
#
#aa = dd'*dd;
#if aa == 0, dd = dc; t = 0; return; end
#
#bb = dc'*dd;
#
#cc = dc'*dc - delta^2;
#if cc >= 0, dd = dc; t = 0; return; end
#
#t = (sqrt(bb^2-aa*cc) - bb) / aa;
#dd = dc + t * dd;
#
#return
#
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#% End of nested functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"""
#    #varargin = cellarray(args)
#    #nargin = 3-[dc,dn,delta].count(None)+len(args)
#
#    dd=dn - dc
#    aa=dd.T * dd
#    if aa == 0:
#        dd=copy_(dc)
#        t=0
#        return dd,t
#    bb=dc.T * dd
#    cc=dc.T * dc - delta ** 2
#    if cc >= 0:
#        dd=copy_(dc)
#        t=0
#        return dd,t
#    t=(sqrt_(bb ** 2 - aa * cc) - bb) / aa
#    dd=dc + t * dd
#    return dd,t
