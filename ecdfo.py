# -*- coding: utf-8 -*-
"""
Created on Wed Feb 11 13:01:26 2015

@author: jaco_da
"""

# Autogenerated with SMOP version 
# c:\Users\jaco_da\AppData\Local\Continuum\Anaconda\Scripts\smop-script.py ecdfo.m

from __future__ import division
import helper
import numpy as np
from ecdfo_main import ecdfo_main_

from ecdfo_prelim import ecdfo_prelim_

try:
    from runtime import *
except ImportError:
    from smop.runtime import *
				
def set_prob(value):
	global prob
	prob = value

eps =  2.2204e-16
prob = 3

def ecdfo_(func=None,x0=None,lm0=None,lb=None,ub=None,options=None,*args,**kwargs):
    #varargin = cellarray(args)
    nargin = 6-[func,x0,lm0,lb,ub,options].count(None)+len(args)

    c = helper.dummyUnionStruct()
    info = helper.dummyUnionStruct()

    global prob,threshold
    c.free=0
    c.fixed=1
    c.alwaysfixed=2
    c.in_=1
    c.out=0
    c.unused=0
    c.inY=1
    c.dummy=1
    c.nodummy=0
    x=copy_(np.NaN)
    fx=copy_(np.NaN)
    gx=copy_(np.NaN)
    nit=0
    nitold=0
    neval=0
    errg=copy_(np.Inf)
    X=matlabarray([])
    fX=matlabarray([])
    xstatus=matlabarray([])
    sstatus=matlabarray([])
    dstatus=matlabarray([])
    sspace_save=matlabarray([])
    xspace_save=matlabarray([])
    ndummyY=0
    info.flag=0
    rand_(char('seed'),np.pi / sqrt_(2))
    randn_(char('seed'),5)
    if (size_(x0,1) == 1 and size_(x0,2) > 1):
        x0=x0.T
    n=length_(x0)
    pquad=((n + 1) * (n + 2)) / 2
    pdiag=2 * n + 1
    plin=n + 1
    msg=char('Unexpected exit')
    poisedness_known=0
    eps_rho=1e-14
    stallfact=10 * eps
    factor_Dmax=100000.0
    factor_fmax=1e+20
    CNTsin=0
    Delta0=1
    cur_degree=copy_(plin)
    rep_degree=copy_(plin)
    epsilon=1e-05
    maxeval=200 * n
    maxit=copy_(maxeval)
    verbose=1
    show_errg=0
    initial_Y=char('simplx')
    eta1=0.0001
    eta2=0.9
    gamma1=0.01
    gamma2=0.5
    gamma3=2.0
    interpol_TR=1
    factor_CV=100
    Lambda_XN=1e-10
    Lambda_CP=1.2
    Lambda_FP=1e-10
    factor_FPU=1
    factor_FPR=10
    criterion_S=char('distance')
    criterion_FP=char('distance')
    criterion_CP=char('standard')
    mu0=0
    mu=0
    theta=1
    eps_TR=0.0001
    eps_L=0.001
    shift_Y=1
    lSolver=1
    stratLam=1
    kappa_ill=1e+15
    kappa_th=2000
    eps_bnd=epsilon / 10
    whichmodel=0
    hardcons=0
    noisy=0
    scaleX=0
    scalefacX=ones_(1,n)
    shrink_Delta=1
    Deltamax=factor_Dmax * Delta0
    if nargin < 2:
        fprintf_(char('\\n### EC-DFO: the first 2 arguments are required\\n\\n'))
        x=matlabarray([])
        lm=matlabarray([])
        info.flag=1
        return x,lm,info
    if nargin < 3:
        lm0=matlabarray([])
    else:
        lm0=lm0[:]
    if nargin < 4:
        lb=matlabarray([])
    else:
        lb=lb[:]
    if nargin < 5:
        ub=matlabarray([])
    else:
        ub=ub[:]
    if nargin < 6:
        options.fout=1
        options.verbose=1
    if prob == 100:
        Delta0=0.01
        epsilon=0.001
        if exist_(char('fvalues_ecdfo_karmanogive.dat'),char('file')) == 2:
            delete_(char('fvalues_ecdfo_karmanogive.dat'))
    x0
    n,nb,mi,me,x,lm,lb,ub,scalefacX,Delta,nfix,indfix,xfix,vstatus,xstatus,sstatus,dstatus,QZ,RZ,scale,poised,Y_radius,poised_model,X,fX,Y,fY,ciX,ciY,ceX,ceY,poisedness_known,m,gx,normgx,fcmodel,ind_Y,i_xbest,cur_degree,rep_degree,plin,pdiag,pquad,indfree,info,options,values=ecdfo_prelim_(func,x0,lm0,Delta0,lb,ub,scaleX,scalefacX,cur_degree,rep_degree,plin,pdiag,pquad,c,initial_Y,kappa_ill,whichmodel,factor_FPR,Lambda_FP,Lambda_CP,eps_L,lSolver,hardcons,stratLam,xstatus,sstatus,dstatus,options,nargout=47)
    if info.flag:
        return x,lm,info
    x0=copy_(x)
    eps_current=max_(mu0 * normgx,epsilon)
    fxmax=min_(1e+25,factor_fmax * abs_(fx))
    M=eye_(n)
    if (verbose):
        fid=fopen_(char('convhist.m'),char('w'))
        fprintf_(fid,char('function A=history \\n A=[ \\n'))
        fprintf_(fid,char('%6d  %+.14e %.2e \\n'),neval,fx,normgx)
        fclose_(fid)
    nit,i_xbest,x,fx,m,X,fX,ciX,ceX,ind_Y,Delta,eps_current,cur_degree,fcmodel,gx,normgx,vstatus,xstatus,sstatus,dstatus,M,ndummyY,sspace_save,xspace_save,msg,CNTsin,neval,lm,info=ecdfo_main_(func,n,nb,mi,me,lm,nitold,nit,i_xbest,lb,ub,m,X,fX,ciX,ceX,ind_Y,QZ,RZ,Delta,cur_degree,neval,maxeval,maxit,fcmodel,gx,normgx,show_errg,pquad,pdiag,plin,stallfact,eps_rho,Deltamax,rep_degree,epsilon,verbose,eta1,eta2,gamma1,gamma2,gamma3,interpol_TR,factor_CV,Lambda_XN,Lambda_CP,factor_FPU,factor_FPR,Lambda_FP,criterion_S,criterion_FP,criterion_CP,mu,theta,eps_TR,eps_L,lSolver,stratLam,eps_current,vstatus,xstatus,sstatus.T,dstatus,ndummyY,sspace_save,xspace_save,xfix,fxmax,poised_model,M,kappa_ill,kappa_th,eps_bnd,poised,Y_radius,c,char('toplevel'),whichmodel,hardcons,noisy,scaleX,scalefacX,CNTsin,shrink_Delta,scale,shift_Y,info,options,values,nargout=29)
    if (verbose):
        fid=fopen_(char('convhist.m'),char('a'))
        fprintf_(fid,char('];'))
        fclose_(fid)
    if (nfix > 0):
        I=eye_(n + nfix)
        x=I[:,indfix] * xfix[indfix] + I[:,indfree] * x
        gx=I[:,indfix] * zeros_(nfix,1) + I[:,indfree] * gx
        Ilm=eye_(n + nfix + me + mi)
        indfree_lm=setdiff_(arange_(1,n + nfix + me + mi),indfix)
        lm=Ilm[:,indfix] * zeros_(nfix,1) + Ilm[:,indfree_lm] * lm
        n=n + nfix
    if (scaleX):
        x=x / scalefacX
    info_best=copy_(info)
    info_best.f=fx
    x=X[:,i_xbest]
    ecdfo_finish_(nb,mi,me,info_best,options,values)
    if options.verbose > 2:
        if nb:
            fprintf_(options.fout,char('VARIABLES:\\n'))
            fprintf_(options.fout,char('i     lower bound          x            upper bound       multiplier\\n'))
            for i in arange_(1,min_(n,40)).reshape(-1):
                fprintf_(options.fout,char('%0i %+16.6e %+16.6e %+16.6e %+16.6e\\n'),i,lb[i],x[i],ub[i],lm[i])
            if (n > 40):
                fprintf_(options.fout,char('.....\\n'))
            else:
                fprintf_(options.fout,char('\\n'))
        else:
            fprintf_(options.fout,char('VARIABLES:\\n'))
            fprintf_(options.fout,char('%16.6e\\n'),x[1:min_(n,40)])
            if (n > 40):
                fprintf_(options.fout,char('.....\\n'))
            else:
                fprintf_(options.fout,char('\\n'))
        if mi:
            fprintf_(options.fout,char('INEQUALITY CONSTRAINTS:\\n'))
            fprintf_(options.fout,char('i     lower bound          ci           upper bound       multiplier\\n'))
            for i in arange_(1,min_(mi,40)).reshape(-1):
                fprintf_(options.fout,char('%0i %+16.6e %+16.6e %+16.6e %+16.6e\\n'),i,lb[n + i],ciX[i,i_xbest],ub[n + i],lm[n + i])
            if (mi > 40):
                fprintf_(options.fout,char('\\n.....'))
            else:
                fprintf_(options.fout,char('\\n'))
        if me:
            fprintf_(options.fout,char('EQUALITY CONSTRAINTS:\\n'))
            fprintf_(options.fout,char('i         ce            multiplier\\n'))
            for i in arange_(1,min_(me,40)).reshape(-1):
                fprintf_(options.fout,char('%0i %+16.6e %+16.6e\\n'),i,ceX[i,i_xbest],lm[n + mi + i])
            if (me > 40):
                fprintf_(options.fout,char('.....\\n'))
            else:
                fprintf_(options.fout,char('\\n'))
    return x,lm,info
